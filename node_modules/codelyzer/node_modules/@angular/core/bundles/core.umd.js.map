{"version":3,"file":"core.umd.js","sources":["../../../../../external/npm/node_modules/tslib/tslib.es6.js","../../../../../../../packages/core/src/util/decorators.ts","../../../../../packages/core/src/di/metadata.ts","../../../../../../../../packages/core/src/di/interface/injector.ts","../../../../../../../packages/core/src/util/property.ts","../../../../../../../../packages/core/src/di/interface/defs.ts","../../../../../../../packages/core/src/util/stringify.ts","../../../../../packages/core/src/di/forward_ref.ts","../../../../../../../packages/core/src/util/global.ts","../../../../../../../packages/core/src/compiler/compiler_facade_interface.ts","../../../../../../../packages/core/src/compiler/compiler_facade.ts","../../../../../packages/core/src/render3/fields.ts","../../../../../../../packages/core/src/util/ng_dev_mode.ts","../../../../../packages/core/src/di/injection_token.ts","../../../../../packages/core/src/di/injector_compatibility.ts","../../../../../packages/core/src/di/jit/environment.ts","../../../../../packages/core/src/linker/ng_module_factory.ts","../../../../../../../packages/core/src/util/assert.ts","../../../../../../../packages/core/src/util/array_utils.ts","../../../../../packages/core/src/change_detection/constants.ts","../../../../../packages/core/src/metadata/view.ts","../../../../../../../packages/core/src/util/closure.ts","../../../../../packages/core/src/render3/empty.ts","../../../../../packages/core/src/render3/definition.ts","../../../../../packages/core/src/render3/interfaces/view.ts","../../../../../packages/core/src/render3/interfaces/container.ts","../../../../../packages/core/src/render3/interfaces/type_checks.ts","../../../../../packages/core/src/render3/assert.ts","../../../../../packages/core/src/render3/state.ts","../../../../../packages/core/src/render3/hooks.ts","../../../../../packages/core/src/render3/interfaces/injector.ts","../../../../../packages/core/src/render3/node_assert.ts","../../../../../packages/core/src/render3/interfaces/document.ts","../../../../../packages/core/src/render3/interfaces/renderer.ts","../../../../../packages/core/src/render3/util/attrs_utils.ts","../../../../../packages/core/src/render3/util/injector_utils.ts","../../../../../packages/core/src/render3/util/misc_utils.ts","../../../../../packages/core/src/render3/di.ts","../../../../../../../packages/core/src/util/errors.ts","../../../../../packages/core/src/errors.ts","../../../../../packages/core/src/error_handler.ts","../../../../../packages/core/src/metadata/schema.ts","../../../../../packages/core/src/sanitization/bypass.ts","../../../../../../../packages/core/src/util/is_dev_mode.ts","../../../../../packages/core/src/sanitization/inert_body.ts","../../../../../packages/core/src/sanitization/url_sanitizer.ts","../../../../../packages/core/src/sanitization/html_sanitizer.ts","../../../../../packages/core/src/sanitization/security.ts","../../../../../packages/core/src/sanitization/style_sanitizer.ts","../../../../../packages/core/src/sanitization/sanitization.ts","../../../../../../../packages/core/src/util/named_array_type.ts","../../../../../../../packages/core/src/util/ng_reflect.ts","../../../../../packages/core/src/render3/interfaces/context.ts","../../../../../packages/core/src/render3/util/view_utils.ts","../../../../../packages/core/src/render3/context_discovery.ts","../../../../../packages/core/src/render3/errors.ts","../../../../../packages/core/src/render3/interfaces/node.ts","../../../../../packages/core/src/render3/interfaces/projection.ts","../../../../../packages/core/src/render3/styling/class_differ.ts","../../../../../packages/core/src/render3/node_selector_matcher.ts","../../../../../packages/core/src/render3/tokens.ts","../../../../../packages/core/src/render3/util/view_traversal_utils.ts","../../../../../packages/core/src/render3/instructions/advance.ts","../../../../../packages/core/src/render3/interfaces/i18n.ts","../../../../../packages/core/src/render3/interfaces/styling.ts","../../../../../packages/core/src/render3/util/debug_utils.ts","../../../../../packages/core/src/render3/instructions/lview_debug.ts","../../../../../packages/core/src/render3/instructions/shared.ts","../../../../../packages/core/src/render3/node_manipulation.ts","../../../../../packages/core/src/render3/node_util.ts","../../../../../packages/core/src/render3/view_ref.ts","../../../../../packages/core/src/render3/view_engine_compatibility.ts","../../../../../packages/core/src/change_detection/change_detector_ref.ts","../../../../../../../packages/core/src/interface/type.ts","../../../../../../../packages/core/src/reflection/reflection_capabilities.ts","../../../../../packages/core/src/di/jit/util.ts","../../../../../packages/core/src/di/jit/injectable.ts","../../../../../packages/core/src/di/util.ts","../../../../../packages/core/src/di/injectable.ts","../../../../../packages/core/src/di/scope.ts","../../../../../packages/core/src/di/r3_injector.ts","../../../../../packages/core/src/di/injector.ts","../../../../../packages/core/src/di/reflective_errors.ts","../../../../../packages/core/src/di/reflective_key.ts","../../../../../../../packages/core/src/reflection/reflector.ts","../../../../../../../packages/core/src/reflection/reflection.ts","../../../../../packages/core/src/di/reflective_provider.ts","../../../../../packages/core/src/di/reflective_injector.ts","../../../../../packages/core/src/di/index.ts","../../../../../packages/core/src/di.ts","../../../../../packages/core/src/metadata/di.ts","../../../../../packages/core/src/metadata/resource_loading.ts","../../../../../packages/core/src/render3/styling/static_styling.ts","../../../../../../../packages/core/src/util/symbol.ts","../../../../../../../packages/core/src/util/iterable.ts","../../../../../../../packages/core/src/util/comparison.ts","../../../../../packages/core/src/change_detection/change_detection_util.ts","../../../../../packages/core/src/render3/bindings.ts","../../../../../packages/core/src/render3/instructions/attribute.ts","../../../../../packages/core/src/render3/instructions/interpolation.ts","../../../../../packages/core/src/render3/instructions/attribute_interpolation.ts","../../../../../packages/core/src/render3/instructions/change_detection.ts","../../../../../packages/core/src/render3/instructions/container.ts","../../../../../packages/core/src/render3/instructions/storage.ts","../../../../../packages/core/src/render3/instructions/di.ts","../../../../../packages/core/src/render3/instructions/property.ts","../../../../../packages/core/src/render3/instructions/element.ts","../../../../../packages/core/src/render3/instructions/element_container.ts","../../../../../packages/core/src/render3/instructions/embedded_view.ts","../../../../../packages/core/src/render3/instructions/get_current_view.ts","../../../../../../../packages/core/src/util/lang.ts","../../../../../packages/core/src/render3/instructions/listener.ts","../../../../../packages/core/src/render3/instructions/namespace.ts","../../../../../packages/core/src/render3/instructions/next_context.ts","../../../../../packages/core/src/render3/instructions/projection.ts","../../../../../packages/core/src/render3/instructions/property_interpolation.ts","../../../../../../../packages/core/src/util/empty.ts","../../../../../packages/core/src/render3/styling/style_binding_list.ts","../../../../../packages/core/src/render3/styling/styling_parser.ts","../../../../../packages/core/src/render3/instructions/styling.ts","../../../../../packages/core/src/render3/instructions/text.ts","../../../../../packages/core/src/render3/instructions/text_interpolation.ts","../../../../../packages/core/src/render3/instructions/class_map_interpolation.ts","../../../../../packages/core/src/render3/instructions/style_prop_interpolation.ts","../../../../../packages/core/src/render3/instructions/host_property.ts","../../../../../packages/core/src/render3/instructions/all.ts","../../../../../packages/core/src/render3/util/discovery_utils.ts","../../../../../packages/core/src/render3/util/change_detection_utils.ts","../../../../../packages/core/src/render3/util/global_utils.ts","../../../../../packages/core/src/render3/component.ts","../../../../../packages/core/src/render3/features/inherit_definition_feature.ts","../../../../../packages/core/src/render3/features/copy_definition_feature.ts","../../../../../../../packages/core/src/interface/simple_change.ts","../../../../../packages/core/src/render3/features/ng_onchanges_feature.ts","../../../../../packages/core/src/render3/di_setup.ts","../../../../../packages/core/src/render3/features/providers_feature.ts","../../../../../packages/core/src/linker/component_factory.ts","../../../../../packages/core/src/linker/component_factory_resolver.ts","../../../../../../../packages/core/src/util/noop.ts","../../../../../packages/core/src/linker/element_ref.ts","../../../../../packages/core/src/render/api.ts","../../../../../packages/core/src/sanitization/sanitizer.ts","../../../../../packages/core/src/version.ts","../../../../../packages/core/src/change_detection/differs/default_iterable_differ.ts","../../../../../packages/core/src/change_detection/differs/default_keyvalue_differ.ts","../../../../../packages/core/src/change_detection/differs/iterable_differs.ts","../../../../../packages/core/src/change_detection/differs/keyvalue_differs.ts","../../../../../packages/core/src/change_detection/change_detection.ts","../../../../../packages/core/src/linker/template_ref.ts","../../../../../packages/core/src/linker/view_container_ref.ts","../../../../../packages/core/src/view/errors.ts","../../../../../packages/core/src/view/types.ts","../../../../../packages/core/src/view/util.ts","../../../../../packages/core/src/view/ng_module.ts","../../../../../packages/core/src/view/view_attach.ts","../../../../../packages/core/src/view/refs.ts","../../../../../packages/core/src/view/provider.ts","../../../../../packages/core/src/render3/component_ref.ts","../../../../../../../packages/core/src/util/ng_i18n_closure_mode.ts","../../../../../packages/core/src/i18n/locale_en.ts","../../../../../packages/core/src/i18n/locale_data_api.ts","../../../../../packages/core/src/i18n/localization.ts","../../../../../packages/core/src/render3/i18n.ts","../../../../../packages/core/src/linker/ng_module_factory_registration.ts","../../../../../packages/core/src/render3/ng_module_ref.ts","../../../../../packages/core/src/render3/metadata.ts","../../../../../packages/core/src/render3/pure_function.ts","../../../../../packages/core/src/render3/pipe.ts","../../../../../packages/core/src/event_emitter.ts","../../../../../packages/core/src/linker/query_list.ts","../../../../../packages/core/src/render3/interfaces/definition.ts","../../../../../packages/core/src/render3/interfaces/query.ts","../../../../../packages/core/src/render3/query.ts","../../../../../packages/core/src/render3/view_engine_compatibility_prebound.ts","../../../../../packages/core/src/render3/index.ts","../../../../../packages/core/src/render3/jit/environment.ts","../../../../../packages/core/src/render3/jit/module.ts","../../../../../packages/core/src/render3/jit/directive.ts","../../../../../packages/core/src/render3/jit/pipe.ts","../../../../../packages/core/src/metadata/directives.ts","../../../../../packages/core/src/metadata/ng_module.ts","../../../../../packages/core/src/metadata.ts","../../../../../packages/core/src/application_init.ts","../../../../../packages/core/src/application_tokens.ts","../../../../../packages/core/src/console.ts","../../../../../packages/core/src/i18n/tokens.ts","../../../../../packages/core/src/ivy_switch.ts","../../../../../packages/core/src/linker/compiler.ts","../../../../../../../packages/core/src/util/microtask.ts","../../../../../../../packages/core/src/util/raf.ts","../../../../../packages/core/src/zone/ng_zone.ts","../../../../../packages/core/src/testability/testability.ts","../../../../../packages/core/src/application_ref.ts","../../../../../packages/core/src/zone.ts","../../../../../packages/core/src/render.ts","../../../../../packages/core/src/linker/ng_module_factory_loader.ts","../../../../../packages/core/src/linker/system_js_ng_module_factory_loader.ts","../../../../../packages/core/src/linker/view_ref.ts","../../../../../packages/core/src/linker.ts","../../../../../packages/core/src/debug/debug_node.ts","../../../../../packages/core/src/change_detection.ts","../../../../../packages/core/src/platform_core_providers.ts","../../../../../packages/core/src/application_module.ts","../../../../../packages/core/src/view/element.ts","../../../../../packages/core/src/view/query.ts","../../../../../packages/core/src/view/ng_content.ts","../../../../../packages/core/src/view/pure_expression.ts","../../../../../packages/core/src/view/text.ts","../../../../../packages/core/src/view/view.ts","../../../../../packages/core/src/view/services.ts","../../../../../packages/core/src/view/entrypoint.ts","../../../../../packages/core/src/view/index.ts","../../../../../packages/core/src/core_private_export.ts","../../../../../packages/core/src/core_render3_private_export.ts","../../../../../packages/core/src/codegen_private_exports.ts","../../../../../packages/core/src/core.ts","../../../../../packages/core/public_api.ts","../../../../../packages/core/index.ts","../../../../../packages/core/core.ts"],"sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Type} from '../interface/type';\n\n/**\n * An interface implemented by all Angular type decorators, which allows them to be used as\n * decorators as well as Angular syntax.\n *\n * ```\n * @ng.Component({...})\n * class MyClass {...}\n * ```\n *\n * @publicApi\n */\nexport interface TypeDecorator {\n  /**\n   * Invoke as decorator.\n   */\n  <T extends Type<any>>(type: T): T;\n\n  // Make TypeDecorator assignable to built-in ParameterDecorator type.\n  // ParameterDecorator is declared in lib.d.ts as a `declare type`\n  // so we cannot declare this interface as a subtype.\n  // see https://github.com/angular/angular/issues/3379#issuecomment-126169417\n  (target: Object, propertyKey?: string|symbol, parameterIndex?: number): void;\n}\n\nexport const ANNOTATIONS = '__annotations__';\nexport const PARAMETERS = '__parameters__';\nexport const PROP_METADATA = '__prop__metadata__';\n\n/**\n * @suppress {globalThis}\n */\nexport function makeDecorator<T>(\n    name: string, props?: (...args: any[]) => any, parentClass?: any,\n    additionalProcessing?: (type: Type<T>) => void,\n    typeFn?: (type: Type<T>, ...args: any[]) => void):\n    {new (...args: any[]): any; (...args: any[]): any; (...args: any[]): (cls: any) => any;} {\n  const metaCtor = makeMetadataCtor(props);\n\n  function DecoratorFactory(\n      this: unknown | typeof DecoratorFactory, ...args: any[]): (cls: Type<T>) => any {\n    if (this instanceof DecoratorFactory) {\n      metaCtor.call(this, ...args);\n      return this as typeof DecoratorFactory;\n    }\n\n    const annotationInstance = new (DecoratorFactory as any)(...args);\n    return function TypeDecorator(cls: Type<T>) {\n      if (typeFn) typeFn(cls, ...args);\n      // Use of Object.defineProperty is important since it creates non-enumerable property which\n      // prevents the property is copied during subclassing.\n      const annotations = cls.hasOwnProperty(ANNOTATIONS) ?\n          (cls as any)[ANNOTATIONS] :\n          Object.defineProperty(cls, ANNOTATIONS, {value: []})[ANNOTATIONS];\n      annotations.push(annotationInstance);\n\n\n      if (additionalProcessing) additionalProcessing(cls);\n\n      return cls;\n    };\n  }\n\n  if (parentClass) {\n    DecoratorFactory.prototype = Object.create(parentClass.prototype);\n  }\n\n  DecoratorFactory.prototype.ngMetadataName = name;\n  (DecoratorFactory as any).annotationCls = DecoratorFactory;\n  return DecoratorFactory as any;\n}\n\nfunction makeMetadataCtor(props?: (...args: any[]) => any): any {\n  return function ctor(this: any, ...args: any[]) {\n    if (props) {\n      const values = props(...args);\n      for (const propName in values) {\n        this[propName] = values[propName];\n      }\n    }\n  };\n}\n\nexport function makeParamDecorator(\n    name: string, props?: (...args: any[]) => any, parentClass?: any): any {\n  const metaCtor = makeMetadataCtor(props);\n  function ParamDecoratorFactory(\n      this: unknown | typeof ParamDecoratorFactory, ...args: any[]): any {\n    if (this instanceof ParamDecoratorFactory) {\n      metaCtor.apply(this, args);\n      return this;\n    }\n    const annotationInstance = new (<any>ParamDecoratorFactory)(...args);\n\n    (<any>ParamDecorator).annotation = annotationInstance;\n    return ParamDecorator;\n\n    function ParamDecorator(cls: any, unusedKey: any, index: number): any {\n      // Use of Object.defineProperty is important since it creates non-enumerable property which\n      // prevents the property is copied during subclassing.\n      const parameters = cls.hasOwnProperty(PARAMETERS) ?\n          (cls as any)[PARAMETERS] :\n          Object.defineProperty(cls, PARAMETERS, {value: []})[PARAMETERS];\n\n      // there might be gaps if some in between parameters do not have annotations.\n      // we pad with nulls.\n      while (parameters.length <= index) {\n        parameters.push(null);\n      }\n\n      (parameters[index] = parameters[index] || []).push(annotationInstance);\n      return cls;\n    }\n  }\n  if (parentClass) {\n    ParamDecoratorFactory.prototype = Object.create(parentClass.prototype);\n  }\n  ParamDecoratorFactory.prototype.ngMetadataName = name;\n  (<any>ParamDecoratorFactory).annotationCls = ParamDecoratorFactory;\n  return ParamDecoratorFactory;\n}\n\nexport function makePropDecorator(\n    name: string, props?: (...args: any[]) => any, parentClass?: any,\n    additionalProcessing?: (target: any, name: string, ...args: any[]) => void): any {\n  const metaCtor = makeMetadataCtor(props);\n\n  function PropDecoratorFactory(this: unknown | typeof PropDecoratorFactory, ...args: any[]): any {\n    if (this instanceof PropDecoratorFactory) {\n      metaCtor.apply(this, args);\n      return this;\n    }\n\n    const decoratorInstance = new (<any>PropDecoratorFactory)(...args);\n\n    function PropDecorator(target: any, name: string) {\n      const constructor = target.constructor;\n      // Use of Object.defineProperty is important since it creates non-enumerable property which\n      // prevents the property is copied during subclassing.\n      const meta = constructor.hasOwnProperty(PROP_METADATA) ?\n          (constructor as any)[PROP_METADATA] :\n          Object.defineProperty(constructor, PROP_METADATA, {value: {}})[PROP_METADATA];\n      meta[name] = meta.hasOwnProperty(name) && meta[name] || [];\n      meta[name].unshift(decoratorInstance);\n\n      if (additionalProcessing) additionalProcessing(target, name, ...args);\n    }\n\n    return PropDecorator;\n  }\n\n  if (parentClass) {\n    PropDecoratorFactory.prototype = Object.create(parentClass.prototype);\n  }\n\n  PropDecoratorFactory.prototype.ngMetadataName = name;\n  (<any>PropDecoratorFactory).annotationCls = PropDecoratorFactory;\n  return PropDecoratorFactory;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {makeParamDecorator} from '../util/decorators';\n\n\n\n/**\n * Type of the Inject decorator / constructor function.\n *\n * @publicApi\n */\nexport interface InjectDecorator {\n  /**\n   * Parameter decorator on a dependency parameter of a class constructor\n   * that specifies a custom provider of the dependency.\n   *\n   * Learn more in the [\"Dependency Injection Guide\"](guide/dependency-injection).\n   *\n   * @usageNotes\n   * The following example shows a class constructor that specifies a\n   * custom provider of a dependency using the parameter decorator.\n   *\n   * When `@Inject()` is not present, the injector uses the type annotation of the\n   * parameter as the provider.\n   *\n   * <code-example path=\"core/di/ts/metadata_spec.ts\" region=\"InjectWithoutDecorator\">\n   * </code-example>\n   */\n  (token: any): any;\n  new (token: any): Inject;\n}\n\n/**\n * Type of the Inject metadata.\n *\n * @publicApi\n */\nexport interface Inject {\n  /**\n   * A [DI token](guide/glossary#di-token) that maps to the dependency to be injected.\n   */\n  token: any;\n}\n\n/**\n * Inject decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nexport const Inject: InjectDecorator = makeParamDecorator('Inject', (token: any) => ({token}));\n\n\n/**\n * Type of the Optional decorator / constructor function.\n *\n * @publicApi\n */\nexport interface OptionalDecorator {\n  /**\n   * Parameter decorator to be used on constructor parameters,\n   * which marks the parameter as being an optional dependency.\n   * The DI framework provides null if the dependency is not found.\n   *\n   * Can be used together with other parameter decorators\n   * that modify how dependency injection operates.\n   *\n   * Learn more in the [\"Dependency Injection Guide\"](guide/dependency-injection).\n   *\n   * @usageNotes\n   *\n   * The following code allows the possibility of a null result:\n   *\n   * <code-example path=\"core/di/ts/metadata_spec.ts\" region=\"Optional\">\n   * </code-example>\n   *\n   */\n  (): any;\n  new (): Optional;\n}\n\n/**\n * Type of the Optional metadata.\n *\n * @publicApi\n */\nexport interface Optional {}\n\n/**\n * Optional decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nexport const Optional: OptionalDecorator = makeParamDecorator('Optional');\n\n/**\n * Type of the Self decorator / constructor function.\n *\n * @publicApi\n */\nexport interface SelfDecorator {\n  /**\n   * Parameter decorator to be used on constructor parameters,\n   * which tells the DI framework to start dependency resolution from the local injector.\n   *\n   * Resolution works upward through the injector hierarchy, so the children\n   * of this class must configure their own providers or be prepared for a null result.\n   *\n   * @usageNotes\n   *\n   * In the following example, the dependency can be resolved\n   * by the local injector when instantiating the class itself, but not\n   * when instantiating a child.\n   *\n   * <code-example path=\"core/di/ts/metadata_spec.ts\" region=\"Self\">\n   * </code-example>\n   *\n   *\n   * @see `SkipSelf`\n   * @see `Optional`\n   *\n   */\n  (): any;\n  new (): Self;\n}\n\n/**\n * Type of the Self metadata.\n *\n * @publicApi\n */\nexport interface Self {}\n\n/**\n * Self decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nexport const Self: SelfDecorator = makeParamDecorator('Self');\n\n\n/**\n * Type of the SkipSelf decorator / constructor function.\n *\n * @publicApi\n */\nexport interface SkipSelfDecorator {\n  /**\n   * Parameter decorator to be used on constructor parameters,\n   * which tells the DI framework to start dependency resolution from the parent injector.\n   * Resolution works upward through the injector hierarchy, so the local injector\n   * is not checked for a provider.\n   *\n   * @usageNotes\n   *\n   * In the following example, the dependency can be resolved when\n   * instantiating a child, but not when instantiating the class itself.\n   *\n   * <code-example path=\"core/di/ts/metadata_spec.ts\" region=\"SkipSelf\">\n   * </code-example>\n   *\n   * Learn more in the\n   * [Dependency Injection guide](guide/dependency-injection-in-action#skip).\n   *\n   * @see `Self`\n   * @see `Optional`\n   *\n   */\n  (): any;\n  new (): SkipSelf;\n}\n\n/**\n * Type of the SkipSelf metadata.\n *\n * @publicApi\n */\nexport interface SkipSelf {}\n\n/**\n * SkipSelf decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nexport const SkipSelf: SkipSelfDecorator = makeParamDecorator('SkipSelf');\n\n/**\n * Type of the Host decorator / constructor function.\n *\n * @publicApi\n */\nexport interface HostDecorator {\n  /**\n   * Parameter decorator on a view-provider parameter of a class constructor\n   * that tells the DI framework to resolve the view by checking injectors of child\n   * elements, and stop when reaching the host element of the current component.\n   *\n   * For an extended example, see\n   * [\"Dependency Injection Guide\"](guide/dependency-injection-in-action#optional).\n   *\n   * @usageNotes\n   *\n   * The following shows use with the `@Optional` decorator, and allows for a null result.\n   *\n   * <code-example path=\"core/di/ts/metadata_spec.ts\" region=\"Host\">\n   * </code-example>\n   */\n  (): any;\n  new (): Host;\n}\n\n/**\n * Type of the Host metadata.\n *\n * @publicApi\n */\nexport interface Host {}\n\n/**\n * Host decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nexport const Host: HostDecorator = makeParamDecorator('Host');\n\n\n/**\n * Type of the Attribute decorator / constructor function.\n *\n * @publicApi\n */\nexport interface AttributeDecorator {\n  /**\n   * Parameter decorator for a directive constructor that designates\n   * a host-element attribute whose value is injected as a constant string literal.\n   *\n   * @usageNotes\n   *\n   * Suppose we have an `<input>` element and want to know its `type`.\n   *\n   * ```html\n   * <input type=\"text\">\n   * ```\n   *\n   * The following example uses the decorator to inject the string literal `text`.\n   *\n   * {@example core/ts/metadata/metadata.ts region='attributeMetadata'}\n   *\n   * ### Example as TypeScript Decorator\n   *\n   * {@example core/ts/metadata/metadata.ts region='attributeFactory'}\n   *\n   */\n  (name: string): any;\n  new (name: string): Attribute;\n}\n\n/**\n * Type of the Attribute metadata.\n *\n * @publicApi\n */\nexport interface Attribute {\n  /**\n   * The name of the attribute whose value can be injected.\n   */\n  attributeName?: string;\n}\n\n/**\n * Attribute decorator and metadata.\n *\n * @Annotation\n * @publicApi\n */\nexport const Attribute: AttributeDecorator =\n    makeParamDecorator('Attribute', (attributeName?: string) => ({attributeName}));\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\n/**\n * Injection flags for DI.\n *\n * @publicApi\n */\nexport enum InjectFlags {\n  // TODO(alxhub): make this 'const' when ngc no longer writes exports of it into ngfactory files.\n\n  /** Check self and check parent injector if needed */\n  Default = 0b0000,\n  /**\n   * Specifies that an injector should retrieve a dependency from any injector until reaching the\n   * host element of the current component. (Only used with Element Injector)\n   */\n  Host = 0b0001,\n  /** Don't ascend to ancestors of the node requesting injection. */\n  Self = 0b0010,\n  /** Skip the node that is requesting injection. */\n  SkipSelf = 0b0100,\n  /** Inject `defaultValue` instead if token not found. */\n  Optional = 0b1000,\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nexport function getClosureSafeProperty<T>(objWithPropertyToExtract: T): string {\n  for (let key in objWithPropertyToExtract) {\n    if (objWithPropertyToExtract[key] === getClosureSafeProperty as any) {\n      return key;\n    }\n  }\n  throw Error('Could not find renamed property on target object.');\n}\n\n/**\n * Sets properties on a target object from a source object, but only if\n * the property doesn't already exist on the target object.\n * @param target The target to set properties on\n * @param source The source of the property keys and values to set\n */\nexport function fillProperties(target: {[key: string]: string}, source: {[key: string]: string}) {\n  for (const key in source) {\n    if (source.hasOwnProperty(key) && !target.hasOwnProperty(key)) {\n      target[key] = source[key];\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Type} from '../../interface/type';\nimport {getClosureSafeProperty} from '../../util/property';\nimport {ClassProvider, ConstructorProvider, ExistingProvider, FactoryProvider, StaticClassProvider, ValueProvider} from './provider';\n\n\n\n/**\n * Information about how a type or `InjectionToken` interfaces with the DI system.\n *\n * At a minimum, this includes a `factory` which defines how to create the given type `T`, possibly\n * requesting injection of other types if necessary.\n *\n * Optionally, a `providedIn` parameter specifies that the given type belongs to a particular\n * `InjectorDef`, `NgModule`, or a special scope (e.g. `'root'`). A value of `null` indicates\n * that the injectable does not belong to any scope.\n *\n * NOTE: This is a private type and should not be exported\n *\n * @publicApi\n */\nexport interface ÉµÉµInjectableDef<T> {\n  /**\n   * Specifies that the given type belongs to a particular injector:\n   * - `InjectorType` such as `NgModule`,\n   * - `'root'` the root injector\n   * - `'any'` all injectors.\n   * - `null`, does not belong to any injector. Must be explicitly listed in the injector\n   *   `providers`.\n   */\n  providedIn: InjectorType<any>|'root'|'platform'|'any'|null;\n\n  /**\n   * The token to which this definition belongs.\n   *\n   * Note that this may not be the same as the type that the `factory` will create.\n   */\n  token: unknown;\n\n  /**\n   * Factory method to execute to create an instance of the injectable.\n   */\n  factory: (t?: Type<any>) => T;\n\n  /**\n   * In a case of no explicit injector, a location where the instance of the injectable is stored.\n   */\n  value: T|undefined;\n}\n\n/**\n * Information about the providers to be included in an `Injector` as well as how the given type\n * which carries the information should be created by the DI system.\n *\n * An `InjectorDef` can import other types which have `InjectorDefs`, forming a deep nested\n * structure of providers with a defined priority (identically to how `NgModule`s also have\n * an import/dependency structure).\n *\n * NOTE: This is a private type and should not be exported\n *\n * @publicApi\n */\nexport interface ÉµÉµInjectorDef<T> {\n  factory: () => T;\n\n  // TODO(alxhub): Narrow down the type here once decorators properly change the return type of the\n  // class they are decorating (to add the Éµprov property for example).\n  providers: (Type<any>|ValueProvider|ExistingProvider|FactoryProvider|ConstructorProvider|\n              StaticClassProvider|ClassProvider|any[])[];\n\n  imports: (InjectorType<any>|InjectorTypeWithProviders<any>)[];\n}\n\n/**\n * A `Type` which has an `InjectableDef` static field.\n *\n * `InjectableDefType`s contain their own Dependency Injection metadata and are usable in an\n * `InjectorDef`-based `StaticInjector.\n *\n * @publicApi\n */\nexport interface InjectableType<T> extends Type<T> {\n  /**\n   * Opaque type whose structure is highly version dependent. Do not rely on any properties.\n   */\n  Éµprov: never;\n}\n\n/**\n * A type which has an `InjectorDef` static field.\n *\n * `InjectorDefTypes` can be used to configure a `StaticInjector`.\n *\n * @publicApi\n */\nexport interface InjectorType<T> extends Type<T> {\n  /**\n   * Opaque type whose structure is highly version dependent. Do not rely on any properties.\n   */\n  Éµinj: never;\n}\n\n/**\n * Describes the `InjectorDef` equivalent of a `ModuleWithProviders`, an `InjectorDefType` with an\n * associated array of providers.\n *\n * Objects of this type can be listed in the imports section of an `InjectorDef`.\n *\n * NOTE: This is a private type and should not be exported\n */\nexport interface InjectorTypeWithProviders<T> {\n  ngModule: InjectorType<T>;\n  providers?: (Type<any>|ValueProvider|ExistingProvider|FactoryProvider|ConstructorProvider|\n               StaticClassProvider|ClassProvider|any[])[];\n}\n\n\n/**\n * Construct an `InjectableDef` which defines how a token will be constructed by the DI system, and\n * in which injectors (if any) it will be available.\n *\n * This should be assigned to a static `Éµprov` field on a type, which will then be an\n * `InjectableType`.\n *\n * Options:\n * * `providedIn` determines which injectors will include the injectable, by either associating it\n *   with an `@NgModule` or other `InjectorType`, or by specifying that this injectable should be\n *   provided in the `'root'` injector, which will be the application-level injector in most apps.\n * * `factory` gives the zero argument function which will create an instance of the injectable.\n *   The factory can call `inject` to access the `Injector` and request injection of dependencies.\n *\n * @codeGenApi\n */\nexport function ÉµÉµdefineInjectable<T>(opts: {\n  token: unknown,\n  providedIn?: Type<any>| 'root' | 'platform' | 'any' | null,\n  factory: () => T,\n}): never {\n  return ({\n    token: opts.token, providedIn: opts.providedIn as any || null, factory: opts.factory,\n        value: undefined,\n  } as ÉµÉµInjectableDef<T>) as never;\n}\n\n/**\n * @deprecated in v8, delete after v10. This API should be used only be generated code, and that\n * code should now use ÉµÉµdefineInjectable instead.\n * @publicApi\n */\nexport const defineInjectable = ÉµÉµdefineInjectable;\n\n/**\n * Construct an `InjectorDef` which configures an injector.\n *\n * This should be assigned to a static injector def (`Éµinj`) field on a type, which will then be an\n * `InjectorType`.\n *\n * Options:\n *\n * * `factory`: an `InjectorType` is an instantiable type, so a zero argument `factory` function to\n *   create the type must be provided. If that factory function needs to inject arguments, it can\n *   use the `inject` function.\n * * `providers`: an optional array of providers to add to the injector. Each provider must\n *   either have a factory or point to a type which has a `Éµprov` static property (the\n *   type must be an `InjectableType`).\n * * `imports`: an optional array of imports of other `InjectorType`s or `InjectorTypeWithModule`s\n *   whose providers will also be added to the injector. Locally provided types will override\n *   providers from imports.\n *\n * @publicApi\n */\nexport function ÉµÉµdefineInjector(options: {factory: () => any, providers?: any[], imports?: any[]}):\n    never {\n  return ({\n    factory: options.factory, providers: options.providers || [], imports: options.imports || [],\n  } as ÉµÉµInjectorDef<any>) as never;\n}\n\n/**\n * Read the injectable def (`Éµprov`) for `type` in a way which is immune to accidentally reading\n * inherited value.\n *\n * @param type A type which may have its own (non-inherited) `Éµprov`.\n */\nexport function getInjectableDef<T>(type: any): ÉµÉµInjectableDef<T>|null {\n  return getOwnDefinition(type, type[NG_PROV_DEF]) ||\n      getOwnDefinition(type, type[NG_INJECTABLE_DEF]);\n}\n\n/**\n * Return `def` only if it is defined directly on `type` and is not inherited from a base\n * class of `type`.\n *\n * The function `Object.hasOwnProperty` is not sufficient to distinguish this case because in older\n * browsers (e.g. IE10) static property inheritance is implemented by copying the properties.\n *\n * Instead, the definition's `token` is compared to the `type`, and if they don't match then the\n * property was not defined directly on the type itself, and was likely inherited. The definition\n * is only returned if the `type` matches the `def.token`.\n */\nfunction getOwnDefinition<T>(type: any, def: ÉµÉµInjectableDef<T>): ÉµÉµInjectableDef<T>|null {\n  return def && def.token === type ? def : null;\n}\n\n/**\n * Read the injectable def (`Éµprov`) for `type` or read the `Éµprov` from one of its ancestors.\n *\n * @param type A type which may have `Éµprov`, via inheritance.\n *\n * @deprecated Will be removed in v10, where an error will occur in the scenario if we find the\n * `Éµprov` on an ancestor only.\n */\nexport function getInheritedInjectableDef<T>(type: any): ÉµÉµInjectableDef<T>|null {\n  // See `jit/injectable.ts#compileInjectable` for context on NG_PROV_DEF_FALLBACK.\n  const def = type && (type[NG_PROV_DEF] || type[NG_INJECTABLE_DEF] ||\n                       (type[NG_PROV_DEF_FALLBACK] && type[NG_PROV_DEF_FALLBACK]()));\n\n  if (def) {\n    const typeName = getTypeName(type);\n    // TODO(FW-1307): Re-add ngDevMode when closure can handle it\n    // ngDevMode &&\n    console.warn(\n        `DEPRECATED: DI is instantiating a token \"${typeName}\" that inherits its @Injectable decorator but does not provide one itself.\\n` +\n        `This will become an error in v10. Please add @Injectable() to the \"${typeName}\" class.`);\n    return def;\n  } else {\n    return null;\n  }\n}\n\n/** Gets the name of a type, accounting for some cross-browser differences. */\nfunction getTypeName(type: any): string {\n  // `Function.prototype.name` behaves differently between IE and other browsers. In most browsers\n  // it'll always return the name of the function itself, no matter how many other functions it\n  // inherits from. On IE the function doesn't have its own `name` property, but it takes it from\n  // the lowest level in the prototype chain. E.g. if we have `class Foo extends Parent` most\n  // browsers will evaluate `Foo.name` to `Foo` while IE will return `Parent`. We work around\n  // the issue by converting the function to a string and parsing its name out that way via a regex.\n  if (type.hasOwnProperty('name')) {\n    return type.name;\n  }\n\n  const match = ('' + type).match(/^function\\s*([^\\s(]+)/);\n  return match === null ? '' : match[1];\n}\n\n/**\n * Read the injector def type in a way which is immune to accidentally reading inherited value.\n *\n * @param type type which may have an injector def (`Éµinj`)\n */\nexport function getInjectorDef<T>(type: any): ÉµÉµInjectorDef<T>|null {\n  return type && (type.hasOwnProperty(NG_INJ_DEF) || type.hasOwnProperty(NG_INJECTOR_DEF)) ?\n      (type as any)[NG_INJ_DEF] :\n      null;\n}\n\nexport const NG_PROV_DEF = getClosureSafeProperty({Éµprov: getClosureSafeProperty});\nexport const NG_INJ_DEF = getClosureSafeProperty({Éµinj: getClosureSafeProperty});\n\n// On IE10 properties defined via `defineProperty` won't be inherited by child classes,\n// which will break inheriting the injectable definition from a grandparent through an\n// undecorated parent class. We work around it by defining a fallback method which will be\n// used to retrieve the definition. This should only be a problem in JIT mode, because in\n// AOT TypeScript seems to have a workaround for static properties. When inheriting from an\n// undecorated parent is no longer supported in v10, this can safely be removed.\nexport const NG_PROV_DEF_FALLBACK = getClosureSafeProperty({ÉµprovFallback: getClosureSafeProperty});\n\n// We need to keep these around so we can read off old defs if new defs are unavailable\nexport const NG_INJECTABLE_DEF = getClosureSafeProperty({ngInjectableDef: getClosureSafeProperty});\nexport const NG_INJECTOR_DEF = getClosureSafeProperty({ngInjectorDef: getClosureSafeProperty});\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nexport function stringify(token: any): string {\n  if (typeof token === 'string') {\n    return token;\n  }\n\n  if (Array.isArray(token)) {\n    return '[' + token.map(stringify).join(', ') + ']';\n  }\n\n  if (token == null) {\n    return '' + token;\n  }\n\n  if (token.overriddenName) {\n    return `${token.overriddenName}`;\n  }\n\n  if (token.name) {\n    return `${token.name}`;\n  }\n\n  const res = token.toString();\n\n  if (res == null) {\n    return '' + res;\n  }\n\n  const newLineIndex = res.indexOf('\\n');\n  return newLineIndex === -1 ? res : res.substring(0, newLineIndex);\n}\n\n/**\n * Concatenates two strings with separator, allocating new strings only when necessary.\n *\n * @param before before string.\n * @param separator separator string.\n * @param after after string.\n * @returns concatenated string.\n */\nexport function concatStringsWithSpace(before: string | null, after: string | null): string {\n  return (before == null || before === '') ?\n      (after === null ? '' : after) :\n      ((after == null || after === '') ? before : before + ' ' + after);\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Type} from '../interface/type';\nimport {getClosureSafeProperty} from '../util/property';\nimport {stringify} from '../util/stringify';\n\n\n\n/**\n * An interface that a function passed into {@link forwardRef} has to implement.\n *\n * @usageNotes\n * ### Example\n *\n * {@example core/di/ts/forward_ref/forward_ref_spec.ts region='forward_ref_fn'}\n * @publicApi\n */\nexport interface ForwardRefFn { (): any; }\n\nconst __forward_ref__ = getClosureSafeProperty({__forward_ref__: getClosureSafeProperty});\n\n/**\n * Allows to refer to references which are not yet defined.\n *\n * For instance, `forwardRef` is used when the `token` which we need to refer to for the purposes of\n * DI is declared, but not yet defined. It is also used when the `token` which we use when creating\n * a query is not yet defined.\n *\n * @usageNotes\n * ### Example\n * {@example core/di/ts/forward_ref/forward_ref_spec.ts region='forward_ref'}\n * @publicApi\n */\nexport function forwardRef(forwardRefFn: ForwardRefFn): Type<any> {\n  (<any>forwardRefFn).__forward_ref__ = forwardRef;\n  (<any>forwardRefFn).toString = function() { return stringify(this()); };\n  return (<Type<any>><any>forwardRefFn);\n}\n\n/**\n * Lazily retrieves the reference value from a forwardRef.\n *\n * Acts as the identity function when given a non-forward-ref value.\n *\n * @usageNotes\n * ### Example\n *\n * {@example core/di/ts/forward_ref/forward_ref_spec.ts region='resolve_forward_ref'}\n *\n * @see `forwardRef`\n * @publicApi\n */\nexport function resolveForwardRef<T>(type: T): T {\n  return isForwardRef(type) ? type() : type;\n}\n\n/** Checks whether a function is wrapped by a `forwardRef`. */\nexport function isForwardRef(fn: any): fn is() => any {\n  return typeof fn === 'function' && fn.hasOwnProperty(__forward_ref__) &&\n      fn.__forward_ref__ === forwardRef;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n// TODO(jteplitz602): Load WorkerGlobalScope from lib.webworker.d.ts file #3492\ndeclare var WorkerGlobalScope: any /** TODO #9100 */;\n// CommonJS / Node have global context exposed as \"global\" variable.\n// We don't want to include the whole node.d.ts this this compilation unit so we'll just fake\n// the global \"global\" var for now.\ndeclare var global: any /** TODO #9100 */;\n// Not yet available in TypeScript: https://github.com/Microsoft/TypeScript/pull/29332\ndeclare var globalThis: any /** TODO #9100 */;\n\nconst __globalThis = typeof globalThis !== 'undefined' && globalThis;\nconst __window = typeof window !== 'undefined' && window;\nconst __self = typeof self !== 'undefined' && typeof WorkerGlobalScope !== 'undefined' &&\n    self instanceof WorkerGlobalScope && self;\nconst __global = typeof global !== 'undefined' && global;\n\n// Always use __globalThis if available, which is the spec-defined global variable across all\n// environments, then fallback to __global first, because in Node tests both __global and\n// __window may be defined and _global should be __global in that case.\nconst _global = __globalThis || __global || __window || __self;\n\n/**\n * Attention: whenever providing a new value, be sure to add an\n * entry into the corresponding `....externs.js` file,\n * so that closure won't use that global for its purposes.\n */\nexport {_global as global};\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\n/**\n * A set of interfaces which are shared between `@angular/core` and `@angular/compiler` to allow\n * for late binding of `@angular/compiler` for JIT purposes.\n *\n * This file has two copies. Please ensure that they are in sync:\n *  - packages/compiler/src/compiler_facade_interface.ts             (master)\n *  - packages/core/src/render3/jit/compiler_facade_interface.ts     (copy)\n *\n * Please ensure that the two files are in sync using this command:\n * ```\n * cp packages/compiler/src/compiler_facade_interface.ts \\\n *    packages/core/src/render3/jit/compiler_facade_interface.ts\n * ```\n */\n\nexport interface ExportedCompilerFacade { ÉµcompilerFacade: CompilerFacade; }\n\nexport interface CompilerFacade {\n  compilePipe(angularCoreEnv: CoreEnvironment, sourceMapUrl: string, meta: R3PipeMetadataFacade):\n      any;\n  compileInjectable(\n      angularCoreEnv: CoreEnvironment, sourceMapUrl: string, meta: R3InjectableMetadataFacade): any;\n  compileInjector(\n      angularCoreEnv: CoreEnvironment, sourceMapUrl: string, meta: R3InjectorMetadataFacade): any;\n  compileNgModule(\n      angularCoreEnv: CoreEnvironment, sourceMapUrl: string, meta: R3NgModuleMetadataFacade): any;\n  compileDirective(\n      angularCoreEnv: CoreEnvironment, sourceMapUrl: string, meta: R3DirectiveMetadataFacade): any;\n  compileComponent(\n      angularCoreEnv: CoreEnvironment, sourceMapUrl: string, meta: R3ComponentMetadataFacade): any;\n  compileFactory(\n      angularCoreEnv: CoreEnvironment, sourceMapUrl: string, meta: R3FactoryDefMetadataFacade): any;\n\n  createParseSourceSpan(kind: string, typeName: string, sourceUrl: string): ParseSourceSpan;\n\n  R3ResolvedDependencyType: typeof R3ResolvedDependencyType;\n  R3FactoryTarget: typeof R3FactoryTarget;\n  ResourceLoader: {new (): ResourceLoader};\n}\n\nexport interface CoreEnvironment { [name: string]: Function; }\n\nexport type ResourceLoader = {\n  get(url: string): Promise<string>| string;\n};\n\nexport type StringMap = {\n  [key: string]: string;\n};\n\nexport type StringMapWithRename = {\n  [key: string]: string | [string, string];\n};\n\nexport type Provider = any;\n\nexport enum R3ResolvedDependencyType {\n  Token = 0,\n  Attribute = 1,\n  ChangeDetectorRef = 2,\n  Invalid = 3,\n}\n\nexport enum R3FactoryTarget {\n  Directive = 0,\n  Component = 1,\n  Injectable = 2,\n  Pipe = 3,\n  NgModule = 4,\n}\n\nexport interface R3DependencyMetadataFacade {\n  token: any;\n  resolved: R3ResolvedDependencyType;\n  host: boolean;\n  optional: boolean;\n  self: boolean;\n  skipSelf: boolean;\n}\n\nexport interface R3PipeMetadataFacade {\n  name: string;\n  type: any;\n  typeArgumentCount: number;\n  pipeName: string;\n  deps: R3DependencyMetadataFacade[]|null;\n  pure: boolean;\n}\n\nexport interface R3InjectableMetadataFacade {\n  name: string;\n  type: any;\n  typeArgumentCount: number;\n  providedIn: any;\n  useClass?: any;\n  useFactory?: any;\n  useExisting?: any;\n  useValue?: any;\n  userDeps?: R3DependencyMetadataFacade[];\n}\n\nexport interface R3NgModuleMetadataFacade {\n  type: any;\n  bootstrap: Function[];\n  declarations: Function[];\n  imports: Function[];\n  exports: Function[];\n  schemas: {name: string}[]|null;\n  id: string|null;\n}\n\nexport interface R3InjectorMetadataFacade {\n  name: string;\n  type: any;\n  deps: R3DependencyMetadataFacade[]|null;\n  providers: any[];\n  imports: any[];\n}\n\nexport interface R3DirectiveMetadataFacade {\n  name: string;\n  type: any;\n  typeArgumentCount: number;\n  typeSourceSpan: ParseSourceSpan;\n  deps: R3DependencyMetadataFacade[]|null;\n  selector: string|null;\n  queries: R3QueryMetadataFacade[];\n  host: {[key: string]: string};\n  propMetadata: {[key: string]: any[]};\n  lifecycle: {usesOnChanges: boolean;};\n  inputs: string[];\n  outputs: string[];\n  usesInheritance: boolean;\n  exportAs: string[]|null;\n  providers: Provider[]|null;\n  viewQueries: R3QueryMetadataFacade[];\n}\n\nexport interface R3ComponentMetadataFacade extends R3DirectiveMetadataFacade {\n  template: string;\n  preserveWhitespaces: boolean;\n  animations: any[]|undefined;\n  pipes: Map<string, any>;\n  directives: {selector: string, expression: any}[];\n  styles: string[];\n  encapsulation: ViewEncapsulation;\n  viewProviders: Provider[]|null;\n  interpolation?: [string, string];\n  changeDetection?: ChangeDetectionStrategy;\n}\n\nexport interface R3FactoryDefMetadataFacade {\n  name: string;\n  type: any;\n  typeArgumentCount: number;\n  deps: R3DependencyMetadataFacade[]|null;\n  injectFn: 'directiveInject'|'inject';\n  target: R3FactoryTarget;\n}\n\nexport enum ViewEncapsulation {\n  Emulated = 0,\n  Native = 1,\n  None = 2,\n  ShadowDom = 3\n}\n\nexport type ChangeDetectionStrategy = number;\n\nexport interface R3QueryMetadataFacade {\n  propertyName: string;\n  first: boolean;\n  predicate: any|string[];\n  descendants: boolean;\n  read: any|null;\n  static: boolean;\n}\n\nexport interface ParseSourceSpan {\n  start: any;\n  end: any;\n  details: any;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {global} from '../util/global';\nimport {CompilerFacade, ExportedCompilerFacade} from './compiler_facade_interface';\nexport * from './compiler_facade_interface';\n\nexport function getCompilerFacade(): CompilerFacade {\n  const globalNg: ExportedCompilerFacade = global['ng'];\n  if (!globalNg || !globalNg.ÉµcompilerFacade) {\n    throw new Error(\n        `Angular JIT compilation failed: '@angular/compiler' not loaded!\\n` +\n        `  - JIT compilation is discouraged for production use-cases! Consider AOT mode instead.\\n` +\n        `  - Did you bootstrap using '@angular/platform-browser-dynamic' or '@angular/platform-server'?\\n` +\n        `  - Alternatively provide the compiler with 'import \"@angular/compiler\";' before bootstrapping.`);\n  }\n  return globalNg.ÉµcompilerFacade;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {getClosureSafeProperty} from '../util/property';\n\nexport const NG_COMP_DEF = getClosureSafeProperty({Éµcmp: getClosureSafeProperty});\nexport const NG_DIR_DEF = getClosureSafeProperty({Éµdir: getClosureSafeProperty});\nexport const NG_PIPE_DEF = getClosureSafeProperty({Éµpipe: getClosureSafeProperty});\nexport const NG_MOD_DEF = getClosureSafeProperty({Éµmod: getClosureSafeProperty});\nexport const NG_LOC_ID_DEF = getClosureSafeProperty({Éµloc: getClosureSafeProperty});\nexport const NG_FACTORY_DEF = getClosureSafeProperty({Éµfac: getClosureSafeProperty});\n\n/**\n * If a directive is diPublic, bloomAdd sets a property on the type with this constant as\n * the key and the directive's unique ID as the value. This allows us to map directives to their\n * bloom filter bit for DI.\n */\n// TODO(misko): This is wrong. The NG_ELEMENT_ID should never be minified.\nexport const NG_ELEMENT_ID = getClosureSafeProperty({__NG_ELEMENT_ID__: getClosureSafeProperty});\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {global} from './global';\n\n// Do not remove: needed for closure to be able to properly tree-shake ngDevMode.\n// goog.define\n\ndeclare global {\n  /**\n   * Values of ngDevMode\n   * Depending on the current state of the application, ngDevMode may have one of several values.\n   *\n   * For convenience, the âtruthyâ value which enables dev mode is also an object which contains\n   * Angularâs performance counters. This is not necessary, but cuts down on boilerplate for the\n   * perf counters.\n   *\n   * ngDevMode may also be set to false. This can happen in one of a few ways:\n   * - The user explicitly sets `window.ngDevMode = false` somewhere in their app.\n   * - The user calls `enableProdMode()`.\n   * - The URL contains a `ngDevMode=false` text.\n   * Finally, ngDevMode may not have been defined at all.\n   */\n  const ngDevMode: null|NgDevModePerfCounters;\n  interface NgDevModePerfCounters {\n    namedConstructors: boolean;\n    firstCreatePass: number;\n    tNode: number;\n    tView: number;\n    rendererCreateTextNode: number;\n    rendererSetText: number;\n    rendererCreateElement: number;\n    rendererAddEventListener: number;\n    rendererSetAttribute: number;\n    rendererRemoveAttribute: number;\n    rendererSetProperty: number;\n    rendererSetClassName: number;\n    rendererAddClass: number;\n    rendererRemoveClass: number;\n    rendererSetStyle: number;\n    rendererRemoveStyle: number;\n    rendererDestroy: number;\n    rendererDestroyNode: number;\n    rendererMoveNode: number;\n    rendererRemoveNode: number;\n    rendererAppendChild: number;\n    rendererInsertBefore: number;\n    rendererCreateComment: number;\n  }\n}\n\nexport function ngDevModeResetPerfCounters(): NgDevModePerfCounters {\n  const locationString = typeof location !== 'undefined' ? location.toString() : '';\n  const newCounters: NgDevModePerfCounters = {\n    namedConstructors: locationString.indexOf('ngDevMode=namedConstructors') != -1,\n    firstCreatePass: 0,\n    tNode: 0,\n    tView: 0,\n    rendererCreateTextNode: 0,\n    rendererSetText: 0,\n    rendererCreateElement: 0,\n    rendererAddEventListener: 0,\n    rendererSetAttribute: 0,\n    rendererRemoveAttribute: 0,\n    rendererSetProperty: 0,\n    rendererSetClassName: 0,\n    rendererAddClass: 0,\n    rendererRemoveClass: 0,\n    rendererSetStyle: 0,\n    rendererRemoveStyle: 0,\n    rendererDestroy: 0,\n    rendererDestroyNode: 0,\n    rendererMoveNode: 0,\n    rendererRemoveNode: 0,\n    rendererAppendChild: 0,\n    rendererInsertBefore: 0,\n    rendererCreateComment: 0,\n  };\n\n  // Make sure to refer to ngDevMode as ['ngDevMode'] for closure.\n  const allowNgDevModeTrue = locationString.indexOf('ngDevMode=false') === -1;\n  global['ngDevMode'] = allowNgDevModeTrue && newCounters;\n  return newCounters;\n}\n\n/**\n * This function checks to see if the `ngDevMode` has been set. If yes,\n * then we honor it, otherwise we default to dev mode with additional checks.\n *\n * The idea is that unless we are doing production build where we explicitly\n * set `ngDevMode == false` we should be helping the developer by providing\n * as much early warning and errors as possible.\n *\n * `ÉµÉµdefineComponent` is guaranteed to have been called before any component template functions\n * (and thus Ivy instructions), so a single initialization there is sufficient to ensure ngDevMode\n * is defined for the entire instruction set.\n *\n * When using checking `ngDevMode` on toplevel, always init it before referencing it\n * (e.g. `((typeof ngDevMode === 'undefined' || ngDevMode) && initNgDevMode())`), otherwise you can\n *  get a `ReferenceError` like in https://github.com/angular/angular/issues/31595.\n *\n * Details on possible values for `ngDevMode` can be found on its docstring.\n *\n * NOTE:\n * - changes to the `ngDevMode` name must be synced with `compiler-cli/src/tooling.ts`.\n */\nexport function initNgDevMode(): boolean {\n  // The below checks are to ensure that calling `initNgDevMode` multiple times does not\n  // reset the counters.\n  // If the `ngDevMode` is not an object, then it means we have not created the perf counters\n  // yet.\n  if (typeof ngDevMode === 'undefined' || ngDevMode) {\n    if (typeof ngDevMode !== 'object') {\n      ngDevModeResetPerfCounters();\n    }\n    return !!ngDevMode;\n  }\n  return false;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Type} from '../interface/type';\n\nimport {ÉµÉµdefineInjectable} from './interface/defs';\n\n/**\n * Creates a token that can be used in a DI Provider.\n *\n * Use an `InjectionToken` whenever the type you are injecting is not reified (does not have a\n * runtime representation) such as when injecting an interface, callable type, array or\n * parameterized type.\n *\n * `InjectionToken` is parameterized on `T` which is the type of object which will be returned by\n * the `Injector`. This provides additional level of type safety.\n *\n * ```\n * interface MyInterface {...}\n * var myInterface = injector.get(new InjectionToken<MyInterface>('SomeToken'));\n * // myInterface is inferred to be MyInterface.\n * ```\n *\n * When creating an `InjectionToken`, you can optionally specify a factory function which returns\n * (possibly by creating) a default value of the parameterized type `T`. This sets up the\n * `InjectionToken` using this factory as a provider as if it was defined explicitly in the\n * application's root injector. If the factory function, which takes zero arguments, needs to inject\n * dependencies, it can do so using the `inject` function. See below for an example.\n *\n * Additionally, if a `factory` is specified you can also specify the `providedIn` option, which\n * overrides the above behavior and marks the token as belonging to a particular `@NgModule`. As\n * mentioned above, `'root'` is the default value for `providedIn`.\n *\n * @usageNotes\n * ### Basic Example\n *\n * ### Plain InjectionToken\n *\n * {@example core/di/ts/injector_spec.ts region='InjectionToken'}\n *\n * ### Tree-shakable InjectionToken\n *\n * {@example core/di/ts/injector_spec.ts region='ShakableInjectionToken'}\n *\n *\n * @publicApi\n */\nexport class InjectionToken<T> {\n  /** @internal */\n  readonly ngMetadataName = 'InjectionToken';\n\n  readonly Éµprov: never|undefined;\n\n  constructor(protected _desc: string, options?: {\n    providedIn?: Type<any>| 'root' | 'platform' | 'any' | null,\n    factory: () => T\n  }) {\n    this.Éµprov = undefined;\n    if (typeof options == 'number') {\n      // This is a special hack to assign __NG_ELEMENT_ID__ to this instance.\n      // __NG_ELEMENT_ID__ is Used by Ivy to determine bloom filter id.\n      // We are using it to assign `-1` which is used to identify `Injector`.\n      (this as any).__NG_ELEMENT_ID__ = options;\n    } else if (options !== undefined) {\n      this.Éµprov = ÉµÉµdefineInjectable({\n        token: this,\n        providedIn: options.providedIn || 'root',\n        factory: options.factory,\n      });\n    }\n  }\n\n  toString(): string { return `InjectionToken ${this._desc}`; }\n}\n\nexport interface InjectableDefToken<T> extends InjectionToken<T> { Éµprov: never; }\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport '../util/ng_dev_mode';\n\nimport {Type} from '../interface/type';\nimport {getClosureSafeProperty} from '../util/property';\nimport {stringify} from '../util/stringify';\n\nimport {resolveForwardRef} from './forward_ref';\nimport {InjectionToken} from './injection_token';\nimport {Injector} from './injector';\nimport {getInjectableDef, ÉµÉµInjectableDef} from './interface/defs';\nimport {InjectFlags} from './interface/injector';\nimport {ValueProvider} from './interface/provider';\nimport {Inject, Optional, Self, SkipSelf} from './metadata';\n\n\n\n/**\n * An InjectionToken that gets the current `Injector` for `createInjector()`-style injectors.\n *\n * Requesting this token instead of `Injector` allows `StaticInjector` to be tree-shaken from a\n * project.\n *\n * @publicApi\n */\nexport const INJECTOR = new InjectionToken<Injector>(\n    'INJECTOR',\n    -1 as any  // `-1` is used by Ivy DI system as special value to recognize it as `Injector`.\n    );\n\nconst _THROW_IF_NOT_FOUND = {};\nexport const THROW_IF_NOT_FOUND = _THROW_IF_NOT_FOUND;\n\nexport const NG_TEMP_TOKEN_PATH = 'ngTempTokenPath';\nconst NG_TOKEN_PATH = 'ngTokenPath';\nconst NEW_LINE = /\\n/gm;\nconst NO_NEW_LINE = 'Éµ';\nexport const SOURCE = '__source';\n\nexport const USE_VALUE =\n    getClosureSafeProperty<ValueProvider>({provide: String, useValue: getClosureSafeProperty});\n\n/**\n * Current injector value used by `inject`.\n * - `undefined`: it is an error to call `inject`\n * - `null`: `inject` can be called but there is no injector (limp-mode).\n * - Injector instance: Use the injector for resolution.\n */\nlet _currentInjector: Injector|undefined|null = undefined;\n\nexport function setCurrentInjector(injector: Injector | null | undefined): Injector|undefined|null {\n  const former = _currentInjector;\n  _currentInjector = injector;\n  return former;\n}\n\n/**\n * Current implementation of inject.\n *\n * By default, it is `injectInjectorOnly`, which makes it `Injector`-only aware. It can be changed\n * to `directiveInject`, which brings in the `NodeInjector` system of ivy. It is designed this\n * way for two reasons:\n *  1. `Injector` should not depend on ivy logic.\n *  2. To maintain tree shake-ability we don't want to bring in unnecessary code.\n */\nlet _injectImplementation:\n    (<T>(token: Type<T>| InjectionToken<T>, flags?: InjectFlags) => T | null)|undefined;\n\n/**\n * Sets the current inject implementation.\n */\nexport function setInjectImplementation(\n    impl: (<T>(token: Type<T>| InjectionToken<T>, flags?: InjectFlags) => T | null) | undefined):\n    (<T>(token: Type<T>| InjectionToken<T>, flags?: InjectFlags) => T | null)|undefined {\n  const previous = _injectImplementation;\n  _injectImplementation = impl;\n  return previous;\n}\n\nexport function injectInjectorOnly<T>(token: Type<T>| InjectionToken<T>): T;\nexport function injectInjectorOnly<T>(token: Type<T>| InjectionToken<T>, flags?: InjectFlags): T|\n    null;\nexport function injectInjectorOnly<T>(\n    token: Type<T>| InjectionToken<T>, flags = InjectFlags.Default): T|null {\n  if (_currentInjector === undefined) {\n    throw new Error(`inject() must be called from an injection context`);\n  } else if (_currentInjector === null) {\n    return injectRootLimpMode(token, undefined, flags);\n  } else {\n    return _currentInjector.get(token, flags & InjectFlags.Optional ? null : undefined, flags);\n  }\n}\n\n/**\n * Generated instruction: Injects a token from the currently active injector.\n *\n * Must be used in the context of a factory function such as one defined for an\n * `InjectionToken`. Throws an error if not called from such a context.\n *\n * (Additional documentation moved to `inject`, as it is the public API, and an alias for this instruction)\n *\n * @see inject\n * @codeGenApi\n */\nexport function ÉµÉµinject<T>(token: Type<T>| InjectionToken<T>): T;\nexport function ÉµÉµinject<T>(token: Type<T>| InjectionToken<T>, flags?: InjectFlags): T|null;\nexport function ÉµÉµinject<T>(token: Type<T>| InjectionToken<T>, flags = InjectFlags.Default): T|\n    null {\n  return (_injectImplementation || injectInjectorOnly)(resolveForwardRef(token), flags);\n}\n\n/**\n * Throws an error indicating that a factory function could not be generated by the compiler for a\n * particular class.\n *\n * This instruction allows the actual error message to be optimized away when ngDevMode is turned\n * off, saving bytes of generated code while still providing a good experience in dev mode.\n *\n * The name of the class is not mentioned here, but will be in the generated factory function name\n * and thus in the stack trace.\n *\n * @codeGenApi\n */\nexport function ÉµÉµinvalidFactoryDep(index: number): never {\n  const msg = ngDevMode ?\n      `This constructor is not compatible with Angular Dependency Injection because its dependency at index ${index} of the parameter list is invalid.\nThis can happen if the dependency type is a primitive like a string or if an ancestor of this class is missing an Angular decorator.\n\nPlease check that 1) the type for the parameter at index ${index} is correct and 2) the correct Angular decorators are defined for this class and its ancestors.` :\n      'invalid';\n  throw new Error(msg);\n}\n\n/**\n * Injects a token from the currently active injector.\n *\n * Must be used in the context of a factory function such as one defined for an\n * `InjectionToken`. Throws an error if not called from such a context.\n *\n * Within such a factory function, using this function to request injection of a dependency\n * is faster and more type-safe than providing an additional array of dependencies\n * (as has been common with `useFactory` providers).\n *\n * @param token The injection token for the dependency to be injected.\n * @param flags Optional flags that control how injection is executed.\n * The flags correspond to injection strategies that can be specified with\n * parameter decorators `@Host`, `@Self`, `@SkipSef`, and `@Optional`.\n * @returns True if injection is successful, null otherwise.\n *\n * @usageNotes\n *\n * ### Example\n *\n * {@example core/di/ts/injector_spec.ts region='ShakableInjectionToken'}\n *\n * @publicApi\n */\nexport const inject = ÉµÉµinject;\n\n/**\n * Injects `root` tokens in limp mode.\n *\n * If no injector exists, we can still inject tree-shakable providers which have `providedIn` set to\n * `\"root\"`. This is known as the limp mode injection. In such case the value is stored in the\n * `InjectableDef`.\n */\nexport function injectRootLimpMode<T>(\n    token: Type<T>| InjectionToken<T>, notFoundValue: T | undefined, flags: InjectFlags): T|null {\n  const injectableDef: ÉµÉµInjectableDef<T>|null = getInjectableDef(token);\n  if (injectableDef && injectableDef.providedIn == 'root') {\n    return injectableDef.value === undefined ? injectableDef.value = injectableDef.factory() :\n                                               injectableDef.value;\n  }\n  if (flags & InjectFlags.Optional) return null;\n  if (notFoundValue !== undefined) return notFoundValue;\n  throw new Error(`Injector: NOT_FOUND [${stringify(token)}]`);\n}\n\nexport function injectArgs(types: (Type<any>| InjectionToken<any>| any[])[]): any[] {\n  const args: any[] = [];\n  for (let i = 0; i < types.length; i++) {\n    const arg = resolveForwardRef(types[i]);\n    if (Array.isArray(arg)) {\n      if (arg.length === 0) {\n        throw new Error('Arguments array must have arguments.');\n      }\n      let type: Type<any>|undefined = undefined;\n      let flags: InjectFlags = InjectFlags.Default;\n\n      for (let j = 0; j < arg.length; j++) {\n        const meta = arg[j];\n        if (meta instanceof Optional || meta.ngMetadataName === 'Optional' || meta === Optional) {\n          flags |= InjectFlags.Optional;\n        } else if (\n            meta instanceof SkipSelf || meta.ngMetadataName === 'SkipSelf' || meta === SkipSelf) {\n          flags |= InjectFlags.SkipSelf;\n        } else if (meta instanceof Self || meta.ngMetadataName === 'Self' || meta === Self) {\n          flags |= InjectFlags.Self;\n        } else if (meta instanceof Inject || meta === Inject) {\n          type = meta.token;\n        } else {\n          type = meta;\n        }\n      }\n\n      args.push(ÉµÉµinject(type !, flags));\n    } else {\n      args.push(ÉµÉµinject(arg));\n    }\n  }\n  return args;\n}\n\n\nexport class NullInjector implements Injector {\n  get(token: any, notFoundValue: any = THROW_IF_NOT_FOUND): any {\n    if (notFoundValue === THROW_IF_NOT_FOUND) {\n      // Intentionally left behind: With dev tools open the debugger will stop here. There is no\n      // reason why correctly written application should cause this exception.\n      // TODO(misko): uncomment the next line once `ngDevMode` works with closure.\n      // if (ngDevMode) debugger;\n      const error = new Error(`NullInjectorError: No provider for ${stringify(token)}!`);\n      error.name = 'NullInjectorError';\n      throw error;\n    }\n    return notFoundValue;\n  }\n}\n\n\nexport function catchInjectorError(\n    e: any, token: any, injectorErrorName: string, source: string | null): never {\n  const tokenPath: any[] = e[NG_TEMP_TOKEN_PATH];\n  if (token[SOURCE]) {\n    tokenPath.unshift(token[SOURCE]);\n  }\n  e.message = formatError('\\n' + e.message, tokenPath, injectorErrorName, source);\n  e[NG_TOKEN_PATH] = tokenPath;\n  e[NG_TEMP_TOKEN_PATH] = null;\n  throw e;\n}\n\nexport function formatError(\n    text: string, obj: any, injectorErrorName: string, source: string | null = null): string {\n  text = text && text.charAt(0) === '\\n' && text.charAt(1) == NO_NEW_LINE ? text.substr(2) : text;\n  let context = stringify(obj);\n  if (Array.isArray(obj)) {\n    context = obj.map(stringify).join(' -> ');\n  } else if (typeof obj === 'object') {\n    let parts = <string[]>[];\n    for (let key in obj) {\n      if (obj.hasOwnProperty(key)) {\n        let value = obj[key];\n        parts.push(\n            key + ':' + (typeof value === 'string' ? JSON.stringify(value) : stringify(value)));\n      }\n    }\n    context = `{${parts.join(', ')}}`;\n  }\n  return `${injectorErrorName}${source ? '(' + source + ')' : ''}[${context}]: ${text.replace(NEW_LINE, '\\n  ')}`;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Type} from '../../interface/type';\nimport {isForwardRef, resolveForwardRef} from '../forward_ref';\nimport {ÉµÉµinject, ÉµÉµinvalidFactoryDep} from '../injector_compatibility';\nimport {getInjectableDef, getInjectorDef, ÉµÉµdefineInjectable, ÉµÉµdefineInjector} from '../interface/defs';\n\n\n\n/**\n * A mapping of the @angular/core API surface used in generated expressions to the actual symbols.\n *\n * This should be kept up to date with the public exports of @angular/core.\n */\nexport const angularCoreDiEnv: {[name: string]: Function} = {\n  'ÉµÉµdefineInjectable': ÉµÉµdefineInjectable,\n  'ÉµÉµdefineInjector': ÉµÉµdefineInjector,\n  'ÉµÉµinject': ÉµÉµinject,\n  'ÉµÉµgetFactoryOf': getFactoryOf,\n  'ÉµÉµinvalidFactoryDep': ÉµÉµinvalidFactoryDep,\n};\n\nfunction getFactoryOf<T>(type: Type<any>): ((type?: Type<T>) => T)|null {\n  const typeAny = type as any;\n\n  if (isForwardRef(type)) {\n    return (() => {\n      const factory = getFactoryOf<T>(resolveForwardRef(typeAny));\n      return factory ? factory() : null;\n    }) as any;\n  }\n\n  const def = getInjectableDef<T>(typeAny) || getInjectorDef<T>(typeAny);\n  if (!def || def.factory === undefined) {\n    return null;\n  }\n  return def.factory;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Injector} from '../di/injector';\nimport {Type} from '../interface/type';\n\nimport {ComponentFactoryResolver} from './component_factory_resolver';\n\n\n/**\n * Represents an instance of an NgModule created via a {@link NgModuleFactory}.\n *\n * `NgModuleRef` provides access to the NgModule Instance as well other objects related to this\n * NgModule Instance.\n *\n * @publicApi\n */\nexport abstract class NgModuleRef<T> {\n  /**\n   * The injector that contains all of the providers of the NgModule.\n   */\n  abstract get injector(): Injector;\n\n  /**\n   * The ComponentFactoryResolver to get hold of the ComponentFactories\n   * declared in the `entryComponents` property of the module.\n   */\n  abstract get componentFactoryResolver(): ComponentFactoryResolver;\n\n  /**\n   * The NgModule instance.\n   */\n  abstract get instance(): T;\n\n  /**\n   * Destroys the module instance and all of the data structures associated with it.\n   */\n  abstract destroy(): void;\n\n  /**\n   * Allows to register a callback that will be called when the module is destroyed.\n   */\n  abstract onDestroy(callback: () => void): void;\n}\n\nexport interface InternalNgModuleRef<T> extends NgModuleRef<T> {\n  // Note: we are using the prefix _ as NgModuleData is an NgModuleRef and therefore directly\n  // exposed to the user.\n  _bootstrapComponents: Type<any>[];\n}\n\n/**\n * @publicApi\n */\nexport abstract class NgModuleFactory<T> {\n  abstract get moduleType(): Type<T>;\n  abstract create(parentInjector: Injector|null): NgModuleRef<T>;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n// The functions in this file verify that the assumptions we are making\n// about state in an instruction are correct before implementing any logic.\n// They are meant only to be called in dev mode as sanity checks.\n\nimport {stringify} from './stringify';\n\nexport function assertNumber(actual: any, msg: string) {\n  if (!(typeof actual === 'number')) {\n    throwError(msg, typeof actual, 'number', '===');\n  }\n}\n\nexport function assertNumberInRange(actual: any, minInclusive: number, maxInclusive: number) {\n  assertNumber(actual, 'Expected a number');\n  assertLessThanOrEqual(actual, maxInclusive, 'Expected number to be less than or equal to');\n  assertGreaterThanOrEqual(actual, minInclusive, 'Expected number to be greater than or equal to');\n}\n\nexport function assertString(actual: any, msg: string) {\n  if (!(typeof actual === 'string')) {\n    throwError(msg, actual === null ? 'null' : typeof actual, 'string', '===');\n  }\n}\n\nexport function assertEqual<T>(actual: T, expected: T, msg: string) {\n  if (!(actual == expected)) {\n    throwError(msg, actual, expected, '==');\n  }\n}\n\nexport function assertNotEqual<T>(actual: T, expected: T, msg: string) {\n  if (!(actual != expected)) {\n    throwError(msg, actual, expected, '!=');\n  }\n}\n\nexport function assertSame<T>(actual: T, expected: T, msg: string) {\n  if (!(actual === expected)) {\n    throwError(msg, actual, expected, '===');\n  }\n}\n\nexport function assertNotSame<T>(actual: T, expected: T, msg: string) {\n  if (!(actual !== expected)) {\n    throwError(msg, actual, expected, '!==');\n  }\n}\n\nexport function assertLessThan<T>(actual: T, expected: T, msg: string) {\n  if (!(actual < expected)) {\n    throwError(msg, actual, expected, '<');\n  }\n}\n\nexport function assertLessThanOrEqual<T>(actual: T, expected: T, msg: string) {\n  if (!(actual <= expected)) {\n    throwError(msg, actual, expected, '<=');\n  }\n}\n\nexport function assertGreaterThan<T>(actual: T, expected: T, msg: string) {\n  if (!(actual > expected)) {\n    throwError(msg, actual, expected, '>');\n  }\n}\n\nexport function assertGreaterThanOrEqual<T>(actual: T, expected: T, msg: string) {\n  if (!(actual >= expected)) {\n    throwError(msg, actual, expected, '>=');\n  }\n}\n\nexport function assertNotDefined<T>(actual: T, msg: string) {\n  if (actual != null) {\n    throwError(msg, actual, null, '==');\n  }\n}\n\nexport function assertDefined<T>(actual: T, msg: string) {\n  if (actual == null) {\n    throwError(msg, actual, null, '!=');\n  }\n}\n\nexport function throwError(msg: string): never;\nexport function throwError(msg: string, actual: any, expected: any, comparison: string): never;\nexport function throwError(msg: string, actual?: any, expected?: any, comparison?: string): never {\n  // tslint:disable-next-line\n  debugger;  // Left intentionally for better debugger experience.\n  throw new Error(\n      `ASSERTION ERROR: ${msg}` +\n      (comparison == null ? '' : ` [Expected=> ${expected} ${comparison} ${actual} <=Actual]`));\n}\n\nexport function assertDomNode(node: any) {\n  // If we're in a worker, `Node` will not be defined.\n  assertEqual(\n      (typeof Node !== 'undefined' && node instanceof Node) ||\n          (typeof node === 'object' && node != null &&\n           node.constructor.name === 'WebWorkerRenderNode'),\n      true, `The provided value must be an instance of a DOM Node but got ${stringify(node)}`);\n}\n\n\nexport function assertDataInRange(arr: any[], index: number) {\n  const maxLen = arr ? arr.length : 0;\n  assertLessThan(index, maxLen, `Index expected to be less than ${maxLen} but got ${index}`);\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {assertEqual, assertLessThanOrEqual} from './assert';\n\n/**\n* Equivalent to ES6 spread, add each item to an array.\n*\n* @param items The items to add\n* @param arr The array to which you want to add the items\n*/\nexport function addAllToArray(items: any[], arr: any[]) {\n  for (let i = 0; i < items.length; i++) {\n    arr.push(items[i]);\n  }\n}\n\n/**\n * Flattens an array.\n */\nexport function flatten(list: any[], dst?: any[]): any[] {\n  if (dst === undefined) dst = list;\n  for (let i = 0; i < list.length; i++) {\n    let item = list[i];\n    if (Array.isArray(item)) {\n      // we need to inline it.\n      if (dst === list) {\n        // Our assumption that the list was already flat was wrong and\n        // we need to clone flat since we need to write to it.\n        dst = list.slice(0, i);\n      }\n      flatten(item, dst);\n    } else if (dst !== list) {\n      dst.push(item);\n    }\n  }\n  return dst;\n}\n\nexport function deepForEach<T>(input: (T | any[])[], fn: (value: T) => void): void {\n  input.forEach(value => Array.isArray(value) ? deepForEach(value, fn) : fn(value));\n}\n\nexport function addToArray(arr: any[], index: number, value: any): void {\n  // perf: array.push is faster than array.splice!\n  if (index >= arr.length) {\n    arr.push(value);\n  } else {\n    arr.splice(index, 0, value);\n  }\n}\n\nexport function removeFromArray(arr: any[], index: number): any {\n  // perf: array.pop is faster than array.splice!\n  if (index >= arr.length - 1) {\n    return arr.pop();\n  } else {\n    return arr.splice(index, 1)[0];\n  }\n}\n\nexport function newArray<T = any>(size: number): T[];\nexport function newArray<T>(size: number, value: T): T[];\nexport function newArray<T>(size: number, value?: T): T[] {\n  const list: T[] = [];\n  for (let i = 0; i < size; i++) {\n    list.push(value !);\n  }\n  return list;\n}\n\n/**\n * Remove item from array (Same as `Array.splice()` but faster.)\n *\n * `Array.splice()` is not as fast because it has to allocate an array for the elements which were\n * removed. This causes memory pressure and slows down code when most of the time we don't\n * care about the deleted items array.\n *\n * https://jsperf.com/fast-array-splice (About 20x faster)\n *\n * @param array Array to splice\n * @param index Index of element in array to remove.\n * @param count Number of items to remove.\n */\nexport function arraySplice(array: any[], index: number, count: number): void {\n  const length = array.length - count;\n  while (index < length) {\n    array[index] = array[index + count];\n    index++;\n  }\n  while (count--) {\n    array.pop();  // shrink the array\n  }\n}\n\n/**\n * Same as `Array.splice(index, 0, value)` but faster.\n *\n * `Array.splice()` is not fast because it has to allocate an array for the elements which were\n * removed. This causes memory pressure and slows down code when most of the time we don't\n * care about the deleted items array.\n *\n * @param array Array to splice.\n * @param index Index in array where the `value` should be added.\n * @param value Value to add to array.\n */\nexport function arrayInsert(array: any[], index: number, value: any): void {\n  ngDevMode && assertLessThanOrEqual(index, array.length, 'Can\\'t insert past array end.');\n  let end = array.length;\n  while (end > index) {\n    const previousEnd = end - 1;\n    array[end] = array[previousEnd];\n    end = previousEnd;\n  }\n  array[index] = value;\n}\n\n/**\n * Same as `Array.splice2(index, 0, value1, value2)` but faster.\n *\n * `Array.splice()` is not fast because it has to allocate an array for the elements which were\n * removed. This causes memory pressure and slows down code when most of the time we don't\n * care about the deleted items array.\n *\n * @param array Array to splice.\n * @param index Index in array where the `value` should be added.\n * @param value1 Value to add to array.\n * @param value2 Value to add to array.\n */\nexport function arrayInsert2(array: any[], index: number, value1: any, value2: any): void {\n  ngDevMode && assertLessThanOrEqual(index, array.length, 'Can\\'t insert past array end.');\n  let end = array.length;\n  if (end == index) {\n    // inserting at the end.\n    array.push(value1, value2);\n  } else if (end === 1) {\n    // corner case when we have less items in array than we have items to insert.\n    array.push(value2, array[0]);\n    array[0] = value1;\n  } else {\n    end--;\n    array.push(array[end - 1], array[end]);\n    while (end > index) {\n      const previousEnd = end - 2;\n      array[end] = array[previousEnd];\n      end--;\n    }\n    array[index] = value1;\n    array[index + 1] = value2;\n  }\n}\n\n/**\n * Insert a `value` into an `array` so that the array remains sorted.\n *\n * NOTE:\n * - Duplicates are not allowed, and are ignored.\n * - This uses binary search algorithm for fast inserts.\n *\n * @param array A sorted array to insert into.\n * @param value The value to insert.\n * @returns index of the inserted value.\n */\nexport function arrayInsertSorted(array: string[], value: string): number {\n  let index = arrayIndexOfSorted(array, value);\n  if (index < 0) {\n    // if we did not find it insert it.\n    index = ~index;\n    arrayInsert(array, index, value);\n  }\n  return index;\n}\n\n/**\n * Remove `value` from a sorted `array`.\n *\n * NOTE:\n * - This uses binary search algorithm for fast removals.\n *\n * @param array A sorted array to remove from.\n * @param value The value to remove.\n * @returns index of the removed value.\n *   - positive index if value found and removed.\n *   - negative index if value not found. (`~index` to get the value where it should have been\n *     inserted)\n */\nexport function arrayRemoveSorted(array: string[], value: string): number {\n  const index = arrayIndexOfSorted(array, value);\n  if (index >= 0) {\n    arraySplice(array, index, 1);\n  }\n  return index;\n}\n\n\n/**\n * Get an index of an `value` in a sorted `array`.\n *\n * NOTE:\n * - This uses binary search algorithm for fast removals.\n *\n * @param array A sorted array to binary search.\n * @param value The value to look for.\n * @returns index of the value.\n *   - positive index if value found.\n *   - negative index if value not found. (`~index` to get the value where it should have been\n *     located)\n */\nexport function arrayIndexOfSorted(array: string[], value: string): number {\n  return _arrayIndexOfSorted(array, value, 0);\n}\n\n\n/**\n * `KeyValueArray` is an array where even positions contain keys and odd positions contain values.\n *\n * `KeyValueArray` provides a very efficient way of iterating over its contents. For small\n * sets (~10) the cost of binary searching an `KeyValueArray` has about the same performance\n * characteristics that of a `Map` with significantly better memory footprint.\n *\n * If used as a `Map` the keys are stored in alphabetical order so that they can be binary searched\n * for retrieval.\n *\n * See: `keyValueArraySet`, `keyValueArrayGet`, `keyValueArrayIndexOf`, `keyValueArrayDelete`.\n */\nexport interface KeyValueArray<VALUE> extends Array<VALUE|string> { __brand__: 'array-map'; }\n\n/**\n * Set a `value` for a `key`.\n *\n * @param keyValueArray to modify.\n * @param key The key to locate or create.\n * @param value The value to set for a `key`.\n * @returns index (always even) of where the value vas set.\n */\nexport function keyValueArraySet<V>(\n    keyValueArray: KeyValueArray<V>, key: string, value: V): number {\n  let index = keyValueArrayIndexOf(keyValueArray, key);\n  if (index >= 0) {\n    // if we found it set it.\n    keyValueArray[index | 1] = value;\n  } else {\n    index = ~index;\n    arrayInsert2(keyValueArray, index, key, value);\n  }\n  return index;\n}\n\n/**\n * Retrieve a `value` for a `key` (on `undefined` if not found.)\n * \n * @param keyValueArray to search.\n * @param key The key to locate.\n * @return The `value` stored at the `key` location or `undefined if not found.\n */\nexport function keyValueArrayGet<V>(keyValueArray: KeyValueArray<V>, key: string): V|undefined {\n  const index = keyValueArrayIndexOf(keyValueArray, key);\n  if (index >= 0) {\n    // if we found it retrieve it.\n    return keyValueArray[index | 1] as V;\n  }\n  return undefined;\n}\n\n/**\n * Retrieve a `key` index value in the array or `-1` if not found.\n *\n * @param keyValueArray to search.\n * @param key The key to locate.\n * @returns index of where the key is (or should have been.)\n *   - positive (even) index if key found.\n *   - negative index if key not found. (`~index` (even) to get the index where it should have\n *     been inserted.)\n */\nexport function keyValueArrayIndexOf<V>(keyValueArray: KeyValueArray<V>, key: string): number {\n  return _arrayIndexOfSorted(keyValueArray as string[], key, 1);\n}\n\n/**\n * Delete a `key` (and `value`) from the `KeyValueArray`.\n *\n * @param keyValueArray to modify.\n * @param key The key to locate or delete (if exist).\n * @returns index of where the key was (or should have been.)\n *   - positive (even) index if key found and deleted.\n *   - negative index if key not found. (`~index` (even) to get the index where it should have\n *     been.)\n */\nexport function keyValueArrayDelete<V>(keyValueArray: KeyValueArray<V>, key: string): number {\n  const index = keyValueArrayIndexOf(keyValueArray, key);\n  if (index >= 0) {\n    // if we found it remove it.\n    arraySplice(keyValueArray, index, 2);\n  }\n  return index;\n}\n\n\n/**\n * INTERNAL: Get an index of an `value` in a sorted `array` by grouping search by `shift`.\n *\n * NOTE:\n * - This uses binary search algorithm for fast removals.\n *\n * @param array A sorted array to binary search.\n * @param value The value to look for.\n * @param shift grouping shift.\n *   - `0` means look at every location\n *   - `1` means only look at every other (even) location (the odd locations are to be ignored as\n *         they are values.)\n * @returns index of the value.\n *   - positive index if value found.\n *   - negative index if value not found. (`~index` to get the value where it should have been\n * inserted)\n */\nfunction _arrayIndexOfSorted(array: string[], value: string, shift: number): number {\n  ngDevMode && assertEqual(Array.isArray(array), true, 'Expecting an array');\n  let start = 0;\n  let end = array.length >> shift;\n  while (end !== start) {\n    const middle = start + ((end - start) >> 1);  // find the middle.\n    const current = array[middle << shift];\n    if (value === current) {\n      return (middle << shift);\n    } else if (current > value) {\n      end = middle;\n    } else {\n      start = middle + 1;  // We already searched middle so make it non-inclusive by adding 1\n    }\n  }\n  return ~(end << shift);\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\n/**\n * The strategy that the default change detector uses to detect changes.\n * When set, takes effect the next time change detection is triggered.\n *\n * @publicApi\n */\nexport enum ChangeDetectionStrategy {\n  /**\n   * Use the `CheckOnce` strategy, meaning that automatic change detection is deactivated\n   * until reactivated by setting the strategy to `Default` (`CheckAlways`).\n   * Change detection can still be explicitly invoked.\n   * This strategy applies to all child directives and cannot be overridden.\n   */\n  OnPush = 0,\n\n  /**\n   * Use the default `CheckAlways` strategy, in which change detection is automatic until\n   * explicitly deactivated.\n   */\n  Default = 1,\n}\n\n/**\n * Defines the possible states of the default change detector.\n * @see `ChangeDetectorRef`\n */\nexport enum ChangeDetectorStatus {\n  /**\n   * A state in which, after calling `detectChanges()`, the change detector\n   * state becomes `Checked`, and must be explicitly invoked or reactivated.\n   */\n  CheckOnce,\n\n  /**\n   * A state in which change detection is skipped until the change detector mode\n   * becomes `CheckOnce`.\n   */\n  Checked,\n\n  /**\n   * A state in which change detection continues automatically until explicitly\n   * deactivated.\n   */\n  CheckAlways,\n\n  /**\n   * A state in which a change detector sub tree is not a part of the main tree and\n   * should be skipped.\n   */\n  Detached,\n\n  /**\n   * Indicates that the change detector encountered an error checking a binding\n   * or calling a directive lifecycle method and is now in an inconsistent state. Change\n   * detectors in this state do not detect changes.\n   */\n  Errored,\n\n  /**\n   * Indicates that the change detector has been destroyed.\n   */\n  Destroyed,\n}\n\n/**\n * Reports whether a given strategy is currently the default for change detection.\n * @param changeDetectionStrategy The strategy to check.\n * @returns True if the given strategy is the current default, false otherwise.\n * @see `ChangeDetectorStatus`\n * @see `ChangeDetectorRef`\n */\nexport function isDefaultChangeDetectionStrategy(changeDetectionStrategy: ChangeDetectionStrategy):\n    boolean {\n  return changeDetectionStrategy == null ||\n      changeDetectionStrategy === ChangeDetectionStrategy.Default;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Defines template and style encapsulation options available for Component's {@link Component}.\n *\n * See {@link Component#encapsulation encapsulation}.\n *\n * @usageNotes\n * ### Example\n *\n * {@example core/ts/metadata/encapsulation.ts region='longform'}\n *\n * @publicApi\n */\nexport enum ViewEncapsulation {\n  /**\n   * Emulate `Native` scoping of styles by adding an attribute containing surrogate id to the Host\n   * Element and pre-processing the style rules provided via {@link Component#styles styles} or\n   * {@link Component#styleUrls styleUrls}, and adding the new Host Element attribute to all\n   * selectors.\n   *\n   * This is the default option.\n   */\n  Emulated = 0,\n  /**\n   * @deprecated v6.1.0 - use {ViewEncapsulation.ShadowDom} instead.\n   * Use the native encapsulation mechanism of the renderer.\n   *\n   * For the DOM this means using the deprecated [Shadow DOM\n   * v0](https://w3c.github.io/webcomponents/spec/shadow/) and\n   * creating a ShadowRoot for Component's Host Element.\n   */\n  Native = 1,\n  /**\n   * Don't provide any template or style encapsulation.\n   */\n  None = 2,\n\n  /**\n   * Use Shadow DOM to encapsulate styles.\n   *\n   * For the DOM this means using modern [Shadow\n   * DOM](https://w3c.github.io/webcomponents/spec/shadow/) and\n   * creating a ShadowRoot for Component's Host Element.\n   */\n  ShadowDom = 3\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Convince closure compiler that the wrapped function has no side-effects.\n *\n * Closure compiler always assumes that `toString` has no side-effects. We use this quirk to\n * allow us to execute a function but have closure compiler mark the call as no-side-effects.\n * It is important that the return value for the `noSideEffects` function be assigned\n * to something which is retained otherwise the call to `noSideEffects` will be removed by closure\n * compiler.\n */\nexport function noSideEffects(fn: () => void): string {\n  return '' + {toString: fn};\n}","/**\n* @license\n* Copyright Google Inc. All Rights Reserved.\n*\n* Use of this source code is governed by an MIT-style license that can be\n* found in the LICENSE file at https://angular.io/license\n*/\nimport {initNgDevMode} from '../util/ng_dev_mode';\n\n/**\n * This file contains reuseable \"empty\" symbols that can be used as default return values\n * in different parts of the rendering code. Because the same symbols are returned, this\n * allows for identity checks against these values to be consistently used by the framework\n * code.\n */\n\nexport const EMPTY_OBJ: {} = {};\nexport const EMPTY_ARRAY: any[] = [];\n\n// freezing the values prevents any code from accidentally inserting new values in\nif ((typeof ngDevMode === 'undefined' || ngDevMode) && initNgDevMode()) {\n  // These property accesses can be ignored because ngDevMode will be set to false\n  // when optimizing code and the whole if statement will be dropped.\n  // tslint:disable-next-line:no-toplevel-property-access\n  Object.freeze(EMPTY_OBJ);\n  // tslint:disable-next-line:no-toplevel-property-access\n  Object.freeze(EMPTY_ARRAY);\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ChangeDetectionStrategy} from '../change_detection/constants';\nimport {Mutable, Type} from '../interface/type';\nimport {NgModuleDef} from '../metadata/ng_module';\nimport {SchemaMetadata} from '../metadata/schema';\nimport {ViewEncapsulation} from '../metadata/view';\nimport {noSideEffects} from '../util/closure';\nimport {initNgDevMode} from '../util/ng_dev_mode';\nimport {stringify} from '../util/stringify';\n\nimport {EMPTY_ARRAY, EMPTY_OBJ} from './empty';\nimport {NG_COMP_DEF, NG_DIR_DEF, NG_FACTORY_DEF, NG_LOC_ID_DEF, NG_MOD_DEF, NG_PIPE_DEF} from './fields';\nimport {ComponentDef, ComponentDefFeature, ComponentTemplate, ComponentType, ContentQueriesFunction, DirectiveDef, DirectiveDefFeature, DirectiveTypesOrFactory, FactoryFn, HostBindingsFunction, PipeDef, PipeType, PipeTypesOrFactory, ViewQueriesFunction} from './interfaces/definition';\nimport {AttributeMarker, TAttributes, TConstants} from './interfaces/node';\nimport {CssSelectorList, SelectorFlags} from './interfaces/projection';\nimport {NgModuleType} from './ng_module_ref';\n\nlet _renderCompCount = 0;\n\n// While these types are unused here, they are required so that types don't\n// get resolved lazily. see: https://github.com/Microsoft/web-build-tools/issues/1050\ntype _web_build_tools_issue_1050_SelectorFlags = SelectorFlags;\ntype _web_build_tools_issue_1050_AttributeMarker = AttributeMarker;\n\n/**\n * Create a component definition object.\n *\n *\n * # Example\n * ```\n * class MyDirective {\n *   // Generated by Angular Template Compiler\n *   // [Symbol] syntax will not be supported by TypeScript until v2.7\n *   static Éµcmp = defineComponent({\n *     ...\n *   });\n * }\n * ```\n * @codeGenApi\n */\nexport function ÉµÉµdefineComponent<T>(componentDefinition: {\n  /**\n   * Directive type, needed to configure the injector.\n   */\n  type: Type<T>;\n\n  /** The selectors that will be used to match nodes to this component. */\n  selectors?: CssSelectorList;\n\n  /**\n   * The number of nodes, local refs, and pipes in this component template.\n   *\n   * Used to calculate the length of this component's LView array, so we\n   * can pre-fill the array and set the binding start index.\n   */\n  // TODO(kara): remove queries from this count\n  decls: number;\n\n  /**\n   * The number of bindings in this component template (including pure fn bindings).\n   *\n   * Used to calculate the length of this component's LView array, so we\n   * can pre-fill the array and set the host binding start index.\n   */\n  vars: number;\n\n  /**\n   * A map of input names.\n   *\n   * The format is in: `{[actualPropertyName: string]:(string|[string, string])}`.\n   *\n   * Given:\n   * ```\n   * class MyComponent {\n   *   @Input()\n   *   publicInput1: string;\n   *\n   *   @Input('publicInput2')\n   *   declaredInput2: string;\n   * }\n   * ```\n   *\n   * is described as:\n   * ```\n   * {\n   *   publicInput1: 'publicInput1',\n   *   declaredInput2: ['publicInput2', 'declaredInput2'],\n   * }\n   * ```\n   *\n   * Which the minifier may translate to:\n   * ```\n   * {\n   *   minifiedPublicInput1: 'publicInput1',\n   *   minifiedDeclaredInput2: ['publicInput2', 'declaredInput2'],\n   * }\n   * ```\n   *\n   * This allows the render to re-construct the minified, public, and declared names\n   * of properties.\n   *\n   * NOTE:\n   *  - Because declared and public name are usually same we only generate the array\n   *    `['public', 'declared']` format when they differ.\n   *  - The reason why this API and `outputs` API is not the same is that `NgOnChanges` has\n   *    inconsistent behavior in that it uses declared names rather than minified or public. For\n   *    this reason `NgOnChanges` will be deprecated and removed in future version and this\n   *    API will be simplified to be consistent with `output`.\n   */\n  inputs?: {[P in keyof T]?: string | [string, string]};\n\n  /**\n   * A map of output names.\n   *\n   * The format is in: `{[actualPropertyName: string]:string}`.\n   *\n   * Which the minifier may translate to: `{[minifiedPropertyName: string]:string}`.\n   *\n   * This allows the render to re-construct the minified and non-minified names\n   * of properties.\n   */\n  outputs?: {[P in keyof T]?: string};\n\n  /**\n   * Function executed by the parent template to allow child directive to apply host bindings.\n   */\n  hostBindings?: HostBindingsFunction<T>;\n\n  /**\n   * The number of bindings in this directive `hostBindings` (including pure fn bindings).\n   *\n   * Used to calculate the length of the component's LView array, so we\n   * can pre-fill the array and set the host binding start index.\n   */\n  hostVars?: number;\n\n  /**\n   * Assign static attribute values to a host element.\n   *\n   * This property will assign static attribute values as well as class and style\n   * values to a host element. Since attribute values can consist of different types of values, the\n   * `hostAttrs` array must include the values in the following format:\n   *\n   * attrs = [\n   *   // static attributes (like `title`, `name`, `id`...)\n   *   attr1, value1, attr2, value,\n   *\n   *   // a single namespace value (like `x:id`)\n   *   NAMESPACE_MARKER, namespaceUri1, name1, value1,\n   *\n   *   // another single namespace value (like `x:name`)\n   *   NAMESPACE_MARKER, namespaceUri2, name2, value2,\n   *\n   *   // a series of CSS classes that will be applied to the element (no spaces)\n   *   CLASSES_MARKER, class1, class2, class3,\n   *\n   *   // a series of CSS styles (property + value) that will be applied to the element\n   *   STYLES_MARKER, prop1, value1, prop2, value2\n   * ]\n   *\n   * All non-class and non-style attributes must be defined at the start of the list\n   * first before all class and style values are set. When there is a change in value\n   * type (like when classes and styles are introduced) a marker must be used to separate\n   * the entries. The marker values themselves are set via entries found in the\n   * [AttributeMarker] enum.\n   */\n  hostAttrs?: TAttributes;\n\n  /**\n   * Function to create instances of content queries associated with a given directive.\n   */\n  contentQueries?: ContentQueriesFunction<T>;\n\n  /**\n   * Defines the name that can be used in the template to assign this directive to a variable.\n   *\n   * See: {@link Directive.exportAs}\n   */\n  exportAs?: string[];\n\n  /**\n   * Template function use for rendering DOM.\n   *\n   * This function has following structure.\n   *\n   * ```\n   * function Template<T>(ctx:T, creationMode: boolean) {\n   *   if (creationMode) {\n   *     // Contains creation mode instructions.\n   *   }\n   *   // Contains binding update instructions\n   * }\n   * ```\n   *\n   * Common instructions are:\n   * Creation mode instructions:\n   *  - `elementStart`, `elementEnd`\n   *  - `text`\n   *  - `container`\n   *  - `listener`\n   *\n   * Binding update instructions:\n   * - `bind`\n   * - `elementAttribute`\n   * - `elementProperty`\n   * - `elementClass`\n   * - `elementStyle`\n   *\n   */\n  template: ComponentTemplate<T>;\n\n  /**\n   * Constants for the nodes in the component's view.\n   * Includes attribute arrays, local definition arrays etc.\n   */\n  consts?: TConstants;\n\n  /**\n   * An array of `ngContent[selector]` values that were found in the template.\n   */\n  ngContentSelectors?: string[];\n\n  /**\n   * Additional set of instructions specific to view query processing. This could be seen as a\n   * set of instruction to be inserted into the template function.\n   *\n   * Query-related instructions need to be pulled out to a specific function as a timing of\n   * execution is different as compared to all other instructions (after change detection hooks but\n   * before view hooks).\n   */\n  viewQuery?: ViewQueriesFunction<T>| null;\n\n  /**\n   * A list of optional features to apply.\n   *\n   * See: {@link NgOnChangesFeature}, {@link ProvidersFeature}\n   */\n  features?: ComponentDefFeature[];\n\n  /**\n   * Defines template and style encapsulation options available for Component's {@link Component}.\n   */\n  encapsulation?: ViewEncapsulation;\n\n  /**\n   * Defines arbitrary developer-defined data to be stored on a renderer instance.\n   * This is useful for renderers that delegate to other renderers.\n   *\n   * see: animation\n   */\n  data?: {[kind: string]: any};\n\n  /**\n   * A set of styles that the component needs to be present for component to render correctly.\n   */\n  styles?: string[];\n\n  /**\n   * The strategy that the default change detector uses to detect changes.\n   * When set, takes effect the next time change detection is triggered.\n   */\n  changeDetection?: ChangeDetectionStrategy;\n\n  /**\n   * Registry of directives and components that may be found in this component's view.\n   *\n   * The property is either an array of `DirectiveDef`s or a function which returns the array of\n   * `DirectiveDef`s. The function is necessary to be able to support forward declarations.\n   */\n  directives?: DirectiveTypesOrFactory | null;\n\n  /**\n   * Registry of pipes that may be found in this component's view.\n   *\n   * The property is either an array of `PipeDefs`s or a function which returns the array of\n   * `PipeDefs`s. The function is necessary to be able to support forward declarations.\n   */\n  pipes?: PipeTypesOrFactory | null;\n\n  /**\n   * The set of schemas that declare elements to be allowed in the component's template.\n   */\n  schemas?: SchemaMetadata[] | null;\n}): never {\n  // Initialize ngDevMode. This must be the first statement in ÉµÉµdefineComponent.\n  // See the `initNgDevMode` docstring for more information.\n  (typeof ngDevMode === 'undefined' || ngDevMode) && initNgDevMode();\n\n  const type = componentDefinition.type;\n  const typePrototype = type.prototype;\n  const declaredInputs: {[key: string]: string} = {} as any;\n  const def: Mutable<ComponentDef<any>, keyof ComponentDef<any>> = {\n    type: type,\n    providersResolver: null,\n    decls: componentDefinition.decls,\n    vars: componentDefinition.vars,\n    factory: null,\n    template: componentDefinition.template || null !,\n    consts: componentDefinition.consts || null,\n    ngContentSelectors: componentDefinition.ngContentSelectors,\n    hostBindings: componentDefinition.hostBindings || null,\n    hostVars: componentDefinition.hostVars || 0,\n    hostAttrs: componentDefinition.hostAttrs || null,\n    contentQueries: componentDefinition.contentQueries || null,\n    declaredInputs: declaredInputs,\n    inputs: null !,   // assigned in noSideEffects\n    outputs: null !,  // assigned in noSideEffects\n    exportAs: componentDefinition.exportAs || null,\n    onChanges: null,\n    onInit: typePrototype.ngOnInit || null,\n    doCheck: typePrototype.ngDoCheck || null,\n    afterContentInit: typePrototype.ngAfterContentInit || null,\n    afterContentChecked: typePrototype.ngAfterContentChecked || null,\n    afterViewInit: typePrototype.ngAfterViewInit || null,\n    afterViewChecked: typePrototype.ngAfterViewChecked || null,\n    onDestroy: typePrototype.ngOnDestroy || null,\n    onPush: componentDefinition.changeDetection === ChangeDetectionStrategy.OnPush,\n    directiveDefs: null !,  // assigned in noSideEffects\n    pipeDefs: null !,       // assigned in noSideEffects\n    selectors: componentDefinition.selectors || EMPTY_ARRAY,\n    viewQuery: componentDefinition.viewQuery || null,\n    features: componentDefinition.features as DirectiveDefFeature[] || null,\n    data: componentDefinition.data || {},\n    // TODO(misko): convert ViewEncapsulation into const enum so that it can be used directly in the\n    // next line. Also `None` should be 0 not 2.\n    encapsulation: componentDefinition.encapsulation || ViewEncapsulation.Emulated,\n    id: 'c',\n    styles: componentDefinition.styles || EMPTY_ARRAY,\n    _: null as never,\n    setInput: null,\n    schemas: componentDefinition.schemas || null,\n    tView: null,\n  };\n  def._ = noSideEffects(() => {\n    const directiveTypes = componentDefinition.directives !;\n    const feature = componentDefinition.features;\n    const pipeTypes = componentDefinition.pipes !;\n    def.id += _renderCompCount++;\n    def.inputs = invertObject(componentDefinition.inputs, declaredInputs),\n    def.outputs = invertObject(componentDefinition.outputs),\n    feature && feature.forEach((fn) => fn(def));\n    def.directiveDefs = directiveTypes ?\n        () => (typeof directiveTypes === 'function' ? directiveTypes() : directiveTypes)\n                  .map(extractDirectiveDef) :\n        null;\n    def.pipeDefs = pipeTypes ?\n        () => (typeof pipeTypes === 'function' ? pipeTypes() : pipeTypes).map(extractPipeDef) :\n        null;\n  }) as never;\n\n  return def as never;\n}\n\n/**\n * @codeGenApi\n */\nexport function ÉµÉµsetComponentScope(\n    type: ComponentType<any>, directives: Type<any>[], pipes: Type<any>[]): void {\n  const def = (type.Éµcmp as ComponentDef<any>);\n  def.directiveDefs = () => directives.map(extractDirectiveDef);\n  def.pipeDefs = () => pipes.map(extractPipeDef);\n}\n\nexport function extractDirectiveDef(type: Type<any>): DirectiveDef<any>|ComponentDef<any> {\n  const def = getComponentDef(type) || getDirectiveDef(type);\n  if (ngDevMode && !def) {\n    throw new Error(`'${type.name}' is neither 'ComponentType' or 'DirectiveType'.`);\n  }\n  return def !;\n}\n\nexport function extractPipeDef(type: Type<any>): PipeDef<any> {\n  const def = getPipeDef(type);\n  if (ngDevMode && !def) {\n    throw new Error(`'${type.name}' is not a 'PipeType'.`);\n  }\n  return def !;\n}\n\nexport const autoRegisterModuleById: {[id: string]: NgModuleType} = {};\n\n/**\n * @codeGenApi\n */\nexport function ÉµÉµdefineNgModule<T>(def: {\n  /** Token representing the module. Used by DI. */\n  type: T;\n\n  /** List of components to bootstrap. */\n  bootstrap?: Type<any>[] | (() => Type<any>[]);\n\n  /** List of components, directives, and pipes declared by this module. */\n  declarations?: Type<any>[] | (() => Type<any>[]);\n\n  /** List of modules or `ModuleWithProviders` imported by this module. */\n  imports?: Type<any>[] | (() => Type<any>[]);\n\n  /**\n   * List of modules, `ModuleWithProviders`, components, directives, or pipes exported by this\n   * module.\n   */\n  exports?: Type<any>[] | (() => Type<any>[]);\n\n  /** The set of schemas that declare elements to be allowed in the NgModule. */\n  schemas?: SchemaMetadata[] | null;\n\n  /** Unique ID for the module that is used with `getModuleFactory`. */\n  id?: string | null;\n}): never {\n  const res: NgModuleDef<T> = {\n    type: def.type,\n    bootstrap: def.bootstrap || EMPTY_ARRAY,\n    declarations: def.declarations || EMPTY_ARRAY,\n    imports: def.imports || EMPTY_ARRAY,\n    exports: def.exports || EMPTY_ARRAY,\n    transitiveCompileScopes: null,\n    schemas: def.schemas || null,\n    id: def.id || null,\n  };\n  if (def.id != null) {\n    noSideEffects(\n        () => { autoRegisterModuleById[def.id !] = def.type as unknown as NgModuleType; });\n  }\n  return res as never;\n}\n\n/**\n * Adds the module metadata that is necessary to compute the module's transitive scope to an\n * existing module definition.\n *\n * Scope metadata of modules is not used in production builds, so calls to this function can be\n * marked pure to tree-shake it from the bundle, allowing for all referenced declarations\n * to become eligible for tree-shaking as well.\n *\n * @codeGenApi\n */\nexport function ÉµÉµsetNgModuleScope(type: any, scope: {\n  /** List of components, directives, and pipes declared by this module. */\n  declarations?: Type<any>[] | (() => Type<any>[]);\n\n  /** List of modules or `ModuleWithProviders` imported by this module. */\n  imports?: Type<any>[] | (() => Type<any>[]);\n\n  /**\n   * List of modules, `ModuleWithProviders`, components, directives, or pipes exported by this\n   * module.\n   */\n  exports?: Type<any>[] | (() => Type<any>[]);\n}): void {\n  return noSideEffects(() => {\n    const ngModuleDef = getNgModuleDef(type, true);\n    ngModuleDef.declarations = scope.declarations || EMPTY_ARRAY;\n    ngModuleDef.imports = scope.imports || EMPTY_ARRAY;\n    ngModuleDef.exports = scope.exports || EMPTY_ARRAY;\n  }) as never;\n}\n\n/**\n * Inverts an inputs or outputs lookup such that the keys, which were the\n * minified keys, are part of the values, and the values are parsed so that\n * the publicName of the property is the new key\n *\n * e.g. for\n *\n * ```\n * class Comp {\n *   @Input()\n *   propName1: string;\n *\n *   @Input('publicName2')\n *   declaredPropName2: number;\n * }\n * ```\n *\n * will be serialized as\n *\n * ```\n * {\n *   propName1: 'propName1',\n *   declaredPropName2: ['publicName2', 'declaredPropName2'],\n * }\n * ```\n *\n * which is than translated by the minifier as:\n *\n * ```\n * {\n *   minifiedPropName1: 'propName1',\n *   minifiedPropName2: ['publicName2', 'declaredPropName2'],\n * }\n * ```\n *\n * becomes: (public name => minifiedName)\n *\n * ```\n * {\n *  'propName1': 'minifiedPropName1',\n *  'publicName2': 'minifiedPropName2',\n * }\n * ```\n *\n * Optionally the function can take `secondary` which will result in: (public name => declared name)\n *\n * ```\n * {\n *  'propName1': 'propName1',\n *  'publicName2': 'declaredPropName2',\n * }\n * ```\n *\n\n */\nfunction invertObject<T>(\n    obj?: {[P in keyof T]?: string | [string, string]},\n    secondary?: {[key: string]: string}): {[P in keyof T]: string} {\n  if (obj == null) return EMPTY_OBJ as any;\n  const newLookup: any = {};\n  for (const minifiedKey in obj) {\n    if (obj.hasOwnProperty(minifiedKey)) {\n      let publicName: string|[string, string] = obj[minifiedKey] !;\n      let declaredName = publicName;\n      if (Array.isArray(publicName)) {\n        declaredName = publicName[1];\n        publicName = publicName[0];\n      }\n      newLookup[publicName] = minifiedKey;\n      if (secondary) {\n        (secondary[publicName] = declaredName as string);\n      }\n    }\n  }\n  return newLookup;\n}\n\n/**\n * Create a directive definition object.\n *\n * # Example\n * ```ts\n * class MyDirective {\n *   // Generated by Angular Template Compiler\n *   // [Symbol] syntax will not be supported by TypeScript until v2.7\n *   static Éµdir = ÉµÉµdefineDirective({\n *     ...\n *   });\n * }\n * ```\n *\n * @codeGenApi\n */\nexport const ÉµÉµdefineDirective = ÉµÉµdefineComponent as any as<T>(directiveDefinition: {\n  /**\n   * Directive type, needed to configure the injector.\n   */\n  type: Type<T>;\n\n  /** The selectors that will be used to match nodes to this directive. */\n  selectors?: CssSelectorList;\n\n  /**\n   * A map of input names.\n   *\n   * The format is in: `{[actualPropertyName: string]:(string|[string, string])}`.\n   *\n   * Given:\n   * ```\n   * class MyComponent {\n   *   @Input()\n   *   publicInput1: string;\n   *\n   *   @Input('publicInput2')\n   *   declaredInput2: string;\n   * }\n   * ```\n   *\n   * is described as:\n   * ```\n   * {\n   *   publicInput1: 'publicInput1',\n   *   declaredInput2: ['declaredInput2', 'publicInput2'],\n   * }\n   * ```\n   *\n   * Which the minifier may translate to:\n   * ```\n   * {\n   *   minifiedPublicInput1: 'publicInput1',\n   *   minifiedDeclaredInput2: [ 'publicInput2', 'declaredInput2'],\n   * }\n   * ```\n   *\n   * This allows the render to re-construct the minified, public, and declared names\n   * of properties.\n   *\n   * NOTE:\n   *  - Because declared and public name are usually same we only generate the array\n   *    `['declared', 'public']` format when they differ.\n   *  - The reason why this API and `outputs` API is not the same is that `NgOnChanges` has\n   *    inconsistent behavior in that it uses declared names rather than minified or public. For\n   *    this reason `NgOnChanges` will be deprecated and removed in future version and this\n   *    API will be simplified to be consistent with `output`.\n   */\n  inputs?: {[P in keyof T]?: string | [string, string]};\n\n  /**\n   * A map of output names.\n   *\n   * The format is in: `{[actualPropertyName: string]:string}`.\n   *\n   * Which the minifier may translate to: `{[minifiedPropertyName: string]:string}`.\n   *\n   * This allows the render to re-construct the minified and non-minified names\n   * of properties.\n   */\n  outputs?: {[P in keyof T]?: string};\n\n  /**\n   * A list of optional features to apply.\n   *\n   * See: {@link NgOnChangesFeature}, {@link ProvidersFeature}, {@link InheritDefinitionFeature}\n   */\n  features?: DirectiveDefFeature[];\n\n  /**\n   * Function executed by the parent template to allow child directive to apply host bindings.\n   */\n  hostBindings?: HostBindingsFunction<T>;\n\n  /**\n   * The number of bindings in this directive `hostBindings` (including pure fn bindings).\n   *\n   * Used to calculate the length of the component's LView array, so we\n   * can pre-fill the array and set the host binding start index.\n   */\n  hostVars?: number;\n\n  /**\n   * Assign static attribute values to a host element.\n   *\n   * This property will assign static attribute values as well as class and style\n   * values to a host element. Since attribute values can consist of different types of values, the\n   * `hostAttrs` array must include the values in the following format:\n   *\n   * attrs = [\n   *   // static attributes (like `title`, `name`, `id`...)\n   *   attr1, value1, attr2, value,\n   *\n   *   // a single namespace value (like `x:id`)\n   *   NAMESPACE_MARKER, namespaceUri1, name1, value1,\n   *\n   *   // another single namespace value (like `x:name`)\n   *   NAMESPACE_MARKER, namespaceUri2, name2, value2,\n   *\n   *   // a series of CSS classes that will be applied to the element (no spaces)\n   *   CLASSES_MARKER, class1, class2, class3,\n   *\n   *   // a series of CSS styles (property + value) that will be applied to the element\n   *   STYLES_MARKER, prop1, value1, prop2, value2\n   * ]\n   *\n   * All non-class and non-style attributes must be defined at the start of the list\n   * first before all class and style values are set. When there is a change in value\n   * type (like when classes and styles are introduced) a marker must be used to separate\n   * the entries. The marker values themselves are set via entries found in the\n   * [AttributeMarker] enum.\n   */\n  hostAttrs?: TAttributes;\n\n  /**\n   * Function to create instances of content queries associated with a given directive.\n   */\n  contentQueries?: ContentQueriesFunction<T>;\n\n  /**\n   * Additional set of instructions specific to view query processing. This could be seen as a\n   * set of instructions to be inserted into the template function.\n   */\n  viewQuery?: ViewQueriesFunction<T>| null;\n\n  /**\n   * Defines the name that can be used in the template to assign this directive to a variable.\n   *\n   * See: {@link Directive.exportAs}\n   */\n  exportAs?: string[];\n}) => never;\n\n/**\n * Create a pipe definition object.\n *\n * # Example\n * ```\n * class MyPipe implements PipeTransform {\n *   // Generated by Angular Template Compiler\n *   static Éµpipe = definePipe({\n *     ...\n *   });\n * }\n * ```\n * @param pipeDef Pipe definition generated by the compiler\n *\n * @codeGenApi\n */\nexport function ÉµÉµdefinePipe<T>(pipeDef: {\n  /** Name of the pipe. Used for matching pipes in template to pipe defs. */\n  name: string,\n\n  /** Pipe class reference. Needed to extract pipe lifecycle hooks. */\n  type: Type<T>,\n\n  /** Whether the pipe is pure. */\n  pure?: boolean\n}): never {\n  return (<PipeDef<T>>{\n    type: pipeDef.type,\n    name: pipeDef.name,\n    factory: null,\n    pure: pipeDef.pure !== false,\n    onDestroy: pipeDef.type.prototype.ngOnDestroy || null\n  }) as never;\n}\n\n/**\n * The following getter methods retrieve the definition form the type. Currently the retrieval\n * honors inheritance, but in the future we may change the rule to require that definitions are\n * explicit. This would require some sort of migration strategy.\n */\n\nexport function getComponentDef<T>(type: any): ComponentDef<T>|null {\n  return type[NG_COMP_DEF] || null;\n}\n\nexport function getDirectiveDef<T>(type: any): DirectiveDef<T>|null {\n  return type[NG_DIR_DEF] || null;\n}\n\nexport function getPipeDef<T>(type: any): PipeDef<T>|null {\n  return type[NG_PIPE_DEF] || null;\n}\n\nexport function getFactoryDef<T>(type: any, throwNotFound: true): FactoryFn<T>;\nexport function getFactoryDef<T>(type: any): FactoryFn<T>|null;\nexport function getFactoryDef<T>(type: any, throwNotFound?: boolean): FactoryFn<T>|null {\n  const hasFactoryDef = type.hasOwnProperty(NG_FACTORY_DEF);\n  if (!hasFactoryDef && throwNotFound === true && ngDevMode) {\n    throw new Error(`Type ${stringify(type)} does not have 'Éµfac' property.`);\n  }\n  return hasFactoryDef ? type[NG_FACTORY_DEF] : null;\n}\n\nexport function getNgModuleDef<T>(type: any, throwNotFound: true): NgModuleDef<T>;\nexport function getNgModuleDef<T>(type: any): NgModuleDef<T>|null;\nexport function getNgModuleDef<T>(type: any, throwNotFound?: boolean): NgModuleDef<T>|null {\n  const ngModuleDef = type[NG_MOD_DEF] || null;\n  if (!ngModuleDef && throwNotFound === true) {\n    throw new Error(`Type ${stringify(type)} does not have 'Éµmod' property.`);\n  }\n  return ngModuleDef;\n}\n\nexport function getNgLocaleIdDef(type: any): string|null {\n  return (type as any)[NG_LOC_ID_DEF] || null;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {InjectionToken} from '../../di/injection_token';\nimport {Injector} from '../../di/injector';\nimport {Type} from '../../interface/type';\nimport {SchemaMetadata} from '../../metadata';\nimport {Sanitizer} from '../../sanitization/sanitizer';\n\nimport {LContainer} from './container';\nimport {ComponentDef, ComponentTemplate, DirectiveDef, DirectiveDefList, HostBindingsFunction, PipeDef, PipeDefList, ViewQueriesFunction} from './definition';\nimport {I18nUpdateOpCodes, TI18n} from './i18n';\nimport {TConstants, TElementNode, TNode, TViewNode} from './node';\nimport {PlayerHandler} from './player';\nimport {LQueries, TQueries} from './query';\nimport {RElement, Renderer3, RendererFactory3} from './renderer';\nimport {TStylingKey, TStylingRange} from './styling';\n\n\n\n// Below are constants for LView indices to help us look up LView members\n// without having to remember the specific indices.\n// Uglify will inline these when minifying so there shouldn't be a cost.\nexport const HOST = 0;\nexport const TVIEW = 1;\nexport const FLAGS = 2;\nexport const PARENT = 3;\nexport const NEXT = 4;\nexport const QUERIES = 5;\nexport const T_HOST = 6;\nexport const CLEANUP = 7;\nexport const CONTEXT = 8;\nexport const INJECTOR = 9;\nexport const RENDERER_FACTORY = 10;\nexport const RENDERER = 11;\nexport const SANITIZER = 12;\nexport const CHILD_HEAD = 13;\nexport const CHILD_TAIL = 14;\nexport const DECLARATION_VIEW = 15;\nexport const DECLARATION_COMPONENT_VIEW = 16;\nexport const DECLARATION_LCONTAINER = 17;\nexport const PREORDER_HOOK_FLAGS = 18;\n/** Size of LView's header. Necessary to adjust for it when setting slots.  */\nexport const HEADER_OFFSET = 19;\n\n\n// This interface replaces the real LView interface if it is an arg or a\n// return value of a public instruction. This ensures we don't need to expose\n// the actual interface, which should be kept private.\nexport interface OpaqueViewState {\n  '__brand__': 'Brand for OpaqueViewState that nothing will match';\n}\n\n\n/**\n * `LView` stores all of the information needed to process the instructions as\n * they are invoked from the template. Each embedded view and component view has its\n * own `LView`. When processing a particular view, we set the `viewData` to that\n * `LView`. When that view is done processing, the `viewData` is set back to\n * whatever the original `viewData` was before (the parent `LView`).\n *\n * Keeping separate state for each view facilities view insertion / deletion, so we\n * don't have to edit the data array based on which views are present.\n */\nexport interface LView extends Array<any> {\n  /**\n   * The host node for this LView instance, if this is a component view.\n   * If this is an embedded view, HOST will be null.\n   */\n  [HOST]: RElement|null;\n\n  /**\n   * The static data for this view. We need a reference to this so we can easily walk up the\n   * node tree in DI and get the TView.data array associated with a node (where the\n   * directive defs are stored).\n   */\n  readonly[TVIEW]: TView;\n\n  /** Flags for this view. See LViewFlags for more info. */\n  [FLAGS]: LViewFlags;\n\n  /**\n   * This may store an {@link LView} or {@link LContainer}.\n   *\n   * `LView` - The parent view. This is needed when we exit the view and must restore the previous\n   * LView. Without this, the render method would have to keep a stack of\n   * views as it is recursively rendering templates.\n   *\n   * `LContainer` - The current view is part of a container, and is an embedded view.\n   */\n  [PARENT]: LView|LContainer|null;\n\n  /**\n   *\n   * The next sibling LView or LContainer.\n   *\n   * Allows us to propagate between sibling view states that aren't in the same\n   * container. Embedded views already have a node.next, but it is only set for\n   * views in the same container. We need a way to link component views and views\n   * across containers as well.\n   */\n  [NEXT]: LView|LContainer|null;\n\n  /** Queries active for this view - nodes from a view are reported to those queries. */\n  [QUERIES]: LQueries|null;\n\n  /**\n   * Pointer to the `TViewNode` or `TElementNode` which represents the root of the view.\n   *\n   * If `TViewNode`, this is an embedded view of a container. We need this to be able to\n   * efficiently find the `LViewNode` when inserting the view into an anchor.\n   *\n   * If `TElementNode`, this is the LView of a component.\n   *\n   * If null, this is the root view of an application (root component is in this view).\n   */\n  [T_HOST]: TViewNode|TElementNode|null;\n\n  /**\n   * When a view is destroyed, listeners need to be released and outputs need to be\n   * unsubscribed. This context array stores both listener functions wrapped with\n   * their context and output subscription instances for a particular view.\n   *\n   * These change per LView instance, so they cannot be stored on TView. Instead,\n   * TView.cleanup saves an index to the necessary context in this array.\n   */\n  // TODO: flatten into LView[]\n  [CLEANUP]: any[]|null;\n\n  /**\n   * - For dynamic views, this is the context with which to render the template (e.g.\n   *   `NgForContext`), or `{}` if not defined explicitly.\n   * - For root view of the root component the context contains change detection data.\n   * - For non-root components, the context is the component instance,\n   * - For inline views, the context is null.\n   */\n  [CONTEXT]: {}|RootContext|null;\n\n  /** An optional Module Injector to be used as fall back after Element Injectors are consulted. */\n  readonly[INJECTOR]: Injector|null;\n\n  /** Factory to be used for creating Renderer. */\n  [RENDERER_FACTORY]: RendererFactory3;\n\n  /** Renderer to be used for this view. */\n  [RENDERER]: Renderer3;\n\n  /** An optional custom sanitizer. */\n  [SANITIZER]: Sanitizer|null;\n\n  /**\n   * Reference to the first LView or LContainer beneath this LView in\n   * the hierarchy.\n   *\n   * Necessary to store this so views can traverse through their nested views\n   * to remove listeners and call onDestroy callbacks.\n   */\n  [CHILD_HEAD]: LView|LContainer|null;\n\n  /**\n   * The last LView or LContainer beneath this LView in the hierarchy.\n   *\n   * The tail allows us to quickly add a new state to the end of the view list\n   * without having to propagate starting from the first child.\n   */\n  [CHILD_TAIL]: LView|LContainer|null;\n\n  /**\n   * View where this view's template was declared.\n   *\n   * Only applicable for dynamically created views. Will be null for inline/component views.\n   *\n   * The template for a dynamically created view may be declared in a different view than\n   * it is inserted. We already track the \"insertion view\" (view where the template was\n   * inserted) in LView[PARENT], but we also need access to the \"declaration view\"\n   * (view where the template was declared). Otherwise, we wouldn't be able to call the\n   * view's template function with the proper contexts. Context should be inherited from\n   * the declaration view tree, not the insertion view tree.\n   *\n   * Example (AppComponent template):\n   *\n   * <ng-template #foo></ng-template>       <-- declared here -->\n   * <some-comp [tpl]=\"foo\"></some-comp>    <-- inserted inside this component -->\n   *\n   * The <ng-template> above is declared in the AppComponent template, but it will be passed into\n   * SomeComp and inserted there. In this case, the declaration view would be the AppComponent,\n   * but the insertion view would be SomeComp. When we are removing views, we would want to\n   * traverse through the insertion view to clean up listeners. When we are calling the\n   * template function during change detection, we need the declaration view to get inherited\n   * context.\n   */\n  [DECLARATION_VIEW]: LView|null;\n\n\n  /**\n   * Points to the declaration component view, used to track transplanted `LView`s.\n   *\n   * See: `DECLARATION_VIEW` which points to the actual `LView` where it was declared, whereas\n   * `DECLARATION_COMPONENT_VIEW` points to the component which may not be same as\n   * `DECLARATION_VIEW`.\n   *\n   * Example:\n   * ```\n   * <#VIEW #myComp>\n   *  <div *ngIf=\"true\">\n   *   <ng-template #myTmpl>...</ng-template>\n   *  </div>\n   * </#VIEW>\n   * ```\n   * In the above case `DECLARATION_VIEW` for `myTmpl` points to the `LView` of `ngIf` whereas\n   * `DECLARATION_COMPONENT_VIEW` points to `LView` of the `myComp` which owns the template.\n   *\n   * The reason for this is that all embedded views are always check-always whereas the component\n   * view can be check-always or on-push. When we have a transplanted view it is important to\n   * determine if we have transplanted a view from check-always declaration to on-push insertion\n   * point. In such a case the transplanted view needs to be added to the `LContainer` in the\n   * declared `LView` and CD during the declared view CD (in addition to the CD at the insertion\n   * point.) (Any transplanted views which are intra Component are of no interest because the CD\n   * strategy of declaration and insertion will always be the same, because it is the same\n   * component.)\n   *\n   * Queries already track moved views in `LView[DECLARATION_LCONTAINER]` and\n   * `LContainer[MOVED_VIEWS]`. However the queries also track `LView`s which moved within the same\n   * component `LView`. Transplanted views are a subset of moved views, and we use\n   * `DECLARATION_COMPONENT_VIEW` to differentiate them. As in this example.\n   *\n   * Example showing intra component `LView` movement.\n   * ```\n   * <#VIEW #myComp>\n   *   <div *ngIf=\"condition; then thenBlock else elseBlock\"></div>\n   *   <ng-template #thenBlock>Content to render when condition is true.</ng-template>\n   *   <ng-template #elseBlock>Content to render when condition is false.</ng-template>\n   * </#VIEW>\n   * ```\n   * The `thenBlock` and `elseBlock` is moved but not transplanted.\n   *\n   * Example showing inter component `LView` movement (transplanted view).\n   * ```\n   * <#VIEW #myComp>\n   *   <ng-template #myTmpl>...</ng-template>\n   *   <insertion-component [template]=\"myTmpl\"></insertion-component>\n   * </#VIEW>\n   * ```\n   * In the above example `myTmpl` is passed into a different component. If `insertion-component`\n   * instantiates `myTmpl` and `insertion-component` is on-push then the `LContainer` needs to be\n   * marked as containing transplanted views and those views need to be CD as part of the\n   * declaration CD.\n   *\n   *\n   * When change detection runs, it iterates over `[MOVED_VIEWS]` and CDs any child `LView`s where\n   * the `DECLARATION_COMPONENT_VIEW` of the current component and the child `LView` does not match\n   * (it has been transplanted across components.)\n   *\n   * Note: `[DECLARATION_COMPONENT_VIEW]` points to itself if the LView is a component view (the\n   *       simplest / most common case).\n   *\n   * see also:\n   *   - https://hackmd.io/@mhevery/rJUJsvv9H write up of the problem\n   *   - `LContainer[ACTIVE_INDEX]` for flag which marks which `LContainer` has transplanted views.\n   *   - `LContainer[TRANSPLANT_HEAD]` and `LContainer[TRANSPLANT_TAIL]` storage for transplanted\n   *   - `LView[DECLARATION_LCONTAINER]` similar problem for queries\n   *   - `LContainer[MOVED_VIEWS]` similar problem for queries\n   */\n  [DECLARATION_COMPONENT_VIEW]: LView;\n\n  /**\n   * A declaration point of embedded views (ones instantiated based on the content of a\n   * <ng-template>), null for other types of views.\n   *\n   * We need to track all embedded views created from a given declaration point so we can prepare\n   * query matches in a proper order (query matches are ordered based on their declaration point and\n   * _not_ the insertion point).\n   */\n  [DECLARATION_LCONTAINER]: LContainer|null;\n\n  /**\n   * More flags for this view. See PreOrderHookFlags for more info.\n   */\n  [PREORDER_HOOK_FLAGS]: PreOrderHookFlags;\n}\n\n/** Flags associated with an LView (saved in LView[FLAGS]) */\nexport const enum LViewFlags {\n  /** The state of the init phase on the first 2 bits */\n  InitPhaseStateIncrementer = 0b00000000001,\n  InitPhaseStateMask = 0b00000000011,\n\n  /**\n   * Whether or not the view is in creationMode.\n   *\n   * This must be stored in the view rather than using `data` as a marker so that\n   * we can properly support embedded views. Otherwise, when exiting a child view\n   * back into the parent view, `data` will be defined and `creationMode` will be\n   * improperly reported as false.\n   */\n  CreationMode = 0b00000000100,\n\n  /**\n   * Whether or not this LView instance is on its first processing pass.\n   *\n   * An LView instance is considered to be on its \"first pass\" until it\n   * has completed one creation mode run and one update mode run. At this\n   * time, the flag is turned off.\n   */\n  FirstLViewPass = 0b00000001000,\n\n  /** Whether this view has default change detection strategy (checks always) or onPush */\n  CheckAlways = 0b00000010000,\n\n  /**\n   * Whether or not manual change detection is turned on for onPush components.\n   *\n   * This is a special mode that only marks components dirty in two cases:\n   * 1) There has been a change to an @Input property\n   * 2) `markDirty()` has been called manually by the user\n   *\n   * Note that in this mode, the firing of events does NOT mark components\n   * dirty automatically.\n   *\n   * Manual mode is turned off by default for backwards compatibility, as events\n   * automatically mark OnPush components dirty in View Engine.\n   *\n   * TODO: Add a public API to ChangeDetectionStrategy to turn this mode on\n   */\n  ManualOnPush = 0b00000100000,\n\n  /** Whether or not this view is currently dirty (needing check) */\n  Dirty = 0b000001000000,\n\n  /** Whether or not this view is currently attached to change detection tree. */\n  Attached = 0b000010000000,\n\n  /** Whether or not this view is destroyed. */\n  Destroyed = 0b000100000000,\n\n  /** Whether or not this view is the root view */\n  IsRoot = 0b001000000000,\n\n  /**\n   * Index of the current init phase on last 22 bits\n   */\n  IndexWithinInitPhaseIncrementer = 0b010000000000,\n  IndexWithinInitPhaseShift = 10,\n  IndexWithinInitPhaseReset = 0b001111111111,\n}\n\n/**\n * Possible states of the init phase:\n * - 00: OnInit hooks to be run.\n * - 01: AfterContentInit hooks to be run\n * - 10: AfterViewInit hooks to be run\n * - 11: All init hooks have been run\n */\nexport const enum InitPhaseState {\n  OnInitHooksToBeRun = 0b00,\n  AfterContentInitHooksToBeRun = 0b01,\n  AfterViewInitHooksToBeRun = 0b10,\n  InitPhaseCompleted = 0b11,\n}\n\n/** More flags associated with an LView (saved in LView[PREORDER_HOOK_FLAGS]) */\nexport const enum PreOrderHookFlags {\n  /** The index of the next pre-order hook to be called in the hooks array, on the first 16\n     bits */\n  IndexOfTheNextPreOrderHookMaskMask = 0b01111111111111111,\n\n  /**\n   * The number of init hooks that have already been called, on the last 16 bits\n   */\n  NumberOfInitHooksCalledIncrementer = 0b010000000000000000,\n  NumberOfInitHooksCalledShift = 16,\n  NumberOfInitHooksCalledMask = 0b11111111111111110000000000000000,\n}\n\n/**\n * Set of instructions used to process host bindings efficiently.\n *\n * See VIEW_DATA.md for more information.\n */\nexport interface ExpandoInstructions extends Array<number|HostBindingsFunction<any>|null> {}\n\n/**\n * Explicitly marks `TView` as a specific type in `ngDevMode`\n *\n * It is useful to know conceptually what time of `TView` we are dealing with when\n * debugging an application (even if the runtime does not need it.) For this reason\n * we store this information in the `ngDevMode` `TView` and than use it for\n * better debugging experience.\n */\nexport const enum TViewType {\n  /**\n   * Root `TView` is the used to bootstrap components into. It is used in conjunction with\n   * `LView` which takes an existing DOM node not owned by Angular and wraps it in `TView`/`LView`\n   * so that other components can be loaded into it.\n   */\n  Root = 0,\n\n  /**\n   * `TView` associated with a Component. This would be the `TView` directly associated with the\n   * component view (as opposed an `Embedded` `TView` which would be a child of `Component` `TView`)\n   */\n  Component = 1,\n\n  /**\n   * `TView` associated with a template. Such as `*ngIf`, `<ng-template>` etc... A `Component`\n   * can have zero or more `Embedede` `TView`s.\n   */\n  Embedded = 2,\n}\n\n/**\n * The static data for an LView (shared between all templates of a\n * given type).\n *\n * Stored on the `ComponentDef.tView`.\n */\nexport interface TView {\n  /**\n   * Type of `TView` (`Root`|`Component`|`Embedded`).\n   */\n  type: TViewType;\n\n  /**\n   * ID for inline views to determine whether a view is the same as the previous view\n   * in a certain position. If it's not, we know the new view needs to be inserted\n   * and the one that exists needs to be removed (e.g. if/else statements)\n   *\n   * If this is -1, then this is a component view or a dynamically created view.\n   */\n  readonly id: number;\n\n  /**\n   * This is a blueprint used to generate LView instances for this TView. Copying this\n   * blueprint is faster than creating a new LView from scratch.\n   */\n  blueprint: LView;\n\n  /**\n   * The template function used to refresh the view of dynamically created views\n   * and components. Will be null for inline views.\n   */\n  template: ComponentTemplate<{}>|null;\n\n  /**\n   * A function containing query-related instructions.\n   */\n  viewQuery: ViewQueriesFunction<{}>|null;\n\n  /**\n   * Pointer to the host `TNode` (not part of this TView).\n   *\n   * If this is a `TViewNode` for an `LViewNode`, this is an embedded view of a container.\n   * We need this pointer to be able to efficiently find this node when inserting the view\n   * into an anchor.\n   *\n   * If this is a `TElementNode`, this is the view of a root component. It has exactly one\n   * root TNode.\n   *\n   * If this is null, this is the view of a component that is not at root. We do not store\n   * the host TNodes for child component views because they can potentially have several\n   * different host TNodes, depending on where the component is being used. These host\n   * TNodes cannot be shared (due to different indices, etc).\n   */\n  node: TViewNode|TElementNode|null;\n\n  /** Whether or not this template has been processed in creation mode. */\n  firstCreatePass: boolean;\n\n  /**\n   *  Whether or not this template has been processed in update mode (e.g. change detected)\n   *\n   * `firstUpdatePass` is used by styling to set up `TData` to contain metadata about the styling\n   * instructions. (Mainly to build up a linked list of styling priority order.)\n   *\n   * Typically this function gets cleared after first execution. If exception is thrown then this\n   * flag can remain turned un until there is first successful (no exception) pass. This means that\n   * individual styling instructions keep track of if they have already been added to the linked\n   * list to prevent double adding.\n   */\n  firstUpdatePass: boolean;\n\n  /** Static data equivalent of LView.data[]. Contains TNodes, PipeDefInternal or TI18n. */\n  data: TData;\n\n  /**\n   * The binding start index is the index at which the data array\n   * starts to store bindings only. Saving this value ensures that we\n   * will begin reading bindings at the correct point in the array when\n   * we are in update mode.\n   *\n   * -1 means that it has not been initialized.\n   */\n  bindingStartIndex: number;\n\n  /**\n   * The index where the \"expando\" section of `LView` begins. The expando\n   * section contains injectors, directive instances, and host binding values.\n   * Unlike the \"decls\" and \"vars\" sections of `LView`, the length of this\n   * section cannot be calculated at compile-time because directives are matched\n   * at runtime to preserve locality.\n   *\n   * We store this start index so we know where to start checking host bindings\n   * in `setHostBindings`.\n   */\n  expandoStartIndex: number;\n\n  /**\n   * Whether or not there are any static view queries tracked on this view.\n   *\n   * We store this so we know whether or not we should do a view query\n   * refresh after creation mode to collect static query results.\n   */\n  staticViewQueries: boolean;\n\n  /**\n   * Whether or not there are any static content queries tracked on this view.\n   *\n   * We store this so we know whether or not we should do a content query\n   * refresh after creation mode to collect static query results.\n   */\n  staticContentQueries: boolean;\n\n  /**\n   * A reference to the first child node located in the view.\n   */\n  firstChild: TNode|null;\n\n  /**\n   * Set of instructions used to process host bindings efficiently.\n   *\n   * See VIEW_DATA.md for more information.\n   */\n  // TODO(misko): `expandoInstructions` should be renamed to `hostBindingsInstructions` since they\n  // keep track of `hostBindings` which need to be executed.\n  expandoInstructions: ExpandoInstructions|null;\n\n  /**\n   * Full registry of directives and components that may be found in this view.\n   *\n   * It's necessary to keep a copy of the full def list on the TView so it's possible\n   * to render template functions without a host component.\n   */\n  directiveRegistry: DirectiveDefList|null;\n\n  /**\n   * Full registry of pipes that may be found in this view.\n   *\n   * The property is either an array of `PipeDefs`s or a function which returns the array of\n   * `PipeDefs`s. The function is necessary to be able to support forward declarations.\n   *\n   * It's necessary to keep a copy of the full def list on the TView so it's possible\n   * to render template functions without a host component.\n   */\n  pipeRegistry: PipeDefList|null;\n\n  /**\n   * Array of ngOnInit, ngOnChanges and ngDoCheck hooks that should be executed for this view in\n   * creation mode.\n   *\n   * Even indices: Directive index\n   * Odd indices: Hook function\n   */\n  preOrderHooks: HookData|null;\n\n  /**\n   * Array of ngOnChanges and ngDoCheck hooks that should be executed for this view in update mode.\n   *\n   * Even indices: Directive index\n   * Odd indices: Hook function\n   */\n  preOrderCheckHooks: HookData|null;\n\n  /**\n   * Array of ngAfterContentInit and ngAfterContentChecked hooks that should be executed\n   * for this view in creation mode.\n   *\n   * Even indices: Directive index\n   * Odd indices: Hook function\n   */\n  contentHooks: HookData|null;\n\n  /**\n   * Array of ngAfterContentChecked hooks that should be executed for this view in update\n   * mode.\n   *\n   * Even indices: Directive index\n   * Odd indices: Hook function\n   */\n  contentCheckHooks: HookData|null;\n\n  /**\n   * Array of ngAfterViewInit and ngAfterViewChecked hooks that should be executed for\n   * this view in creation mode.\n   *\n   * Even indices: Directive index\n   * Odd indices: Hook function\n   */\n  viewHooks: HookData|null;\n\n  /**\n   * Array of ngAfterViewChecked hooks that should be executed for this view in\n   * update mode.\n   *\n   * Even indices: Directive index\n   * Odd indices: Hook function\n   */\n  viewCheckHooks: HookData|null;\n\n  /**\n   * Array of ngOnDestroy hooks that should be executed when this view is destroyed.\n   *\n   * Even indices: Directive index\n   * Odd indices: Hook function\n   */\n  destroyHooks: HookData|null;\n\n  /**\n   * When a view is destroyed, listeners need to be released and outputs need to be\n   * unsubscribed. This cleanup array stores both listener data (in chunks of 4)\n   * and output data (in chunks of 2) for a particular view. Combining the arrays\n   * saves on memory (70 bytes per array) and on a few bytes of code size (for two\n   * separate for loops).\n   *\n   * If it's a native DOM listener or output subscription being stored:\n   * 1st index is: event name  `name = tView.cleanup[i+0]`\n   * 2nd index is: index of native element or a function that retrieves global target (window,\n   *               document or body) reference based on the native element:\n   *    `typeof idxOrTargetGetter === 'function'`: global target getter function\n   *    `typeof idxOrTargetGetter === 'number'`: index of native element\n   *\n   * 3rd index is: index of listener function `listener = lView[CLEANUP][tView.cleanup[i+2]]`\n   * 4th index is: `useCaptureOrIndx = tView.cleanup[i+3]`\n   *    `typeof useCaptureOrIndx == 'boolean' : useCapture boolean\n   *    `typeof useCaptureOrIndx == 'number':\n   *         `useCaptureOrIndx >= 0` `removeListener = LView[CLEANUP][useCaptureOrIndx]`\n   *         `useCaptureOrIndx <  0` `subscription = LView[CLEANUP][-useCaptureOrIndx]`\n   *\n   * If it's an output subscription or query list destroy hook:\n   * 1st index is: output unsubscribe function / query list destroy function\n   * 2nd index is: index of function context in LView.cleanupInstances[]\n   *               `tView.cleanup[i+0].call(lView[CLEANUP][tView.cleanup[i+1]])`\n   */\n  cleanup: any[]|null;\n\n  /**\n   * A list of element indices for child components that will need to be\n   * refreshed when the current view has finished its check. These indices have\n   * already been adjusted for the HEADER_OFFSET.\n   *\n   */\n  components: number[]|null;\n\n  /**\n   * A collection of queries tracked in a given view.\n   */\n  queries: TQueries|null;\n\n  /**\n   * An array of indices pointing to directives with content queries alongside with the\n   * corresponding\n   * query index. Each entry in this array is a tuple of:\n   * - index of the first content query index declared by a given directive;\n   * - index of a directive.\n   *\n   * We are storing those indexes so we can refresh content queries as part of a view refresh\n   * process.\n   */\n  contentQueries: number[]|null;\n\n  /**\n   * Set of schemas that declare elements to be allowed inside the view.\n   */\n  schemas: SchemaMetadata[]|null;\n\n  /**\n   * Array of constants for the view. Includes attribute arrays, local definition arrays etc.\n   * Used for directive matching, attribute bindings, local definitions and more.\n   */\n  consts: TConstants|null;\n}\n\nexport const enum RootContextFlags {Empty = 0b00, DetectChanges = 0b01, FlushPlayers = 0b10}\n\n\n/**\n * RootContext contains information which is shared for all components which\n * were bootstrapped with {@link renderComponent}.\n */\nexport interface RootContext {\n  /**\n   * A function used for scheduling change detection in the future. Usually\n   * this is `requestAnimationFrame`.\n   */\n  scheduler: (workFn: () => void) => void;\n\n  /**\n   * A promise which is resolved when all components are considered clean (not dirty).\n   *\n   * This promise is overwritten every time a first call to {@link markDirty} is invoked.\n   */\n  clean: Promise<null>;\n\n  /**\n   * RootComponents - The components that were instantiated by the call to\n   * {@link renderComponent}.\n   */\n  components: {}[];\n\n  /**\n   * The player flushing handler to kick off all animations\n   */\n  playerHandler: PlayerHandler|null;\n\n  /**\n   * What render-related operations to run once a scheduler has been set\n   */\n  flags: RootContextFlags;\n}\n\n/**\n * Array of hooks that should be executed for a view and their directive indices.\n *\n * For each node of the view, the following data is stored:\n * 1) Node index (optional)\n * 2) A series of number/function pairs where:\n *  - even indices are directive indices\n *  - odd indices are hook functions\n *\n * Special cases:\n *  - a negative directive index flags an init hook (ngOnInit, ngAfterContentInit, ngAfterViewInit)\n */\nexport type HookData = (number | (() => void))[];\n\n/**\n * Static data that corresponds to the instance-specific data array on an LView.\n *\n * Each node's static data is stored in tData at the same index that it's stored\n * in the data array.  Any nodes that do not have static data store a null value in\n * tData to avoid a sparse array.\n *\n * Each pipe's definition is stored here at the same index as its pipe instance in\n * the data array.\n *\n * Each host property's name is stored here at the same index as its value in the\n * data array.\n *\n * Each property binding name is stored here at the same index as its value in\n * the data array. If the binding is an interpolation, the static string values\n * are stored parallel to the dynamic values. Example:\n *\n * id=\"prefix {{ v0 }} a {{ v1 }} b {{ v2 }} suffix\"\n *\n * LView       |   TView.data\n *------------------------\n *  v0 value   |   'a'\n *  v1 value   |   'b'\n *  v2 value   |   id ï¿½ prefix ï¿½ suffix\n *\n * Injector bloom filters are also stored here.\n */\nexport type TData =\n    (TNode | PipeDef<any>| DirectiveDef<any>| ComponentDef<any>| number | TStylingRange |\n     TStylingKey | Type<any>| InjectionToken<any>| TI18n | I18nUpdateOpCodes | null | string)[];\n\n// Note: This hack is necessary so we don't erroneously get a circular dependency\n// failure based on types.\nexport const unusedValueExportToPlacateAjd = 1;\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ViewRef} from '../../linker/view_ref';\n\nimport {TNode} from './node';\nimport {RComment, RElement} from './renderer';\n\nimport {HOST, LView, NEXT, PARENT, T_HOST} from './view';\n\n\n/**\n * Special location which allows easy identification of type. If we have an array which was\n * retrieved from the `LView` and that array has `true` at `TYPE` location, we know it is\n * `LContainer`.\n */\nexport const TYPE = 1;\n/**\n * Below are constants for LContainer indices to help us look up LContainer members\n * without having to remember the specific indices.\n * Uglify will inline these when minifying so there shouldn't be a cost.\n */\nexport const ACTIVE_INDEX = 2;\n\n// PARENT and NEXT are indices 3 and 4\n// As we already have these constants in LView, we don't need to re-create them.\n\nexport const MOVED_VIEWS = 5;\n\n// T_HOST is index 6\n// We already have this constants in LView, we don't need to re-create it.\n\nexport const NATIVE = 7;\nexport const VIEW_REFS = 8;\n\n/**\n * Size of LContainer's header. Represents the index after which all views in the\n * container will be inserted. We need to keep a record of current views so we know\n * which views are already in the DOM (and don't need to be re-added) and so we can\n * remove views from the DOM when they are no longer required.\n */\nexport const CONTAINER_HEADER_OFFSET = 9;\n\n\n/**\n * Used to track:\n *  - Inline embedded views (see: `ÉµÉµembeddedViewStart`)\n *  - Transplanted `LView`s (see: `LView[DECLARATION_COMPONENT_VIEW])`\n */\nexport const enum ActiveIndexFlag {\n  /**\n   * Flag which signifies that the `LContainer` does not have any inline embedded views.\n   */\n  DYNAMIC_EMBEDDED_VIEWS_ONLY = -1,\n\n  /**\n   * Flag to signify that this `LContainer` may have transplanted views which need to be change\n   * detected. (see: `LView[DECLARATION_COMPONENT_VIEW])`.\n   *\n   * This flag once set is never unset for the `LContainer`. This means that when unset we can skip\n   * a lot of work in `refreshDynamicEmbeddedViews`. But when set we still need to verify\n   * that the `MOVED_VIEWS` are transplanted and on-push.\n   */\n  HAS_TRANSPLANTED_VIEWS = 1,\n\n  /**\n   * Number of bits to shift inline embedded views counter to make space for other flags.\n   */\n  SHIFT = 1,\n\n\n  /**\n   * When incrementing the active index for inline embedded views, the amount to increment to leave\n   * space for other flags.\n   */\n  INCREMENT = 1 << SHIFT,\n}\n\n/**\n * The state associated with a container.\n *\n * This is an array so that its structure is closer to LView. This helps\n * when traversing the view tree (which is a mix of containers and component\n * views), so we can jump to viewOrContainer[NEXT] in the same way regardless\n * of type.\n */\nexport interface LContainer extends Array<any> {\n  /**\n   * The host element of this LContainer.\n   *\n   * The host could be an LView if this container is on a component node.\n   * In that case, the component LView is its HOST.\n   */\n  readonly[HOST]: RElement|RComment|LView;\n\n  /**\n   * This is a type field which allows us to differentiate `LContainer` from `StylingContext` in an\n   * efficient way. The value is always set to `true`\n   */\n  [TYPE]: true;\n\n  /**\n   * The next active index in the views array to read or write to. This helps us\n   * keep track of where we are in the views array.\n   * In the case the LContainer is created for a ViewContainerRef,\n   * it is set to null to identify this scenario, as indices are \"absolute\" in that case,\n   * i.e. provided directly by the user of the ViewContainerRef API.\n   *\n   * This is used by `ÉµÉµembeddedViewStart` to track which `LView` is currently active.\n   * Because `ÉµÉµembeddedViewStart` is not generated by the compiler this feature is essentially\n   * unused.\n   *\n   * The lowest bit signals that this `LContainer` has transplanted views which need to be change\n   * detected as part of the declaration CD. (See `LView[DECLARATION_COMPONENT_VIEW]`)\n   */\n  [ACTIVE_INDEX]: ActiveIndexFlag;\n\n  /**\n   * Access to the parent view is necessary so we can propagate back\n   * up from inside a container to parent[NEXT].\n   */\n  [PARENT]: LView;\n\n  /**\n   * This allows us to jump from a container to a sibling container or component\n   * view with the same parent, so we can remove listeners efficiently.\n   */\n  [NEXT]: LView|LContainer|null;\n\n  /**\n   * A collection of views created based on the underlying `<ng-template>` element but inserted into\n   * a different `LContainer`. We need to track views created from a given declaration point since\n   * queries collect matches from the embedded view declaration point and _not_ the insertion point.\n   */\n  [MOVED_VIEWS]: LView[]|null;\n\n  /**\n   * Pointer to the `TNode` which represents the host of the container.\n   */\n  [T_HOST]: TNode;\n\n  /** The comment element that serves as an anchor for this LContainer. */\n  readonly[NATIVE]:\n      RComment;  // TODO(misko): remove as this value can be gotten by unwrapping `[HOST]`\n\n  /**\n   * Array of `ViewRef`s used by any `ViewContainerRef`s that point to this container.\n   *\n   * This is lazily initialized by `ViewContainerRef` when the first view is inserted.\n   */\n  [VIEW_REFS]: ViewRef[]|null;\n}\n\n// Note: This hack is necessary so we don't erroneously get a circular dependency\n// failure based on types.\nexport const unusedValueExportToPlacateAjd = 1;\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ComponentDef, DirectiveDef} from '..';\n\nimport {LContainer, TYPE} from './container';\nimport {TNode, TNodeFlags} from './node';\nimport {RNode} from './renderer';\nimport {FLAGS, LView, LViewFlags} from './view';\n\n\n/**\n* True if `value` is `LView`.\n* @param value wrapped value of `RNode`, `LView`, `LContainer`\n*/\nexport function isLView(value: RNode | LView | LContainer | {} | null): value is LView {\n  return Array.isArray(value) && typeof value[TYPE] === 'object';\n}\n\n/**\n * True if `value` is `LContainer`.\n * @param value wrapped value of `RNode`, `LView`, `LContainer`\n */\nexport function isLContainer(value: RNode | LView | LContainer | {} | null): value is LContainer {\n  return Array.isArray(value) && value[TYPE] === true;\n}\n\nexport function isContentQueryHost(tNode: TNode): boolean {\n  return (tNode.flags & TNodeFlags.hasContentQuery) !== 0;\n}\n\nexport function isComponentHost(tNode: TNode): boolean {\n  return (tNode.flags & TNodeFlags.isComponentHost) === TNodeFlags.isComponentHost;\n}\n\nexport function isDirectiveHost(tNode: TNode): boolean {\n  return (tNode.flags & TNodeFlags.isDirectiveHost) === TNodeFlags.isDirectiveHost;\n}\n\nexport function isComponentDef<T>(def: DirectiveDef<T>): def is ComponentDef<T> {\n  return (def as ComponentDef<T>).template !== null;\n}\n\nexport function isRootView(target: LView): boolean {\n  return (target[FLAGS] & LViewFlags.IsRoot) !== 0;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {assertDefined, assertEqual, throwError} from '../util/assert';\n\nimport {getComponentDef, getNgModuleDef} from './definition';\nimport {TNode} from './interfaces/node';\nimport {isLContainer, isLView} from './interfaces/type_checks';\nimport {LView, TVIEW, TView} from './interfaces/view';\n\nexport function assertTNodeForLView(tNode: TNode, lView: LView) {\n  tNode.hasOwnProperty('tView_') && assertEqual(\n                                        (tNode as any as{tView_: TView}).tView_, lView[TVIEW],\n                                        'This TNode does not belong to this LView.');\n}\n\nexport function assertComponentType(\n    actual: any,\n    msg: string = 'Type passed in is not ComponentType, it does not have \\'Éµcmp\\' property.') {\n  if (!getComponentDef(actual)) {\n    throwError(msg);\n  }\n}\n\nexport function assertNgModuleType(\n    actual: any,\n    msg: string = 'Type passed in is not NgModuleType, it does not have \\'Éµmod\\' property.') {\n  if (!getNgModuleDef(actual)) {\n    throwError(msg);\n  }\n}\n\nexport function assertPreviousIsParent(isParent: boolean) {\n  assertEqual(isParent, true, 'previousOrParentTNode should be a parent');\n}\n\nexport function assertHasParent(tNode: TNode | null) {\n  assertDefined(tNode, 'previousOrParentTNode should exist!');\n  assertDefined(tNode !.parent, 'previousOrParentTNode should have a parent');\n}\n\nexport function assertDataNext(lView: LView, index: number, arr?: any[]) {\n  if (arr == null) arr = lView;\n  assertEqual(\n      arr.length, index, `index ${index} expected to be at the end of arr (length ${arr.length})`);\n}\n\nexport function assertLContainerOrUndefined(value: any): void {\n  value && assertEqual(isLContainer(value), true, 'Expecting LContainer or undefined or null');\n}\n\nexport function assertLContainer(value: any): void {\n  assertDefined(value, 'LContainer must be defined');\n  assertEqual(isLContainer(value), true, 'Expecting LContainer');\n}\n\nexport function assertLViewOrUndefined(value: any): void {\n  value && assertEqual(isLView(value), true, 'Expecting LView or undefined or null');\n}\n\nexport function assertLView(value: any) {\n  assertDefined(value, 'LView must be defined');\n  assertEqual(isLView(value), true, 'Expecting LView');\n}\n\nexport function assertFirstCreatePass(tView: TView, errMessage?: string) {\n  assertEqual(\n      tView.firstCreatePass, true, errMessage || 'Should only be called in first create pass.');\n}\n\nexport function assertFirstUpdatePass(tView: TView, errMessage?: string) {\n  assertEqual(\n      tView.firstUpdatePass, true, errMessage || 'Should only be called in first update pass.');\n}\n\n/**\n * This is a basic sanity check that an object is probably a directive def. DirectiveDef is\n * an interface, so we can't do a direct instanceof check.\n */\nexport function assertDirectiveDef(obj: any) {\n  if (obj.type === undefined || obj.selectors == undefined || obj.inputs === undefined) {\n    throwError(\n        `Expected a DirectiveDef/ComponentDef and this object does not seem to have the expected shape.`);\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {StyleSanitizeFn} from '../sanitization/style_sanitizer';\nimport {assertDefined} from '../util/assert';\nimport {assertLViewOrUndefined} from './assert';\nimport {TNode} from './interfaces/node';\nimport {CONTEXT, DECLARATION_VIEW, LView, OpaqueViewState, TVIEW, TView} from './interfaces/view';\n\n\n/**\n *\n */\ninterface LFrame {\n  /**\n   * Parent LFrame.\n   *\n   * This is needed when `leaveView` is called to restore the previous state.\n   */\n  parent: LFrame;\n\n  /**\n   * Child LFrame.\n   *\n   * This is used to cache existing LFrames to relieve the memory pressure.\n   */\n  child: LFrame|null;\n\n  /**\n   * State of the current view being processed.\n   *\n   * An array of nodes (text, element, container, etc), pipes, their bindings, and\n   * any local variables that need to be stored between invocations.\n   */\n  lView: LView;\n\n  /**\n   * Current `TView` associated with the `LFrame.lView`.\n   *\n   * One can get `TView` from `lFrame[TVIEW]` however because it is so common it makes sense to\n   * store it in `LFrame` for perf reasons.\n   */\n  tView: TView;\n\n  /**\n   * Used to set the parent property when nodes are created and track query results.\n   *\n   * This is used in conjunction with `isParent`.\n   */\n  previousOrParentTNode: TNode;\n\n  /**\n   * If `isParent` is:\n   *  - `true`: then `previousOrParentTNode` points to a parent node.\n   *  - `false`: then `previousOrParentTNode` points to previous node (sibling).\n   */\n  isParent: boolean;\n\n  /**\n   * Index of currently selected element in LView.\n   *\n   * Used by binding instructions. Updated as part of advance instruction.\n   */\n  selectedIndex: number;\n\n  /**\n   * Current pointer to the binding index.\n   */\n  bindingIndex: number;\n\n  /**\n   * The last viewData retrieved by nextContext().\n   * Allows building nextContext() and reference() calls.\n   *\n   * e.g. const inner = x().$implicit; const outer = x().$implicit;\n   */\n  contextLView: LView;\n\n  /**\n   * Store the element depth count. This is used to identify the root elements of the template\n   * so that we can then attach patch data `LView` to only those elements. We know that those\n   * are the only places where the patch data could change, this way we will save on number\n   * of places where tha patching occurs.\n   */\n  elementDepthCount: number;\n\n  /**\n   * Current namespace to be used when creating elements\n   */\n  currentNamespace: string|null;\n\n  /**\n   * Current sanitizer\n   */\n  currentSanitizer: StyleSanitizeFn|null;\n\n\n  /**\n   * The root index from which pure function instructions should calculate their binding\n   * indices. In component views, this is TView.bindingStartIndex. In a host binding\n   * context, this is the TView.expandoStartIndex + any dirs/hostVars before the given dir.\n   */\n  bindingRootIndex: number;\n\n  /**\n   * Current index of a View or Content Query which needs to be processed next.\n   * We iterate over the list of Queries and increment current query index at every step.\n   */\n  currentQueryIndex: number;\n\n  /**\n   * When host binding is executing this points to the directive index.\n   * `TView.data[currentDirectiveIndex]` is `DirectiveDef`\n   * `LView[currentDirectiveIndex]` is directive instance.\n   */\n  currentDirectiveIndex: number;\n}\n\n/**\n * All implicit instruction state is stored here.\n *\n * It is useful to have a single object where all of the state is stored as a mental model\n * (rather it being spread across many different variables.)\n *\n * PERF NOTE: Turns out that writing to a true global variable is slower than\n * having an intermediate object with properties.\n */\ninterface InstructionState {\n  /**\n   * Current `LFrame`\n   *\n   * `null` if we have not called `enterView`\n   */\n  lFrame: LFrame;\n\n  /**\n   * Stores whether directives should be matched to elements.\n   *\n   * When template contains `ngNonBindable` then we need to prevent the runtime from matching\n   * directives on children of that element.\n   *\n   * Example:\n   * ```\n   * <my-comp my-directive>\n   *   Should match component / directive.\n   * </my-comp>\n   * <div ngNonBindable>\n   *   <my-comp my-directive>\n   *     Should not match component / directive because we are in ngNonBindable.\n   *   </my-comp>\n   * </div>\n   * ```\n   */\n  bindingsEnabled: boolean;\n\n  /**\n   * In this mode, any changes in bindings will throw an ExpressionChangedAfterChecked error.\n   *\n   * Necessary to support ChangeDetectorRef.checkNoChanges().\n   */\n  checkNoChangesMode: boolean;\n}\n\nexport const instructionState: InstructionState = {\n  lFrame: createLFrame(null),\n  bindingsEnabled: true,\n  checkNoChangesMode: false,\n};\n\n\nexport function getElementDepthCount() {\n  return instructionState.lFrame.elementDepthCount;\n}\n\nexport function increaseElementDepthCount() {\n  instructionState.lFrame.elementDepthCount++;\n}\n\nexport function decreaseElementDepthCount() {\n  instructionState.lFrame.elementDepthCount--;\n}\n\nexport function getBindingsEnabled(): boolean {\n  return instructionState.bindingsEnabled;\n}\n\n\n/**\n * Enables directive matching on elements.\n *\n *  * Example:\n * ```\n * <my-comp my-directive>\n *   Should match component / directive.\n * </my-comp>\n * <div ngNonBindable>\n *   <!-- ÉµÉµdisableBindings() -->\n *   <my-comp my-directive>\n *     Should not match component / directive because we are in ngNonBindable.\n *   </my-comp>\n *   <!-- ÉµÉµenableBindings() -->\n * </div>\n * ```\n *\n * @codeGenApi\n */\nexport function ÉµÉµenableBindings(): void {\n  instructionState.bindingsEnabled = true;\n}\n\n/**\n * Disables directive matching on element.\n *\n *  * Example:\n * ```\n * <my-comp my-directive>\n *   Should match component / directive.\n * </my-comp>\n * <div ngNonBindable>\n *   <!-- ÉµÉµdisableBindings() -->\n *   <my-comp my-directive>\n *     Should not match component / directive because we are in ngNonBindable.\n *   </my-comp>\n *   <!-- ÉµÉµenableBindings() -->\n * </div>\n * ```\n *\n * @codeGenApi\n */\nexport function ÉµÉµdisableBindings(): void {\n  instructionState.bindingsEnabled = false;\n}\n\n/**\n * Return the current `LView`.\n */\nexport function getLView(): LView {\n  return instructionState.lFrame.lView;\n}\n\n/**\n * Return the current `TView`.\n */\nexport function getTView(): TView {\n  return instructionState.lFrame.tView;\n}\n\n/**\n * Restores `contextViewData` to the given OpaqueViewState instance.\n *\n * Used in conjunction with the getCurrentView() instruction to save a snapshot\n * of the current view and restore it when listeners are invoked. This allows\n * walking the declaration view tree in listeners to get vars from parent views.\n *\n * @param viewToRestore The OpaqueViewState instance to restore.\n *\n * @codeGenApi\n */\nexport function ÉµÉµrestoreView(viewToRestore: OpaqueViewState) {\n  instructionState.lFrame.contextLView = viewToRestore as any as LView;\n}\n\nexport function getPreviousOrParentTNode(): TNode {\n  return instructionState.lFrame.previousOrParentTNode;\n}\n\nexport function setPreviousOrParentTNode(tNode: TNode, _isParent: boolean) {\n  instructionState.lFrame.previousOrParentTNode = tNode;\n  instructionState.lFrame.isParent = _isParent;\n}\n\nexport function getIsParent(): boolean {\n  return instructionState.lFrame.isParent;\n}\n\nexport function setIsNotParent(): void {\n  instructionState.lFrame.isParent = false;\n}\nexport function setIsParent(): void {\n  instructionState.lFrame.isParent = true;\n}\n\nexport function getContextLView(): LView {\n  return instructionState.lFrame.contextLView;\n}\n\nexport function getCheckNoChangesMode(): boolean {\n  // TODO(misko): remove this from the LView since it is ngDevMode=true mode only.\n  return instructionState.checkNoChangesMode;\n}\n\nexport function setCheckNoChangesMode(mode: boolean): void {\n  instructionState.checkNoChangesMode = mode;\n}\n\n// top level variables should not be exported for performance reasons (PERF_NOTES.md)\nexport function getBindingRoot() {\n  const lFrame = instructionState.lFrame;\n  let index = lFrame.bindingRootIndex;\n  if (index === -1) {\n    index = lFrame.bindingRootIndex = lFrame.tView.bindingStartIndex;\n  }\n  return index;\n}\n\nexport function getBindingIndex(): number {\n  return instructionState.lFrame.bindingIndex;\n}\n\nexport function setBindingIndex(value: number): number {\n  return instructionState.lFrame.bindingIndex = value;\n}\n\nexport function nextBindingIndex(): number {\n  return instructionState.lFrame.bindingIndex++;\n}\n\nexport function incrementBindingIndex(count: number): number {\n  const lFrame = instructionState.lFrame;\n  const index = lFrame.bindingIndex;\n  lFrame.bindingIndex = lFrame.bindingIndex + count;\n  return index;\n}\n\n/**\n * Set a new binding root index so that host template functions can execute.\n *\n * Bindings inside the host template are 0 index. But because we don't know ahead of time\n * how many host bindings we have we can't pre-compute them. For this reason they are all\n * 0 index and we just shift the root so that they match next available location in the LView.\n *\n * @param bindingRootIndex Root index for `hostBindings`\n * @param currentDirectiveIndex `TData[currentDirectiveIndex]` will point to the current directive\n *        whose `hostBindings` are being processed.\n */\nexport function setBindingRootForHostBindings(\n    bindingRootIndex: number, currentDirectiveIndex: number) {\n  const lFrame = instructionState.lFrame;\n  lFrame.bindingIndex = lFrame.bindingRootIndex = bindingRootIndex;\n  lFrame.currentDirectiveIndex = currentDirectiveIndex;\n}\n\n/**\n * When host binding is executing this points to the directive index.\n * `TView.data[getCurrentDirectiveIndex()]` is `DirectiveDef`\n * `LView[getCurrentDirectiveIndex()]` is directive instance.\n */\nexport function getCurrentDirectiveIndex(): number {\n  return instructionState.lFrame.currentDirectiveIndex;\n}\n\nexport function getCurrentQueryIndex(): number {\n  return instructionState.lFrame.currentQueryIndex;\n}\n\nexport function setCurrentQueryIndex(value: number): void {\n  instructionState.lFrame.currentQueryIndex = value;\n}\n\n/**\n * This is a light weight version of the `enterView` which is needed by the DI system.\n * @param newView\n * @param tNode\n */\nexport function enterDI(newView: LView, tNode: TNode) {\n  ngDevMode && assertLViewOrUndefined(newView);\n  const newLFrame = allocLFrame();\n  instructionState.lFrame = newLFrame;\n  newLFrame.previousOrParentTNode = tNode !;\n  newLFrame.lView = newView;\n  if (ngDevMode) {\n    // resetting for safety in dev mode only.\n    newLFrame.isParent = DEV_MODE_VALUE;\n    newLFrame.selectedIndex = DEV_MODE_VALUE;\n    newLFrame.contextLView = DEV_MODE_VALUE;\n    newLFrame.elementDepthCount = DEV_MODE_VALUE;\n    newLFrame.currentNamespace = DEV_MODE_VALUE;\n    newLFrame.currentSanitizer = DEV_MODE_VALUE;\n    newLFrame.bindingRootIndex = DEV_MODE_VALUE;\n    newLFrame.currentQueryIndex = DEV_MODE_VALUE;\n  }\n}\n\nconst DEV_MODE_VALUE: any =\n    'Value indicating that DI is trying to read value which it should not need to know about.';\n\n/**\n * This is a light weight version of the `leaveView` which is needed by the DI system.\n *\n * Because the implementation is same it is only an alias\n */\nexport const leaveDI = leaveView;\n\n/**\n * Swap the current lView with a new lView.\n *\n * For performance reasons we store the lView in the top level of the module.\n * This way we minimize the number of properties to read. Whenever a new view\n * is entered we have to store the lView for later, and when the view is\n * exited the state has to be restored\n *\n * @param newView New lView to become active\n * @param tNode Element to which the View is a child of\n * @returns the previously active lView;\n */\nexport function enterView(newView: LView, tNode: TNode | null): void {\n  ngDevMode && assertLViewOrUndefined(newView);\n  const newLFrame = allocLFrame();\n  const tView = newView[TVIEW];\n  instructionState.lFrame = newLFrame;\n  newLFrame.previousOrParentTNode = tNode !;\n  newLFrame.isParent = true;\n  newLFrame.lView = newView;\n  newLFrame.tView = tView;\n  newLFrame.selectedIndex = 0;\n  newLFrame.contextLView = newView !;\n  newLFrame.elementDepthCount = 0;\n  newLFrame.currentDirectiveIndex = -1;\n  newLFrame.currentNamespace = null;\n  newLFrame.currentSanitizer = null;\n  newLFrame.bindingRootIndex = -1;\n  newLFrame.bindingIndex = tView.bindingStartIndex;\n  newLFrame.currentQueryIndex = 0;\n}\n\n/**\n * Allocates next free LFrame. This function tries to reuse the `LFrame`s to lower memory pressure.\n */\nfunction allocLFrame() {\n  const currentLFrame = instructionState.lFrame;\n  const childLFrame = currentLFrame === null ? null : currentLFrame.child;\n  const newLFrame = childLFrame === null ? createLFrame(currentLFrame) : childLFrame;\n  return newLFrame;\n}\n\nfunction createLFrame(parent: LFrame | null): LFrame {\n  const lFrame: LFrame = {\n    previousOrParentTNode: null !,  //\n    isParent: true,                 //\n    lView: null !,                  //\n    tView: null !,                  //\n    selectedIndex: 0,               //\n    contextLView: null !,           //\n    elementDepthCount: 0,           //\n    currentNamespace: null,         //\n    currentSanitizer: null,         //\n    currentDirectiveIndex: -1,      //\n    bindingRootIndex: -1,           //\n    bindingIndex: -1,               //\n    currentQueryIndex: 0,           //\n    parent: parent !,               //\n    child: null,                    //\n  };\n  parent !== null && (parent.child = lFrame);  // link the new LFrame for reuse.\n  return lFrame;\n}\n\nexport function leaveView() {\n  instructionState.lFrame = instructionState.lFrame.parent;\n}\n\nexport function nextContextImpl<T = any>(level: number): T {\n  const contextLView = instructionState.lFrame.contextLView =\n      walkUpViews(level, instructionState.lFrame.contextLView !);\n  return contextLView[CONTEXT] as T;\n}\n\nfunction walkUpViews(nestingLevel: number, currentView: LView): LView {\n  while (nestingLevel > 0) {\n    ngDevMode && assertDefined(\n                     currentView[DECLARATION_VIEW],\n                     'Declaration view should be defined if nesting level is greater than 0.');\n    currentView = currentView[DECLARATION_VIEW] !;\n    nestingLevel--;\n  }\n  return currentView;\n}\n\n/**\n * Gets the currently selected element index.\n *\n * Used with {@link property} instruction (and more in the future) to identify the index in the\n * current `LView` to act on.\n */\nexport function getSelectedIndex() {\n  return instructionState.lFrame.selectedIndex;\n}\n\n/**\n * Sets the most recent index passed to {@link select}\n *\n * Used with {@link property} instruction (and more in the future) to identify the index in the\n * current `LView` to act on.\n *\n * (Note that if an \"exit function\" was set earlier (via `setElementExitFn()`) then that will be\n * run if and when the provided `index` value is different from the current selected index value.)\n */\nexport function setSelectedIndex(index: number) {\n  instructionState.lFrame.selectedIndex = index;\n}\n\n\n/**\n * Sets the namespace used to create elements to `'http://www.w3.org/2000/svg'` in global state.\n *\n * @codeGenApi\n */\nexport function ÉµÉµnamespaceSVG() {\n  instructionState.lFrame.currentNamespace = 'http://www.w3.org/2000/svg';\n}\n\n/**\n * Sets the namespace used to create elements to `'http://www.w3.org/1998/MathML/'` in global state.\n *\n * @codeGenApi\n */\nexport function ÉµÉµnamespaceMathML() {\n  instructionState.lFrame.currentNamespace = 'http://www.w3.org/1998/MathML/';\n}\n\n/**\n * Sets the namespace used to create elements to `null`, which forces element creation to use\n * `createElement` rather than `createElementNS`.\n *\n * @codeGenApi\n */\nexport function ÉµÉµnamespaceHTML() {\n  namespaceHTMLInternal();\n}\n\n/**\n * Sets the namespace used to create elements to `null`, which forces element creation to use\n * `createElement` rather than `createElementNS`.\n */\nexport function namespaceHTMLInternal() {\n  instructionState.lFrame.currentNamespace = null;\n}\n\nexport function getNamespace(): string|null {\n  return instructionState.lFrame.currentNamespace;\n}\n\nexport function setCurrentStyleSanitizer(sanitizer: StyleSanitizeFn | null) {\n  instructionState.lFrame.currentSanitizer = sanitizer;\n}\n\nexport function resetCurrentStyleSanitizer() {\n  setCurrentStyleSanitizer(null);\n}\n\nexport function getCurrentStyleSanitizer() {\n  // TODO(misko): This should throw when there is no LView, but it turns out we can get here from\n  // `NodeStyleDebug` hence we return `null`. This should be fixed\n  const lFrame = instructionState.lFrame;\n  return lFrame === null ? null : lFrame.currentSanitizer;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {assertEqual, assertNotEqual} from '../util/assert';\n\nimport {assertFirstCreatePass} from './assert';\nimport {DirectiveDef} from './interfaces/definition';\nimport {TNode} from './interfaces/node';\nimport {FLAGS, HookData, InitPhaseState, LView, LViewFlags, PREORDER_HOOK_FLAGS, PreOrderHookFlags, TView} from './interfaces/view';\nimport {getCheckNoChangesMode} from './state';\n\n\n\n/**\n * Adds all directive lifecycle hooks from the given `DirectiveDef` to the given `TView`.\n *\n * Must be run *only* on the first template pass.\n *\n * Sets up the pre-order hooks on the provided `tView`,\n * see {@link HookData} for details about the data structure.\n *\n * @param directiveIndex The index of the directive in LView\n * @param directiveDef The definition containing the hooks to setup in tView\n * @param tView The current TView\n */\nexport function registerPreOrderHooks(\n    directiveIndex: number, directiveDef: DirectiveDef<any>, tView: TView): void {\n  ngDevMode && assertFirstCreatePass(tView);\n  const {onChanges, onInit, doCheck} = directiveDef;\n\n  if (onChanges) {\n    (tView.preOrderHooks || (tView.preOrderHooks = [])).push(directiveIndex, onChanges);\n    (tView.preOrderCheckHooks || (tView.preOrderCheckHooks = [])).push(directiveIndex, onChanges);\n  }\n\n  if (onInit) {\n    (tView.preOrderHooks || (tView.preOrderHooks = [])).push(-directiveIndex, onInit);\n  }\n\n  if (doCheck) {\n    (tView.preOrderHooks || (tView.preOrderHooks = [])).push(directiveIndex, doCheck);\n    (tView.preOrderCheckHooks || (tView.preOrderCheckHooks = [])).push(directiveIndex, doCheck);\n  }\n}\n\n/**\n *\n * Loops through the directives on the provided `tNode` and queues hooks to be\n * run that are not initialization hooks.\n *\n * Should be executed during `elementEnd()` and similar to\n * preserve hook execution order. Content, view, and destroy hooks for projected\n * components and directives must be called *before* their hosts.\n *\n * Sets up the content, view, and destroy hooks on the provided `tView`,\n * see {@link HookData} for details about the data structure.\n *\n * NOTE: This does not set up `onChanges`, `onInit` or `doCheck`, those are set up\n * separately at `elementStart`.\n *\n * @param tView The current TView\n * @param tNode The TNode whose directives are to be searched for hooks to queue\n */\nexport function registerPostOrderHooks(tView: TView, tNode: TNode): void {\n  ngDevMode && assertFirstCreatePass(tView);\n  // It's necessary to loop through the directives at elementEnd() (rather than processing in\n  // directiveCreate) so we can preserve the current hook order. Content, view, and destroy\n  // hooks for projected components and directives must be called *before* their hosts.\n  for (let i = tNode.directiveStart, end = tNode.directiveEnd; i < end; i++) {\n    const directiveDef = tView.data[i] as DirectiveDef<any>;\n    if (directiveDef.afterContentInit) {\n      (tView.contentHooks || (tView.contentHooks = [])).push(-i, directiveDef.afterContentInit);\n    }\n\n    if (directiveDef.afterContentChecked) {\n      (tView.contentHooks || (tView.contentHooks = [])).push(i, directiveDef.afterContentChecked);\n      (tView.contentCheckHooks || (tView.contentCheckHooks = [\n       ])).push(i, directiveDef.afterContentChecked);\n    }\n\n    if (directiveDef.afterViewInit) {\n      (tView.viewHooks || (tView.viewHooks = [])).push(-i, directiveDef.afterViewInit);\n    }\n\n    if (directiveDef.afterViewChecked) {\n      (tView.viewHooks || (tView.viewHooks = [])).push(i, directiveDef.afterViewChecked);\n      (tView.viewCheckHooks || (tView.viewCheckHooks = [])).push(i, directiveDef.afterViewChecked);\n    }\n\n    if (directiveDef.onDestroy != null) {\n      (tView.destroyHooks || (tView.destroyHooks = [])).push(i, directiveDef.onDestroy);\n    }\n  }\n}\n\n/**\n * Executing hooks requires complex logic as we need to deal with 2 constraints.\n *\n * 1. Init hooks (ngOnInit, ngAfterContentInit, ngAfterViewInit) must all be executed once and only\n * once, across many change detection cycles. This must be true even if some hooks throw, or if\n * some recursively trigger a change detection cycle.\n * To solve that, it is required to track the state of the execution of these init hooks.\n * This is done by storing and maintaining flags in the view: the {@link InitPhaseState},\n * and the index within that phase. They can be seen as a cursor in the following structure:\n * [[onInit1, onInit2], [afterContentInit1], [afterViewInit1, afterViewInit2, afterViewInit3]]\n * They are are stored as flags in LView[FLAGS].\n *\n * 2. Pre-order hooks can be executed in batches, because of the select instruction.\n * To be able to pause and resume their execution, we also need some state about the hook's array\n * that is being processed:\n * - the index of the next hook to be executed\n * - the number of init hooks already found in the processed part of the  array\n * They are are stored as flags in LView[PREORDER_HOOK_FLAGS].\n */\n\n\n/**\n * Executes pre-order check hooks ( OnChanges, DoChanges) given a view where all the init hooks were\n * executed once. This is a light version of executeInitAndCheckPreOrderHooks where we can skip read\n * / write of the init-hooks related flags.\n * @param lView The LView where hooks are defined\n * @param hooks Hooks to be run\n * @param nodeIndex 3 cases depending on the value:\n * - undefined: all hooks from the array should be executed (post-order case)\n * - null: execute hooks only from the saved index until the end of the array (pre-order case, when\n * flushing the remaining hooks)\n * - number: execute hooks only from the saved index until that node index exclusive (pre-order\n * case, when executing select(number))\n */\nexport function executeCheckHooks(lView: LView, hooks: HookData, nodeIndex?: number | null) {\n  callHooks(lView, hooks, InitPhaseState.InitPhaseCompleted, nodeIndex);\n}\n\n/**\n * Executes post-order init and check hooks (one of AfterContentInit, AfterContentChecked,\n * AfterViewInit, AfterViewChecked) given a view where there are pending init hooks to be executed.\n * @param lView The LView where hooks are defined\n * @param hooks Hooks to be run\n * @param initPhase A phase for which hooks should be run\n * @param nodeIndex 3 cases depending on the value:\n * - undefined: all hooks from the array should be executed (post-order case)\n * - null: execute hooks only from the saved index until the end of the array (pre-order case, when\n * flushing the remaining hooks)\n * - number: execute hooks only from the saved index until that node index exclusive (pre-order\n * case, when executing select(number))\n */\nexport function executeInitAndCheckHooks(\n    lView: LView, hooks: HookData, initPhase: InitPhaseState, nodeIndex?: number | null) {\n  ngDevMode && assertNotEqual(\n                   initPhase, InitPhaseState.InitPhaseCompleted,\n                   'Init pre-order hooks should not be called more than once');\n  if ((lView[FLAGS] & LViewFlags.InitPhaseStateMask) === initPhase) {\n    callHooks(lView, hooks, initPhase, nodeIndex);\n  }\n}\n\nexport function incrementInitPhaseFlags(lView: LView, initPhase: InitPhaseState): void {\n  ngDevMode &&\n      assertNotEqual(\n          initPhase, InitPhaseState.InitPhaseCompleted,\n          'Init hooks phase should not be incremented after all init hooks have been run.');\n  let flags = lView[FLAGS];\n  if ((flags & LViewFlags.InitPhaseStateMask) === initPhase) {\n    flags &= LViewFlags.IndexWithinInitPhaseReset;\n    flags += LViewFlags.InitPhaseStateIncrementer;\n    lView[FLAGS] = flags;\n  }\n}\n\n/**\n * Calls lifecycle hooks with their contexts, skipping init hooks if it's not\n * the first LView pass\n *\n * @param currentView The current view\n * @param arr The array in which the hooks are found\n * @param initPhaseState the current state of the init phase\n * @param currentNodeIndex 3 cases depending on the value:\n * - undefined: all hooks from the array should be executed (post-order case)\n * - null: execute hooks only from the saved index until the end of the array (pre-order case, when\n * flushing the remaining hooks)\n * - number: execute hooks only from the saved index until that node index exclusive (pre-order\n * case, when executing select(number))\n */\nfunction callHooks(\n    currentView: LView, arr: HookData, initPhase: InitPhaseState,\n    currentNodeIndex: number | null | undefined): void {\n  ngDevMode && assertEqual(\n                   getCheckNoChangesMode(), false,\n                   'Hooks should never be run in the check no changes mode.');\n  const startIndex = currentNodeIndex !== undefined ?\n      (currentView[PREORDER_HOOK_FLAGS] & PreOrderHookFlags.IndexOfTheNextPreOrderHookMaskMask) :\n      0;\n  const nodeIndexLimit = currentNodeIndex != null ? currentNodeIndex : -1;\n  let lastNodeIndexFound = 0;\n  for (let i = startIndex; i < arr.length; i++) {\n    const hook = arr[i + 1] as() => void;\n    if (typeof hook === 'number') {\n      lastNodeIndexFound = arr[i] as number;\n      if (currentNodeIndex != null && lastNodeIndexFound >= currentNodeIndex) {\n        break;\n      }\n    } else {\n      const isInitHook = arr[i] < 0;\n      if (isInitHook)\n        currentView[PREORDER_HOOK_FLAGS] += PreOrderHookFlags.NumberOfInitHooksCalledIncrementer;\n      if (lastNodeIndexFound < nodeIndexLimit || nodeIndexLimit == -1) {\n        callHook(currentView, initPhase, arr, i);\n        currentView[PREORDER_HOOK_FLAGS] =\n            (currentView[PREORDER_HOOK_FLAGS] & PreOrderHookFlags.NumberOfInitHooksCalledMask) + i +\n            2;\n      }\n      i++;\n    }\n  }\n}\n\n/**\n * Execute one hook against the current `LView`.\n *\n * @param currentView The current view\n * @param initPhaseState the current state of the init phase\n * @param arr The array in which the hooks are found\n * @param i The current index within the hook data array\n */\nfunction callHook(currentView: LView, initPhase: InitPhaseState, arr: HookData, i: number) {\n  const isInitHook = arr[i] < 0;\n  const hook = arr[i + 1] as() => void;\n  const directiveIndex = isInitHook ? -arr[i] : arr[i] as number;\n  const directive = currentView[directiveIndex];\n  if (isInitHook) {\n    const indexWithintInitPhase = currentView[FLAGS] >> LViewFlags.IndexWithinInitPhaseShift;\n    // The init phase state must be always checked here as it may have been recursively\n    // updated\n    if (indexWithintInitPhase <\n            (currentView[PREORDER_HOOK_FLAGS] >> PreOrderHookFlags.NumberOfInitHooksCalledShift) &&\n        (currentView[FLAGS] & LViewFlags.InitPhaseStateMask) === initPhase) {\n      currentView[FLAGS] += LViewFlags.IndexWithinInitPhaseIncrementer;\n      hook.call(directive);\n    }\n  } else {\n    hook.call(directive);\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {InjectionToken} from '../../di/injection_token';\nimport {InjectFlags} from '../../di/interface/injector';\nimport {Type} from '../../interface/type';\n\nimport {TDirectiveHostNode} from './node';\nimport {LView, TData} from './view';\n\nexport const TNODE = 8;\nexport const PARENT_INJECTOR = 8;\nexport const INJECTOR_BLOOM_PARENT_SIZE = 9;\n\n/**\n * Represents a relative location of parent injector.\n *\n * The interfaces encodes number of parents `LView`s to traverse and index in the `LView`\n * pointing to the parent injector.\n */\nexport interface RelativeInjectorLocation { __brand__: 'RelativeInjectorLocationFlags'; }\n\nexport const enum RelativeInjectorLocationFlags {\n  InjectorIndexMask = 0b111111111111111,\n  ViewOffsetShift = 16,\n  NO_PARENT = -1,\n}\n\nexport const NO_PARENT_INJECTOR: RelativeInjectorLocation = -1 as any;\n\n/**\n * Each injector is saved in 9 contiguous slots in `LView` and 9 contiguous slots in\n * `TView.data`. This allows us to store information about the current node's tokens (which\n * can be shared in `TView`) as well as the tokens of its ancestor nodes (which cannot be\n * shared, so they live in `LView`).\n *\n * Each of these slots (aside from the last slot) contains a bloom filter. This bloom filter\n * determines whether a directive is available on the associated node or not. This prevents us\n * from searching the directives array at this level unless it's probable the directive is in it.\n *\n * See: https://en.wikipedia.org/wiki/Bloom_filter for more about bloom filters.\n *\n * Because all injectors have been flattened into `LView` and `TViewData`, they cannot typed\n * using interfaces as they were previously. The start index of each `LInjector` and `TInjector`\n * will differ based on where it is flattened into the main array, so it's not possible to know\n * the indices ahead of time and save their types here. The interfaces are still included here\n * for documentation purposes.\n *\n * export interface LInjector extends Array<any> {\n *\n *    // Cumulative bloom for directive IDs 0-31  (IDs are % BLOOM_SIZE)\n *    [0]: number;\n *\n *    // Cumulative bloom for directive IDs 32-63\n *    [1]: number;\n *\n *    // Cumulative bloom for directive IDs 64-95\n *    [2]: number;\n *\n *    // Cumulative bloom for directive IDs 96-127\n *    [3]: number;\n *\n *    // Cumulative bloom for directive IDs 128-159\n *    [4]: number;\n *\n *    // Cumulative bloom for directive IDs 160 - 191\n *    [5]: number;\n *\n *    // Cumulative bloom for directive IDs 192 - 223\n *    [6]: number;\n *\n *    // Cumulative bloom for directive IDs 224 - 255\n *    [7]: number;\n *\n *    // We need to store a reference to the injector's parent so DI can keep looking up\n *    // the injector tree until it finds the dependency it's looking for.\n *    [PARENT_INJECTOR]: number;\n * }\n *\n * export interface TInjector extends Array<any> {\n *\n *    // Shared node bloom for directive IDs 0-31  (IDs are % BLOOM_SIZE)\n *    [0]: number;\n *\n *    // Shared node bloom for directive IDs 32-63\n *    [1]: number;\n *\n *    // Shared node bloom for directive IDs 64-95\n *    [2]: number;\n *\n *    // Shared node bloom for directive IDs 96-127\n *    [3]: number;\n *\n *    // Shared node bloom for directive IDs 128-159\n *    [4]: number;\n *\n *    // Shared node bloom for directive IDs 160 - 191\n *    [5]: number;\n *\n *    // Shared node bloom for directive IDs 192 - 223\n *    [6]: number;\n *\n *    // Shared node bloom for directive IDs 224 - 255\n *    [7]: number;\n *\n *    // Necessary to find directive indices for a particular node.\n *    [TNODE]: TElementNode|TElementContainerNode|TContainerNode;\n *  }\n */\n\n/**\n* Factory for creating instances of injectors in the NodeInjector.\n*\n* This factory is complicated by the fact that it can resolve `multi` factories as well.\n*\n* NOTE: Some of the fields are optional which means that this class has two hidden classes.\n* - One without `multi` support (most common)\n* - One with `multi` values, (rare).\n*\n* Since VMs can cache up to 4 inline hidden classes this is OK.\n*\n* - Single factory: Only `resolving` and `factory` is defined.\n* - `providers` factory: `componentProviders` is a number and `index = -1`.\n* - `viewProviders` factory: `componentProviders` is a number and `index` points to `providers`.\n*/\nexport class NodeInjectorFactory {\n  /**\n   * The inject implementation to be activated when using the factory.\n   */\n  injectImpl: null|(<T>(token: Type<T>|InjectionToken<T>, flags?: InjectFlags) => T);\n\n  /**\n   * Marker set to true during factory invocation to see if we get into recursive loop.\n   * Recursive loop causes an error to be displayed.\n   */\n  resolving = false;\n\n  /**\n   * Marks that the token can see other Tokens declared in `viewProviders` on the same node.\n   */\n  canSeeViewProviders: boolean;\n\n  /**\n   * An array of factories to use in case of `multi` provider.\n   */\n  multi?: Array<() => any>;\n\n  /**\n   * Number of `multi`-providers which belong to the component.\n   *\n   * This is needed because when multiple components and directives declare the `multi` provider\n   * they have to be concatenated in the correct order.\n   *\n   * Example:\n   *\n   * If we have a component and directive active an a single element as declared here\n   * ```\n   * component:\n   *   provides: [ {provide: String, useValue: 'component', multi: true} ],\n   *   viewProvides: [ {provide: String, useValue: 'componentView', multi: true} ],\n   *\n   * directive:\n   *   provides: [ {provide: String, useValue: 'directive', multi: true} ],\n   * ```\n   *\n   * Then the expected results are:\n   *\n   * ```\n   * providers: ['component', 'directive']\n   * viewProviders: ['component', 'componentView', 'directive']\n   * ```\n   *\n   * The way to think about it is that the `viewProviders` have been inserted after the component\n   * but before the directives, which is why we need to know how many `multi`s have been declared by\n   * the component.\n   */\n  componentProviders?: number;\n\n  /**\n   * Current index of the Factory in the `data`. Needed for `viewProviders` and `providers` merging.\n   * See `providerFactory`.\n   */\n  index?: number;\n\n  /**\n   * Because the same `multi` provider can be declared in `provides` and `viewProvides` it is\n   * possible for `viewProvides` to shadow the `provides`. For this reason we store the\n   * `provideFactory` of the `providers` so that `providers` can be extended with `viewProviders`.\n   *\n   * Example:\n   *\n   * Given:\n   * ```\n   * provides: [ {provide: String, useValue: 'all', multi: true} ],\n   * viewProvides: [ {provide: String, useValue: 'viewOnly', multi: true} ],\n   * ```\n   *\n   * We have to return `['all']` in case of content injection, but `['all', 'viewOnly']` in case\n   * of view injection. We further have to make sure that the shared instances (in our case\n   * `all`) are the exact same instance in both the content as well as the view injection. (We\n   * have to make sure that we don't double instantiate.) For this reason the `viewProvides`\n   * `Factory` has a pointer to the shadowed `provides` factory so that it can instantiate the\n   * `providers` (`['all']`) and then extend it with `viewProviders` (`['all'] + ['viewOnly'] =\n   * ['all', 'viewOnly']`).\n   */\n  providerFactory?: NodeInjectorFactory|null;\n\n\n  constructor(\n      /**\n       * Factory to invoke in order to create a new instance.\n       */\n      public factory:\n          (this: NodeInjectorFactory, _: undefined,\n           /**\n            * array where injectables tokens are stored. This is used in\n            * case of an error reporting to produce friendlier errors.\n            */\n           tData: TData,\n           /**\n            * array where existing instances of injectables are stored. This is used in case\n            * of multi shadow is needed. See `multi` field documentation.\n            */\n           lView: LView,\n           /**\n            * The TNode of the same element injector.\n            */\n           tNode: TDirectiveHostNode) => any,\n      /**\n       * Set to `true` if the token is declared in `viewProviders` (or if it is component).\n       */\n      isViewProvider: boolean, injectImplementation: null|\n      (<T>(token: Type<T>|InjectionToken<T>, flags?: InjectFlags) => T)) {\n    this.canSeeViewProviders = isViewProvider;\n    this.injectImpl = injectImplementation;\n  }\n}\n\nexport function isFactory(obj: any): obj is NodeInjectorFactory {\n  return obj instanceof NodeInjectorFactory;\n}\n\n// Note: This hack is necessary so we don't erroneously get a circular dependency\n// failure based on types.\nexport const unusedValueExportToPlacateAjd = 1;\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {assertDefined, assertEqual} from '../util/assert';\nimport {TNode, TNodeType} from './interfaces/node';\n\nexport function assertNodeType(tNode: TNode, type: TNodeType) {\n  assertDefined(tNode, 'should be called with a TNode');\n  assertEqual(tNode.type, type, `should be a ${typeName(type)}`);\n}\n\nexport function assertNodeOfPossibleTypes(tNode: TNode, ...types: TNodeType[]) {\n  assertDefined(tNode, 'should be called with a TNode');\n  const found = types.some(type => tNode.type === type);\n  assertEqual(\n      found, true,\n      `Should be one of ${types.map(typeName).join(', ')} but got ${typeName(tNode.type)}`);\n}\n\nfunction typeName(type: TNodeType): string {\n  if (type == TNodeType.Projection) return 'Projection';\n  if (type == TNodeType.Container) return 'Container';\n  if (type == TNodeType.IcuContainer) return 'IcuContainer';\n  if (type == TNodeType.View) return 'View';\n  if (type == TNodeType.Element) return 'Element';\n  if (type == TNodeType.ElementContainer) return 'ElementContainer';\n  return '<unknown>';\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Most of the use of `document` in Angular is from within the DI system so it is possible to simply\n * inject the `DOCUMENT` token and are done.\n *\n * Ivy is special because it does not rely upon the DI and must get hold of the document some other\n * way.\n *\n * The solution is to define `getDocument()` and `setDocument()` top-level functions for ivy.\n * Wherever ivy needs the global document, it calls `getDocument()` instead.\n *\n * When running ivy outside of a browser environment, it is necessary to call `setDocument()` to\n * tell ivy what the global `document` is.\n *\n * Angular does this for us in each of the standard platforms (`Browser`, `Server`, and `WebWorker`)\n * by calling `setDocument()` when providing the `DOCUMENT` token.\n */\nlet DOCUMENT: Document|undefined = undefined;\n\n/**\n * Tell ivy what the `document` is for this platform.\n *\n * It is only necessary to call this if the current platform is not a browser.\n *\n * @param document The object representing the global `document` in this environment.\n */\nexport function setDocument(document: Document | undefined): void {\n  DOCUMENT = document;\n}\n\n/**\n * Access the object that represents the `document` for this platform.\n *\n * Ivy calls this whenever it needs to access the `document` object.\n * For example to create the renderer or to do sanitization.\n */\nexport function getDocument(): Document {\n  if (DOCUMENT !== undefined) {\n    return DOCUMENT;\n  } else if (typeof document !== 'undefined') {\n    return document;\n  }\n  // No \"document\" can be found. This should only happen if we are running ivy outside Angular and\n  // the current platform is not a browser. Since this is not a supported scenario at the moment\n  // this should not happen in Angular apps.\n  // Once we support running ivy outside of Angular we will need to publish `setDocument()` as a\n  // public API. Meanwhile we just return `undefined` and let the application fail.\n  return undefined !;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * The goal here is to make sure that the browser DOM API is the Renderer.\n * We do this by defining a subset of DOM API to be the renderer and then\n * use that at runtime for rendering.\n *\n * At runtime we can then use the DOM api directly, in server or web-worker\n * it will be easy to implement such API.\n */\n\nimport {RendererStyleFlags2, RendererType2} from '../../render/api';\nimport {getDocument} from './document';\n\n// TODO: cleanup once the code is merged in angular/angular\nexport enum RendererStyleFlags3 {\n  Important = 1 << 0,\n  DashCase = 1 << 1\n}\n\nexport type Renderer3 = ObjectOrientedRenderer3 | ProceduralRenderer3;\n\nexport type GlobalTargetName = 'document' | 'window' | 'body';\n\nexport type GlobalTargetResolver = (element: any) => {\n  name: GlobalTargetName, target: EventTarget\n};\n\n/**\n * Object Oriented style of API needed to create elements and text nodes.\n *\n * This is the native browser API style, e.g. operations are methods on individual objects\n * like HTMLElement. With this style, no additional code is needed as a facade\n * (reducing payload size).\n * */\nexport interface ObjectOrientedRenderer3 {\n  createComment(data: string): RComment;\n  createElement(tagName: string): RElement;\n  createElementNS(namespace: string, tagName: string): RElement;\n  createTextNode(data: string): RText;\n\n  querySelector(selectors: string): RElement|null;\n}\n\n/** Returns whether the `renderer` is a `ProceduralRenderer3` */\nexport function isProceduralRenderer(renderer: ProceduralRenderer3 | ObjectOrientedRenderer3):\n    renderer is ProceduralRenderer3 {\n  return !!((renderer as any).listen);\n}\n\n/**\n * Procedural style of API needed to create elements and text nodes.\n *\n * In non-native browser environments (e.g. platforms such as web-workers), this is the\n * facade that enables element manipulation. This also facilitates backwards compatibility\n * with Renderer2.\n */\nexport interface ProceduralRenderer3 {\n  destroy(): void;\n  createComment(value: string): RComment;\n  createElement(name: string, namespace?: string|null): RElement;\n  createText(value: string): RText;\n  /**\n   * This property is allowed to be null / undefined,\n   * in which case the view engine won't call it.\n   * This is used as a performance optimization for production mode.\n   */\n  destroyNode?: ((node: RNode) => void)|null;\n  appendChild(parent: RElement, newChild: RNode): void;\n  insertBefore(parent: RNode, newChild: RNode, refChild: RNode|null): void;\n  removeChild(parent: RElement, oldChild: RNode, isHostElement?: boolean): void;\n  selectRootElement(selectorOrNode: string|any, preserveContent?: boolean): RElement;\n\n  parentNode(node: RNode): RElement|null;\n  nextSibling(node: RNode): RNode|null;\n\n  setAttribute(el: RElement, name: string, value: string, namespace?: string|null): void;\n  removeAttribute(el: RElement, name: string, namespace?: string|null): void;\n  addClass(el: RElement, name: string): void;\n  removeClass(el: RElement, name: string): void;\n  setStyle(\n      el: RElement, style: string, value: any,\n      flags?: RendererStyleFlags2|RendererStyleFlags3): void;\n  removeStyle(el: RElement, style: string, flags?: RendererStyleFlags2|RendererStyleFlags3): void;\n  setProperty(el: RElement, name: string, value: any): void;\n  setValue(node: RText|RComment, value: string): void;\n\n  // TODO(misko): Deprecate in favor of addEventListener/removeEventListener\n  listen(\n      target: GlobalTargetName|RNode, eventName: string,\n      callback: (event: any) => boolean | void): () => void;\n}\n\nexport interface RendererFactory3 {\n  createRenderer(hostElement: RElement|null, rendererType: RendererType2|null): Renderer3;\n  begin?(): void;\n  end?(): void;\n}\n\nexport const domRendererFactory3: RendererFactory3 = {\n  createRenderer: (hostElement: RElement | null, rendererType: RendererType2 | null):\n                      Renderer3 => { return getDocument();}\n};\n\n/** Subset of API needed for appending elements and text nodes. */\nexport interface RNode {\n  /**\n   * Returns the parent Element, Document, or DocumentFragment\n   */\n  parentNode: RNode|null;\n\n\n  /**\n   * Returns the parent Element if there is one\n   */\n  parentElement: RElement|null;\n\n  /**\n   * Gets the Node immediately following this one in the parent's childNodes\n   */\n  nextSibling: RNode|null;\n\n  /**\n   * Removes a child from the current node and returns the removed node\n   * @param oldChild the child node to remove\n   */\n  removeChild(oldChild: RNode): RNode;\n\n  /**\n   * Insert a child node.\n   *\n   * Used exclusively for adding View root nodes into ViewAnchor location.\n   */\n  insertBefore(newChild: RNode, refChild: RNode|null, isViewRoot: boolean): void;\n\n  /**\n   * Append a child node.\n   *\n   * Used exclusively for building up DOM which are static (ie not View roots)\n   */\n  appendChild(newChild: RNode): RNode;\n}\n\n/**\n * Subset of API needed for writing attributes, properties, and setting up\n * listeners on Element.\n */\nexport interface RElement extends RNode {\n  style: RCssStyleDeclaration;\n  classList: RDomTokenList;\n  className: string;\n  textContent: string|null;\n  setAttribute(name: string, value: string): void;\n  removeAttribute(name: string): void;\n  setAttributeNS(namespaceURI: string, qualifiedName: string, value: string): void;\n  addEventListener(type: string, listener: EventListener, useCapture?: boolean): void;\n  removeEventListener(type: string, listener?: EventListener, options?: boolean): void;\n\n  setProperty?(name: string, value: any): void;\n}\n\nexport interface RCssStyleDeclaration {\n  removeProperty(propertyName: string): string;\n  setProperty(propertyName: string, value: string|null, priority?: string): void;\n}\n\nexport interface RDomTokenList {\n  add(token: string): void;\n  remove(token: string): void;\n}\n\nexport interface RText extends RNode { textContent: string|null; }\n\nexport interface RComment extends RNode { textContent: string|null; }\n\n// Note: This hack is necessary so we don't erroneously get a circular dependency\n// failure based on types.\nexport const unusedValueExportToPlacateAjd = 1;\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {CharCode} from '../../util/char_code';\nimport {AttributeMarker, TAttributes} from '../interfaces/node';\nimport {CssSelector} from '../interfaces/projection';\nimport {ProceduralRenderer3, RElement, Renderer3, isProceduralRenderer} from '../interfaces/renderer';\n\n\n\n/**\n * Assigns all attribute values to the provided element via the inferred renderer.\n *\n * This function accepts two forms of attribute entries:\n *\n * default: (key, value):\n *  attrs = [key1, value1, key2, value2]\n *\n * namespaced: (NAMESPACE_MARKER, uri, name, value)\n *  attrs = [NAMESPACE_MARKER, uri, name, value, NAMESPACE_MARKER, uri, name, value]\n *\n * The `attrs` array can contain a mix of both the default and namespaced entries.\n * The \"default\" values are set without a marker, but if the function comes across\n * a marker value then it will attempt to set a namespaced value. If the marker is\n * not of a namespaced value then the function will quit and return the index value\n * where it stopped during the iteration of the attrs array.\n *\n * See [AttributeMarker] to understand what the namespace marker value is.\n *\n * Note that this instruction does not support assigning style and class values to\n * an element. See `elementStart` and `elementHostAttrs` to learn how styling values\n * are applied to an element.\n * @param renderer The renderer to be used\n * @param native The element that the attributes will be assigned to\n * @param attrs The attribute array of values that will be assigned to the element\n * @returns the index value that was last accessed in the attributes array\n */\nexport function setUpAttributes(renderer: Renderer3, native: RElement, attrs: TAttributes): number {\n  const isProc = isProceduralRenderer(renderer);\n\n  let i = 0;\n  while (i < attrs.length) {\n    const value = attrs[i];\n    if (typeof value === 'number') {\n      // only namespaces are supported. Other value types (such as style/class\n      // entries) are not supported in this function.\n      if (value !== AttributeMarker.NamespaceURI) {\n        break;\n      }\n\n      // we just landed on the marker value ... therefore\n      // we should skip to the next entry\n      i++;\n\n      const namespaceURI = attrs[i++] as string;\n      const attrName = attrs[i++] as string;\n      const attrVal = attrs[i++] as string;\n      ngDevMode && ngDevMode.rendererSetAttribute++;\n      isProc ?\n          (renderer as ProceduralRenderer3).setAttribute(native, attrName, attrVal, namespaceURI) :\n          native.setAttributeNS(namespaceURI, attrName, attrVal);\n    } else {\n      // attrName is string;\n      const attrName = value as string;\n      const attrVal = attrs[++i];\n      // Standard attributes\n      ngDevMode && ngDevMode.rendererSetAttribute++;\n      if (isAnimationProp(attrName)) {\n        if (isProc) {\n          (renderer as ProceduralRenderer3).setProperty(native, attrName, attrVal);\n        }\n      } else {\n        isProc ?\n            (renderer as ProceduralRenderer3).setAttribute(native, attrName, attrVal as string) :\n            native.setAttribute(attrName, attrVal as string);\n      }\n      i++;\n    }\n  }\n\n  // another piece of code may iterate over the same attributes array. Therefore\n  // it may be helpful to return the exact spot where the attributes array exited\n  // whether by running into an unsupported marker or if all the static values were\n  // iterated over.\n  return i;\n}\n\n/**\n * Test whether the given value is a marker that indicates that the following\n * attribute values in a `TAttributes` array are only the names of attributes,\n * and not name-value pairs.\n * @param marker The attribute marker to test.\n * @returns true if the marker is a \"name-only\" marker (e.g. `Bindings`, `Template` or `I18n`).\n */\nexport function isNameOnlyAttributeMarker(marker: string | AttributeMarker | CssSelector) {\n  return marker === AttributeMarker.Bindings || marker === AttributeMarker.Template ||\n      marker === AttributeMarker.I18n;\n}\n\nexport function isAnimationProp(name: string): boolean {\n  // Perf note: accessing charCodeAt to check for the first character of a string is faster as\n  // compared to accessing a character at index 0 (ex. name[0]). The main reason for this is that\n  // charCodeAt doesn't allocate memory to return a substring.\n  return name.charCodeAt(0) === CharCode.AT_SIGN;\n}\n\n/**\n * Merges `src` `TAttributes` into `dst` `TAttributes` removing any duplicates in the process.\n *\n * This merge function keeps the order of attrs same.\n *\n * @param dst Location of where the merged `TAttributes` should end up.\n * @param src `TAttributes` which should be appended to `dst`\n */\nexport function mergeHostAttrs(dst: TAttributes | null, src: TAttributes | null): TAttributes|null {\n  if (src === null || src.length === 0) {\n    // do nothing\n  } else if (dst === null || dst.length === 0) {\n    // We have source, but dst is empty, just make a copy.\n    dst = src.slice();\n  } else {\n    let srcMarker: AttributeMarker = AttributeMarker.ImplicitAttributes;\n    for (let i = 0; i < src.length; i++) {\n      const item = src[i];\n      if (typeof item === 'number') {\n        srcMarker = item;\n      } else {\n        if (srcMarker === AttributeMarker.NamespaceURI) {\n          // Case where we need to consume `key1`, `key2`, `value` items.\n        } else if (\n            srcMarker === AttributeMarker.ImplicitAttributes ||\n            srcMarker === AttributeMarker.Styles) {\n          // Case where we have to consume `key1` and `value` only.\n          mergeHostAttribute(dst, srcMarker, item as string, null, src[++i] as string);\n        } else {\n          // Case where we have to consume `key1` only.\n          mergeHostAttribute(dst, srcMarker, item as string, null, null);\n        }\n      }\n    }\n  }\n  return dst;\n}\n\n/**\n * Append `key`/`value` to existing `TAttributes` taking region marker and duplicates into account.\n *\n * @param dst `TAttributes` to append to.\n * @param marker Region where the `key`/`value` should be added.\n * @param key1 Key to add to `TAttributes`\n * @param key2 Key to add to `TAttributes` (in case of `AttributeMarker.NamespaceURI`)\n * @param value Value to add or to overwrite to `TAttributes` Only used if `marker` is not Class.\n */\nexport function mergeHostAttribute(\n    dst: TAttributes, marker: AttributeMarker, key1: string, key2: string | null,\n    value: string | null): void {\n  let i = 0;\n  // Assume that new markers will be inserted at the end.\n  let markerInsertPosition = dst.length;\n  // scan until correct type.\n  if (marker === AttributeMarker.ImplicitAttributes) {\n    markerInsertPosition = -1;\n  } else {\n    while (i < dst.length) {\n      const dstValue = dst[i++];\n      if (typeof dstValue === 'number') {\n        if (dstValue === marker) {\n          markerInsertPosition = -1;\n          break;\n        } else if (dstValue > marker) {\n          // We need to save this as we want the markers to be inserted in specific order.\n          markerInsertPosition = i - 1;\n          break;\n        }\n      }\n    }\n  }\n\n  // search until you find place of insertion\n  while (i < dst.length) {\n    const item = dst[i];\n    if (typeof item === 'number') {\n      // since `i` started as the index after the marker, we did not find it if we are at the next\n      // marker\n      break;\n    } else if (item === key1) {\n      // We already have same token\n      if (key2 === null) {\n        if (value !== null) {\n          dst[i + 1] = value;\n        }\n        return;\n      } else if (key2 === dst[i + 1]) {\n        dst[i + 2] = value !;\n        return;\n      }\n    }\n    // Increment counter.\n    i++;\n    if (key2 !== null) i++;\n    if (value !== null) i++;\n  }\n\n  // insert at location.\n  if (markerInsertPosition !== -1) {\n    dst.splice(markerInsertPosition, 0, marker);\n    i = markerInsertPosition + 1;\n  }\n  dst.splice(i++, 0, key1);\n  if (key2 !== null) {\n    dst.splice(i++, 0, key2);\n  }\n  if (value !== null) {\n    dst.splice(i++, 0, value);\n  }\n}","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {NO_PARENT_INJECTOR, RelativeInjectorLocation, RelativeInjectorLocationFlags} from '../interfaces/injector';\nimport {DECLARATION_VIEW, LView} from '../interfaces/view';\n/// Parent Injector Utils ///////////////////////////////////////////////////////////////\nexport function hasParentInjector(parentLocation: RelativeInjectorLocation): boolean {\n  return parentLocation !== NO_PARENT_INJECTOR;\n}\n\nexport function getParentInjectorIndex(parentLocation: RelativeInjectorLocation): number {\n  return (parentLocation as any as number) & RelativeInjectorLocationFlags.InjectorIndexMask;\n}\n\nexport function getParentInjectorViewOffset(parentLocation: RelativeInjectorLocation): number {\n  return (parentLocation as any as number) >> RelativeInjectorLocationFlags.ViewOffsetShift;\n}\n\n/**\n * Unwraps a parent injector location number to find the view offset from the current injector,\n * then walks up the declaration view tree until the view is found that contains the parent\n * injector.\n *\n * @param location The location of the parent injector, which contains the view offset\n * @param startView The LView instance from which to start walking up the view tree\n * @returns The LView instance that contains the parent injector\n */\nexport function getParentInjectorView(location: RelativeInjectorLocation, startView: LView): LView {\n  let viewOffset = getParentInjectorViewOffset(location);\n  let parentView = startView;\n  // For most cases, the parent injector can be found on the host node (e.g. for component\n  // or container), but we must keep the loop here to support the rarer case of deeply nested\n  // <ng-template> tags or inline views, where the parent injector might live many views\n  // above the child injector.\n  while (viewOffset > 0) {\n    parentView = parentView[DECLARATION_VIEW] !;\n    viewOffset--;\n  }\n  return parentView;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {global} from '../../util/global';\nimport {RElement} from '../interfaces/renderer';\n\n/**\n * Used for stringify render output in Ivy.\n * Important! This function is very performance-sensitive and we should\n * be extra careful not to introduce megamorphic reads in it.\n */\nexport function renderStringify(value: any): string {\n  if (typeof value === 'string') return value;\n  if (value == null) return '';\n  return '' + value;\n}\n\n\n/**\n * Used to stringify a value so that it can be displayed in an error message.\n * Important! This function contains a megamorphic read and should only be\n * used for error messages.\n */\nexport function stringifyForError(value: any): string {\n  if (typeof value === 'function') return value.name || value.toString();\n  if (typeof value === 'object' && value != null && typeof value.type === 'function') {\n    return value.type.name || value.type.toString();\n  }\n\n  return renderStringify(value);\n}\n\n\nexport const defaultScheduler =\n    (() =>\n         (typeof requestAnimationFrame !== 'undefined' && requestAnimationFrame ||  // browser only\n          setTimeout  // everything else\n          ).bind(global))();\n\n/**\n *\n * @codeGenApi\n */\nexport function ÉµÉµresolveWindow(element: RElement & {ownerDocument: Document}) {\n  return {name: 'window', target: element.ownerDocument.defaultView};\n}\n\n/**\n *\n * @codeGenApi\n */\nexport function ÉµÉµresolveDocument(element: RElement & {ownerDocument: Document}) {\n  return {name: 'document', target: element.ownerDocument};\n}\n\n/**\n *\n * @codeGenApi\n */\nexport function ÉµÉµresolveBody(element: RElement & {ownerDocument: Document}) {\n  return {name: 'body', target: element.ownerDocument.body};\n}\n\n/**\n * The special delimiter we use to separate property names, prefixes, and suffixes\n * in property binding metadata. See storeBindingMetadata().\n *\n * We intentionally use the Unicode \"REPLACEMENT CHARACTER\" (U+FFFD) as a delimiter\n * because it is a very uncommon character that is unlikely to be part of a user's\n * property names or interpolation strings. If it is in fact used in a property\n * binding, DebugElement.properties will not return the correct value for that\n * binding. However, there should be no runtime effect for real applications.\n *\n * This character is typically rendered as a question mark inside of a diamond.\n * See https://en.wikipedia.org/wiki/Specials_(Unicode_block)\n *\n */\nexport const INTERPOLATION_DELIMITER = `ï¿½`;\n\n/**\n * Unwrap a value which might be behind a closure (for forward declaration reasons).\n */\nexport function maybeUnwrapFn<T>(value: T | (() => T)): T {\n  if (value instanceof Function) {\n    return value();\n  } else {\n    return value;\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {isForwardRef, resolveForwardRef} from '../di/forward_ref';\nimport {InjectionToken} from '../di/injection_token';\nimport {Injector} from '../di/injector';\nimport {injectRootLimpMode, setInjectImplementation} from '../di/injector_compatibility';\nimport {getInjectorDef} from '../di/interface/defs';\nimport {InjectFlags} from '../di/interface/injector';\nimport {Type} from '../interface/type';\nimport {assertDefined, assertEqual} from '../util/assert';\n\nimport {assertDirectiveDef} from './assert';\nimport {getFactoryDef} from './definition';\nimport {NG_ELEMENT_ID, NG_FACTORY_DEF} from './fields';\nimport {registerPreOrderHooks} from './hooks';\nimport {DirectiveDef, FactoryFn} from './interfaces/definition';\nimport {NO_PARENT_INJECTOR, NodeInjectorFactory, PARENT_INJECTOR, RelativeInjectorLocation, RelativeInjectorLocationFlags, TNODE, isFactory} from './interfaces/injector';\nimport {AttributeMarker, TContainerNode, TDirectiveHostNode, TElementContainerNode, TElementNode, TNode, TNodeProviderIndexes, TNodeType} from './interfaces/node';\nimport {isComponentDef, isComponentHost} from './interfaces/type_checks';\nimport {DECLARATION_COMPONENT_VIEW, DECLARATION_VIEW, INJECTOR, LView, TData, TVIEW, TView, T_HOST} from './interfaces/view';\nimport {assertNodeOfPossibleTypes} from './node_assert';\nimport {enterDI, leaveDI} from './state';\nimport {isNameOnlyAttributeMarker} from './util/attrs_utils';\nimport {getParentInjectorIndex, getParentInjectorView, hasParentInjector} from './util/injector_utils';\nimport {stringifyForError} from './util/misc_utils';\n\n\n\n/**\n * Defines if the call to `inject` should include `viewProviders` in its resolution.\n *\n * This is set to true when we try to instantiate a component. This value is reset in\n * `getNodeInjectable` to a value which matches the declaration location of the token about to be\n * instantiated. This is done so that if we are injecting a token which was declared outside of\n * `viewProviders` we don't accidentally pull `viewProviders` in.\n *\n * Example:\n *\n * ```\n * @Injectable()\n * class MyService {\n *   constructor(public value: String) {}\n * }\n *\n * @Component({\n *   providers: [\n *     MyService,\n *     {provide: String, value: 'providers' }\n *   ]\n *   viewProviders: [\n *     {provide: String, value: 'viewProviders'}\n *   ]\n * })\n * class MyComponent {\n *   constructor(myService: MyService, value: String) {\n *     // We expect that Component can see into `viewProviders`.\n *     expect(value).toEqual('viewProviders');\n *     // `MyService` was not declared in `viewProviders` hence it can't see it.\n *     expect(myService.value).toEqual('providers');\n *   }\n * }\n *\n * ```\n */\nlet includeViewProviders = true;\n\nfunction setIncludeViewProviders(v: boolean): boolean {\n  const oldValue = includeViewProviders;\n  includeViewProviders = v;\n  return oldValue;\n}\n\n/**\n * The number of slots in each bloom filter (used by DI). The larger this number, the fewer\n * directives that will share slots, and thus, the fewer false positives when checking for\n * the existence of a directive.\n */\nconst BLOOM_SIZE = 256;\nconst BLOOM_MASK = BLOOM_SIZE - 1;\n\n/** Counter used to generate unique IDs for directives. */\nlet nextNgElementId = 0;\n\n/**\n * Registers this directive as present in its node's injector by flipping the directive's\n * corresponding bit in the injector's bloom filter.\n *\n * @param injectorIndex The index of the node injector where this token should be registered\n * @param tView The TView for the injector's bloom filters\n * @param type The directive token to register\n */\nexport function bloomAdd(\n    injectorIndex: number, tView: TView, type: Type<any>| InjectionToken<any>| string): void {\n  ngDevMode && assertEqual(tView.firstCreatePass, true, 'expected firstCreatePass to be true');\n  let id: number|undefined =\n      typeof type !== 'string' ? (type as any)[NG_ELEMENT_ID] : type.charCodeAt(0) || 0;\n\n  // Set a unique ID on the directive type, so if something tries to inject the directive,\n  // we can easily retrieve the ID and hash it into the bloom bit that should be checked.\n  if (id == null) {\n    id = (type as any)[NG_ELEMENT_ID] = nextNgElementId++;\n  }\n\n  // We only have BLOOM_SIZE (256) slots in our bloom filter (8 buckets * 32 bits each),\n  // so all unique IDs must be modulo-ed into a number from 0 - 255 to fit into the filter.\n  const bloomBit = id & BLOOM_MASK;\n\n  // Create a mask that targets the specific bit associated with the directive.\n  // JS bit operations are 32 bits, so this will be a number between 2^0 and 2^31, corresponding\n  // to bit positions 0 - 31 in a 32 bit integer.\n  const mask = 1 << bloomBit;\n\n  // Use the raw bloomBit number to determine which bloom filter bucket we should check\n  // e.g: bf0 = [0 - 31], bf1 = [32 - 63], bf2 = [64 - 95], bf3 = [96 - 127], etc\n  const b7 = bloomBit & 0x80;\n  const b6 = bloomBit & 0x40;\n  const b5 = bloomBit & 0x20;\n  const tData = tView.data as number[];\n\n  if (b7) {\n    b6 ? (b5 ? (tData[injectorIndex + 7] |= mask) : (tData[injectorIndex + 6] |= mask)) :\n         (b5 ? (tData[injectorIndex + 5] |= mask) : (tData[injectorIndex + 4] |= mask));\n  } else {\n    b6 ? (b5 ? (tData[injectorIndex + 3] |= mask) : (tData[injectorIndex + 2] |= mask)) :\n         (b5 ? (tData[injectorIndex + 1] |= mask) : (tData[injectorIndex] |= mask));\n  }\n}\n\n/**\n * Creates (or gets an existing) injector for a given element or container.\n *\n * @param tNode for which an injector should be retrieved / created.\n * @param hostView View where the node is stored\n * @returns Node injector\n */\nexport function getOrCreateNodeInjectorForNode(\n    tNode: TElementNode | TContainerNode | TElementContainerNode, hostView: LView): number {\n  const existingInjectorIndex = getInjectorIndex(tNode, hostView);\n  if (existingInjectorIndex !== -1) {\n    return existingInjectorIndex;\n  }\n\n  const tView = hostView[TVIEW];\n  if (tView.firstCreatePass) {\n    tNode.injectorIndex = hostView.length;\n    insertBloom(tView.data, tNode);  // foundation for node bloom\n    insertBloom(hostView, null);     // foundation for cumulative bloom\n    insertBloom(tView.blueprint, null);\n  }\n\n  const parentLoc = getParentInjectorLocation(tNode, hostView);\n  const injectorIndex = tNode.injectorIndex;\n\n  // If a parent injector can't be found, its location is set to -1.\n  // In that case, we don't need to set up a cumulative bloom\n  if (hasParentInjector(parentLoc)) {\n    const parentIndex = getParentInjectorIndex(parentLoc);\n    const parentLView = getParentInjectorView(parentLoc, hostView);\n    const parentData = parentLView[TVIEW].data as any;\n    // Creates a cumulative bloom filter that merges the parent's bloom filter\n    // and its own cumulative bloom (which contains tokens for all ancestors)\n    for (let i = 0; i < 8; i++) {\n      hostView[injectorIndex + i] = parentLView[parentIndex + i] | parentData[parentIndex + i];\n    }\n  }\n\n  hostView[injectorIndex + PARENT_INJECTOR] = parentLoc;\n  return injectorIndex;\n}\n\nfunction insertBloom(arr: any[], footer: TNode | null): void {\n  arr.push(0, 0, 0, 0, 0, 0, 0, 0, footer);\n}\n\n\nexport function getInjectorIndex(tNode: TNode, hostView: LView): number {\n  if (tNode.injectorIndex === -1 ||\n      // If the injector index is the same as its parent's injector index, then the index has been\n      // copied down from the parent node. No injector has been created yet on this node.\n      (tNode.parent && tNode.parent.injectorIndex === tNode.injectorIndex) ||\n      // After the first template pass, the injector index might exist but the parent values\n      // might not have been calculated yet for this instance\n      hostView[tNode.injectorIndex + PARENT_INJECTOR] == null) {\n    return -1;\n  } else {\n    return tNode.injectorIndex;\n  }\n}\n\n/**\n * Finds the index of the parent injector, with a view offset if applicable. Used to set the\n * parent injector initially.\n *\n * Returns a combination of number of `ViewData` we have to go up and index in that `Viewdata`\n */\nexport function getParentInjectorLocation(tNode: TNode, view: LView): RelativeInjectorLocation {\n  if (tNode.parent && tNode.parent.injectorIndex !== -1) {\n    return tNode.parent.injectorIndex as any;  // ViewOffset is 0\n  }\n\n  // For most cases, the parent injector index can be found on the host node (e.g. for component\n  // or container), so this loop will be skipped, but we must keep the loop here to support\n  // the rarer case of deeply nested <ng-template> tags or inline views.\n  let hostTNode = view[T_HOST];\n  let viewOffset = 1;\n  while (hostTNode && hostTNode.injectorIndex === -1) {\n    view = view[DECLARATION_VIEW] !;\n    hostTNode = view ? view[T_HOST] : null;\n    viewOffset++;\n  }\n\n  return hostTNode ?\n      hostTNode.injectorIndex | (viewOffset << RelativeInjectorLocationFlags.ViewOffsetShift) :\n      -1 as any;\n}\n\n/**\n * Makes a type or an injection token public to the DI system by adding it to an\n * injector's bloom filter.\n *\n * @param di The node injector in which a directive will be added\n * @param token The type or the injection token to be made public\n */\nexport function diPublicInInjector(\n    injectorIndex: number, tView: TView, token: InjectionToken<any>| Type<any>): void {\n  bloomAdd(injectorIndex, tView, token);\n}\n\n/**\n * Inject static attribute value into directive constructor.\n *\n * This method is used with `factory` functions which are generated as part of\n * `defineDirective` or `defineComponent`. The method retrieves the static value\n * of an attribute. (Dynamic attributes are not supported since they are not resolved\n *  at the time of injection and can change over time.)\n *\n * # Example\n * Given:\n * ```\n * @Component(...)\n * class MyComponent {\n *   constructor(@Attribute('title') title: string) { ... }\n * }\n * ```\n * When instantiated with\n * ```\n * <my-component title=\"Hello\"></my-component>\n * ```\n *\n * Then factory method generated is:\n * ```\n * MyComponent.Éµcmp = defineComponent({\n *   factory: () => new MyComponent(injectAttribute('title'))\n *   ...\n * })\n * ```\n *\n * @publicApi\n */\nexport function injectAttributeImpl(tNode: TNode, attrNameToInject: string): string|null {\n  ngDevMode && assertNodeOfPossibleTypes(\n                   tNode, TNodeType.Container, TNodeType.Element, TNodeType.ElementContainer);\n  ngDevMode && assertDefined(tNode, 'expecting tNode');\n  if (attrNameToInject === 'class') {\n    return tNode.classes;\n  }\n  if (attrNameToInject === 'style') {\n    return tNode.styles;\n  }\n\n  const attrs = tNode.attrs;\n  if (attrs) {\n    const attrsLength = attrs.length;\n    let i = 0;\n    while (i < attrsLength) {\n      const value = attrs[i];\n\n      // If we hit a `Bindings` or `Template` marker then we are done.\n      if (isNameOnlyAttributeMarker(value)) break;\n\n      // Skip namespaced attributes\n      if (value === AttributeMarker.NamespaceURI) {\n        // we skip the next two values\n        // as namespaced attributes looks like\n        // [..., AttributeMarker.NamespaceURI, 'http://someuri.com/test', 'test:exist',\n        // 'existValue', ...]\n        i = i + 2;\n      } else if (typeof value === 'number') {\n        // Skip to the first value of the marked attribute.\n        i++;\n        while (i < attrsLength && typeof attrs[i] === 'string') {\n          i++;\n        }\n      } else if (value === attrNameToInject) {\n        return attrs[i + 1] as string;\n      } else {\n        i = i + 2;\n      }\n    }\n  }\n  return null;\n}\n\n\n/**\n * Returns the value associated to the given token from the NodeInjectors => ModuleInjector.\n *\n * Look for the injector providing the token by walking up the node injector tree and then\n * the module injector tree.\n *\n * This function patches `token` with `__NG_ELEMENT_ID__` which contains the id for the bloom\n * filter. Negative values are reserved for special objects.\n *   - `-1` is reserved for injecting `Injector` (implemented by `NodeInjector`)\n *\n * @param tNode The Node where the search for the injector should start\n * @param lView The `LView` that contains the `tNode`\n * @param token The token to look for\n * @param flags Injection flags\n * @param notFoundValue The value to return when the injection flags is `InjectFlags.Optional`\n * @returns the value from the injector, `null` when not found, or `notFoundValue` if provided\n */\nexport function getOrCreateInjectable<T>(\n    tNode: TDirectiveHostNode | null, lView: LView, token: Type<T>| InjectionToken<T>,\n    flags: InjectFlags = InjectFlags.Default, notFoundValue?: any): T|null {\n  if (tNode !== null) {\n    const bloomHash = bloomHashBitOrFactory(token);\n    // If the ID stored here is a function, this is a special object like ElementRef or TemplateRef\n    // so just call the factory function to create it.\n    if (typeof bloomHash === 'function') {\n      enterDI(lView, tNode);\n      try {\n        const value = bloomHash();\n        if (value == null && !(flags & InjectFlags.Optional)) {\n          throw new Error(`No provider for ${stringifyForError(token)}!`);\n        } else {\n          return value;\n        }\n      } finally {\n        leaveDI();\n      }\n    } else if (typeof bloomHash == 'number') {\n      if (bloomHash === -1) {\n        // `-1` is a special value used to identify `Injector` types.\n        return new NodeInjector(tNode, lView) as any;\n      }\n      // If the token has a bloom hash, then it is a token which could be in NodeInjector.\n\n      // A reference to the previous injector TView that was found while climbing the element\n      // injector tree. This is used to know if viewProviders can be accessed on the current\n      // injector.\n      let previousTView: TView|null = null;\n      let injectorIndex = getInjectorIndex(tNode, lView);\n      let parentLocation: RelativeInjectorLocation = NO_PARENT_INJECTOR;\n      let hostTElementNode: TNode|null =\n          flags & InjectFlags.Host ? lView[DECLARATION_COMPONENT_VIEW][T_HOST] : null;\n\n      // If we should skip this injector, or if there is no injector on this node, start by\n      // searching\n      // the parent injector.\n      if (injectorIndex === -1 || flags & InjectFlags.SkipSelf) {\n        parentLocation = injectorIndex === -1 ? getParentInjectorLocation(tNode, lView) :\n                                                lView[injectorIndex + PARENT_INJECTOR];\n\n        if (!shouldSearchParent(flags, false)) {\n          injectorIndex = -1;\n        } else {\n          previousTView = lView[TVIEW];\n          injectorIndex = getParentInjectorIndex(parentLocation);\n          lView = getParentInjectorView(parentLocation, lView);\n        }\n      }\n\n      // Traverse up the injector tree until we find a potential match or until we know there\n      // *isn't* a match.\n      while (injectorIndex !== -1) {\n        parentLocation = lView[injectorIndex + PARENT_INJECTOR];\n\n        // Check the current injector. If it matches, see if it contains token.\n        const tView = lView[TVIEW];\n        if (bloomHasToken(bloomHash, injectorIndex, tView.data)) {\n          // At this point, we have an injector which *may* contain the token, so we step through\n          // the providers and directives associated with the injector's corresponding node to get\n          // the instance.\n          const instance: T|null = searchTokensOnInjector<T>(\n              injectorIndex, lView, token, previousTView, flags, hostTElementNode);\n          if (instance !== NOT_FOUND) {\n            return instance;\n          }\n        }\n        if (shouldSearchParent(\n                flags, lView[TVIEW].data[injectorIndex + TNODE] === hostTElementNode) &&\n            bloomHasToken(bloomHash, injectorIndex, lView)) {\n          // The def wasn't found anywhere on this node, so it was a false positive.\n          // Traverse up the tree and continue searching.\n          previousTView = tView;\n          injectorIndex = getParentInjectorIndex(parentLocation);\n          lView = getParentInjectorView(parentLocation, lView);\n        } else {\n          // If we should not search parent OR If the ancestor bloom filter value does not have the\n          // bit corresponding to the directive we can give up on traversing up to find the specific\n          // injector.\n          injectorIndex = -1;\n        }\n      }\n    }\n  }\n\n  if (flags & InjectFlags.Optional && notFoundValue === undefined) {\n    // This must be set or the NullInjector will throw for optional deps\n    notFoundValue = null;\n  }\n\n  if ((flags & (InjectFlags.Self | InjectFlags.Host)) === 0) {\n    const moduleInjector = lView[INJECTOR];\n    // switch to `injectInjectorOnly` implementation for module injector, since module injector\n    // should not have access to Component/Directive DI scope (that may happen through\n    // `directiveInject` implementation)\n    const previousInjectImplementation = setInjectImplementation(undefined);\n    try {\n      if (moduleInjector) {\n        return moduleInjector.get(token, notFoundValue, flags & InjectFlags.Optional);\n      } else {\n        return injectRootLimpMode(token, notFoundValue, flags & InjectFlags.Optional);\n      }\n    } finally {\n      setInjectImplementation(previousInjectImplementation);\n    }\n  }\n  if (flags & InjectFlags.Optional) {\n    return notFoundValue;\n  } else {\n    throw new Error(`NodeInjector: NOT_FOUND [${stringifyForError(token)}]`);\n  }\n}\n\nconst NOT_FOUND = {};\n\nfunction searchTokensOnInjector<T>(\n    injectorIndex: number, lView: LView, token: Type<T>| InjectionToken<T>,\n    previousTView: TView | null, flags: InjectFlags, hostTElementNode: TNode | null) {\n  const currentTView = lView[TVIEW];\n  const tNode = currentTView.data[injectorIndex + TNODE] as TNode;\n  // First, we need to determine if view providers can be accessed by the starting element.\n  // There are two possibities\n  const canAccessViewProviders = previousTView == null ?\n      // 1) This is the first invocation `previousTView == null` which means that we are at the\n      // `TNode` of where injector is starting to look. In such a case the only time we are allowed\n      // to look into the ViewProviders is if:\n      // - we are on a component\n      // - AND the injector set `includeViewProviders` to true (implying that the token can see\n      // ViewProviders because it is the Component or a Service which itself was declared in\n      // ViewProviders)\n      (isComponentHost(tNode) && includeViewProviders) :\n      // 2) `previousTView != null` which means that we are now walking across the parent nodes.\n      // In such a case we are only allowed to look into the ViewProviders if:\n      // - We just crossed from child View to Parent View `previousTView != currentTView`\n      // - AND the parent TNode is an Element.\n      // This means that we just came from the Component's View and therefore are allowed to see\n      // into the ViewProviders.\n      (previousTView != currentTView && (tNode.type === TNodeType.Element));\n\n  // This special case happens when there is a @host on the inject and when we are searching\n  // on the host element node.\n  const isHostSpecialCase = (flags & InjectFlags.Host) && hostTElementNode === tNode;\n\n  const injectableIdx = locateDirectiveOrProvider(\n      tNode, currentTView, token, canAccessViewProviders, isHostSpecialCase);\n  if (injectableIdx !== null) {\n    return getNodeInjectable(lView, currentTView, injectableIdx, tNode as TElementNode);\n  } else {\n    return NOT_FOUND;\n  }\n}\n\n/**\n * Searches for the given token among the node's directives and providers.\n *\n * @param tNode TNode on which directives are present.\n * @param tView The tView we are currently processing\n * @param token Provider token or type of a directive to look for.\n * @param canAccessViewProviders Whether view providers should be considered.\n * @param isHostSpecialCase Whether the host special case applies.\n * @returns Index of a found directive or provider, or null when none found.\n */\nexport function locateDirectiveOrProvider<T>(\n    tNode: TNode, tView: TView, token: Type<T>| InjectionToken<T>, canAccessViewProviders: boolean,\n    isHostSpecialCase: boolean | number): number|null {\n  const nodeProviderIndexes = tNode.providerIndexes;\n  const tInjectables = tView.data;\n\n  const injectablesStart = nodeProviderIndexes & TNodeProviderIndexes.ProvidersStartIndexMask;\n  const directivesStart = tNode.directiveStart;\n  const directiveEnd = tNode.directiveEnd;\n  const cptViewProvidersCount =\n      nodeProviderIndexes >> TNodeProviderIndexes.CptViewProvidersCountShift;\n  const startingIndex =\n      canAccessViewProviders ? injectablesStart : injectablesStart + cptViewProvidersCount;\n  // When the host special case applies, only the viewProviders and the component are visible\n  const endIndex = isHostSpecialCase ? injectablesStart + cptViewProvidersCount : directiveEnd;\n  for (let i = startingIndex; i < endIndex; i++) {\n    const providerTokenOrDef = tInjectables[i] as InjectionToken<any>| Type<any>| DirectiveDef<any>;\n    if (i < directivesStart && token === providerTokenOrDef ||\n        i >= directivesStart && (providerTokenOrDef as DirectiveDef<any>).type === token) {\n      return i;\n    }\n  }\n  if (isHostSpecialCase) {\n    const dirDef = tInjectables[directivesStart] as DirectiveDef<any>;\n    if (dirDef && isComponentDef(dirDef) && dirDef.type === token) {\n      return directivesStart;\n    }\n  }\n  return null;\n}\n\n/**\n* Retrieve or instantiate the injectable from the `LView` at particular `index`.\n*\n* This function checks to see if the value has already been instantiated and if so returns the\n* cached `injectable`. Otherwise if it detects that the value is still a factory it\n* instantiates the `injectable` and caches the value.\n*/\nexport function getNodeInjectable(\n    lView: LView, tView: TView, index: number, tNode: TDirectiveHostNode): any {\n  let value = lView[index];\n  const tData = tView.data;\n  if (isFactory(value)) {\n    const factory: NodeInjectorFactory = value;\n    if (factory.resolving) {\n      throw new Error(`Circular dep for ${stringifyForError(tData[index])}`);\n    }\n    const previousIncludeViewProviders = setIncludeViewProviders(factory.canSeeViewProviders);\n    factory.resolving = true;\n    let previousInjectImplementation;\n    if (factory.injectImpl) {\n      previousInjectImplementation = setInjectImplementation(factory.injectImpl);\n    }\n    enterDI(lView, tNode);\n    try {\n      value = lView[index] = factory.factory(undefined, tData, lView, tNode);\n      // This code path is hit for both directives and providers.\n      // For perf reasons, we want to avoid searching for hooks on providers.\n      // It does no harm to try (the hooks just won't exist), but the extra\n      // checks are unnecessary and this is a hot path. So we check to see\n      // if the index of the dependency is in the directive range for this\n      // tNode. If it's not, we know it's a provider and skip hook registration.\n      if (tView.firstCreatePass && index >= tNode.directiveStart) {\n        ngDevMode && assertDirectiveDef(tData[index]);\n        registerPreOrderHooks(index, tData[index] as DirectiveDef<any>, tView);\n      }\n    } finally {\n      if (factory.injectImpl) setInjectImplementation(previousInjectImplementation);\n      setIncludeViewProviders(previousIncludeViewProviders);\n      factory.resolving = false;\n      leaveDI();\n    }\n  }\n  return value;\n}\n\n/**\n * Returns the bit in an injector's bloom filter that should be used to determine whether or not\n * the directive might be provided by the injector.\n *\n * When a directive is public, it is added to the bloom filter and given a unique ID that can be\n * retrieved on the Type. When the directive isn't public or the token is not a directive `null`\n * is returned as the node injector can not possibly provide that token.\n *\n * @param token the injection token\n * @returns the matching bit to check in the bloom filter or `null` if the token is not known.\n *   When the returned value is negative then it represents special values such as `Injector`.\n */\nexport function bloomHashBitOrFactory(token: Type<any>| InjectionToken<any>| string): number|\n    Function|undefined {\n  ngDevMode && assertDefined(token, 'token must be defined');\n  if (typeof token === 'string') {\n    return token.charCodeAt(0) || 0;\n  }\n  const tokenId: number|undefined = (token as any)[NG_ELEMENT_ID];\n  // Negative token IDs are used for special objects such as `Injector`\n  return (typeof tokenId === 'number' && tokenId > 0) ? tokenId & BLOOM_MASK : tokenId;\n}\n\nexport function bloomHasToken(\n    bloomHash: number, injectorIndex: number, injectorView: LView | TData) {\n  // Create a mask that targets the specific bit associated with the directive we're looking for.\n  // JS bit operations are 32 bits, so this will be a number between 2^0 and 2^31, corresponding\n  // to bit positions 0 - 31 in a 32 bit integer.\n  const mask = 1 << bloomHash;\n  const b7 = bloomHash & 0x80;\n  const b6 = bloomHash & 0x40;\n  const b5 = bloomHash & 0x20;\n\n  // Our bloom filter size is 256 bits, which is eight 32-bit bloom filter buckets:\n  // bf0 = [0 - 31], bf1 = [32 - 63], bf2 = [64 - 95], bf3 = [96 - 127], etc.\n  // Get the bloom filter value from the appropriate bucket based on the directive's bloomBit.\n  let value: number;\n\n  if (b7) {\n    value = b6 ? (b5 ? injectorView[injectorIndex + 7] : injectorView[injectorIndex + 6]) :\n                 (b5 ? injectorView[injectorIndex + 5] : injectorView[injectorIndex + 4]);\n  } else {\n    value = b6 ? (b5 ? injectorView[injectorIndex + 3] : injectorView[injectorIndex + 2]) :\n                 (b5 ? injectorView[injectorIndex + 1] : injectorView[injectorIndex]);\n  }\n\n  // If the bloom filter value has the bit corresponding to the directive's bloomBit flipped on,\n  // this injector is a potential match.\n  return !!(value & mask);\n}\n\n/** Returns true if flags prevent parent injector from being searched for tokens */\nfunction shouldSearchParent(flags: InjectFlags, isFirstHostTNode: boolean): boolean|number {\n  return !(flags & InjectFlags.Self) && !(flags & InjectFlags.Host && isFirstHostTNode);\n}\n\nexport class NodeInjector implements Injector {\n  constructor(\n      private _tNode: TElementNode|TContainerNode|TElementContainerNode|null,\n      private _lView: LView) {}\n\n  get(token: any, notFoundValue?: any): any {\n    return getOrCreateInjectable(this._tNode, this._lView, token, undefined, notFoundValue);\n  }\n}\n\n/**\n * @codeGenApi\n */\nexport function ÉµÉµgetFactoryOf<T>(type: Type<any>): FactoryFn<T>|null {\n  const typeAny = type as any;\n\n  if (isForwardRef(type)) {\n    return (() => {\n      const factory = ÉµÉµgetFactoryOf<T>(resolveForwardRef(typeAny));\n      return factory ? factory() : null;\n    }) as any;\n  }\n\n  let factory = getFactoryDef<T>(typeAny);\n  if (factory === null) {\n    const injectorDef = getInjectorDef<T>(typeAny);\n    factory = injectorDef && injectorDef.factory;\n  }\n  return factory || null;\n}\n\n/**\n * @codeGenApi\n */\nexport function ÉµÉµgetInheritedFactory<T>(type: Type<any>): (type: Type<T>) => T {\n  const proto = Object.getPrototypeOf(type.prototype).constructor as Type<any>;\n  const factory = (proto as any)[NG_FACTORY_DEF] || ÉµÉµgetFactoryOf<T>(proto);\n  if (factory !== null) {\n    return factory;\n  } else {\n    // There is no factory defined. Either this was improper usage of inheritance\n    // (no Angular decorator on the superclass) or there is no constructor at all\n    // in the inheritance chain. Since the two cases cannot be distinguished, the\n    // latter has to be assumed.\n    return (t) => new t();\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nexport const ERROR_TYPE = 'ngType';\nexport const ERROR_DEBUG_CONTEXT = 'ngDebugContext';\nexport const ERROR_ORIGINAL_ERROR = 'ngOriginalError';\nexport const ERROR_LOGGER = 'ngErrorLogger';\n\n\nexport function wrappedError(message: string, originalError: any): Error {\n  const msg =\n      `${message} caused by: ${originalError instanceof Error ? originalError.message: originalError }`;\n  const error = Error(msg);\n  (error as any)[ERROR_ORIGINAL_ERROR] = originalError;\n  return error;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ERROR_DEBUG_CONTEXT, ERROR_LOGGER, ERROR_ORIGINAL_ERROR, ERROR_TYPE} from './util/errors';\nimport {DebugContext} from './view';\n\nexport function getType(error: Error): Function {\n  return (error as any)[ERROR_TYPE];\n}\n\nexport function getDebugContext(error: Error): DebugContext {\n  return (error as any)[ERROR_DEBUG_CONTEXT];\n}\n\nexport function getOriginalError(error: Error): Error {\n  return (error as any)[ERROR_ORIGINAL_ERROR];\n}\n\nexport function getErrorLogger(error: Error): (console: Console, ...values: any[]) => void {\n  return (error as any)[ERROR_LOGGER] || defaultErrorLogger;\n}\n\n\nfunction defaultErrorLogger(console: Console, ...values: any[]) {\n  (<any>console.error)(...values);\n}","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {getDebugContext, getErrorLogger, getOriginalError} from './errors';\n\n\n\n/**\n * Provides a hook for centralized exception handling.\n *\n * The default implementation of `ErrorHandler` prints error messages to the `console`. To\n * intercept error handling, write a custom exception handler that replaces this default as\n * appropriate for your app.\n *\n * @usageNotes\n * ### Example\n *\n * ```\n * class MyErrorHandler implements ErrorHandler {\n *   handleError(error) {\n *     // do something with the exception\n *   }\n * }\n *\n * @NgModule({\n *   providers: [{provide: ErrorHandler, useClass: MyErrorHandler}]\n * })\n * class MyModule {}\n * ```\n *\n * @publicApi\n */\nexport class ErrorHandler {\n  /**\n   * @internal\n   */\n  _console: Console = console;\n\n  handleError(error: any): void {\n    const originalError = this._findOriginalError(error);\n    const context = this._findContext(error);\n    // Note: Browser consoles show the place from where console.error was called.\n    // We can use this to give users additional information about the error.\n    const errorLogger = getErrorLogger(error);\n\n    errorLogger(this._console, `ERROR`, error);\n    if (originalError) {\n      errorLogger(this._console, `ORIGINAL ERROR`, originalError);\n    }\n    if (context) {\n      errorLogger(this._console, 'ERROR CONTEXT', context);\n    }\n  }\n\n  /** @internal */\n  _findContext(error: any): any {\n    if (error) {\n      return getDebugContext(error) ? getDebugContext(error) :\n                                      this._findContext(getOriginalError(error));\n    }\n\n    return null;\n  }\n\n  /** @internal */\n  _findOriginalError(error: Error): any {\n    let e = getOriginalError(error);\n    while (e && getOriginalError(e)) {\n      e = getOriginalError(e);\n    }\n\n    return e;\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\n/**\n * A schema definition associated with an NgModule.\n *\n * @see `@NgModule`, `CUSTOM_ELEMENTS_SCHEMA`, `NO_ERRORS_SCHEMA`\n *\n * @param name The name of a defined schema.\n *\n * @publicApi\n */\nexport interface SchemaMetadata { name: string; }\n\n/**\n * Defines a schema that allows an NgModule to contain the following:\n * - Non-Angular elements named with dash case (`-`).\n * - Element properties named with dash case (`-`).\n * Dash case is the naming convention for custom elements.\n *\n * @publicApi\n */\nexport const CUSTOM_ELEMENTS_SCHEMA: SchemaMetadata = {\n  name: 'custom-elements'\n};\n\n/**\n * Defines a schema that allows any property on any element.\n *\n * @publicApi\n */\nexport const NO_ERRORS_SCHEMA: SchemaMetadata = {\n  name: 'no-errors-schema'\n};\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nexport const enum BypassType {\n  Url = 'URL',\n  Html = 'HTML',\n  ResourceUrl = 'ResourceURL',\n  Script = 'Script',\n  Style = 'Style',\n}\n\n/**\n * Marker interface for a value that's safe to use in a particular context.\n *\n * @publicApi\n */\nexport interface SafeValue {}\n\n/**\n * Marker interface for a value that's safe to use as HTML.\n *\n * @publicApi\n */\nexport interface SafeHtml extends SafeValue {}\n\n/**\n * Marker interface for a value that's safe to use as style (CSS).\n *\n * @publicApi\n */\nexport interface SafeStyle extends SafeValue {}\n\n/**\n * Marker interface for a value that's safe to use as JavaScript.\n *\n * @publicApi\n */\nexport interface SafeScript extends SafeValue {}\n\n/**\n * Marker interface for a value that's safe to use as a URL linking to a document.\n *\n * @publicApi\n */\nexport interface SafeUrl extends SafeValue {}\n\n/**\n * Marker interface for a value that's safe to use as a URL to load executable code from.\n *\n * @publicApi\n */\nexport interface SafeResourceUrl extends SafeValue {}\n\n\nabstract class SafeValueImpl implements SafeValue {\n  constructor(public changingThisBreaksApplicationSecurity: string) {}\n\n  abstract getTypeName(): string;\n\n  toString() {\n    return `SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity}` +\n        ` (see http://g.co/ng/security#xss)`;\n  }\n}\n\nclass SafeHtmlImpl extends SafeValueImpl implements SafeHtml {\n  getTypeName() { return BypassType.Html; }\n}\nclass SafeStyleImpl extends SafeValueImpl implements SafeStyle {\n  getTypeName() { return BypassType.Style; }\n}\nclass SafeScriptImpl extends SafeValueImpl implements SafeScript {\n  getTypeName() { return BypassType.Script; }\n}\nclass SafeUrlImpl extends SafeValueImpl implements SafeUrl {\n  getTypeName() { return BypassType.Url; }\n}\nclass SafeResourceUrlImpl extends SafeValueImpl implements SafeResourceUrl {\n  getTypeName() { return BypassType.ResourceUrl; }\n}\n\nexport function unwrapSafeValue(value: SafeValue): string;\nexport function unwrapSafeValue<T>(value: T): T;\nexport function unwrapSafeValue<T>(value: T | SafeValue): T {\n  return value instanceof SafeValueImpl ? value.changingThisBreaksApplicationSecurity as any as T :\n                                          value as any as T;\n}\n\n\nexport function allowSanitizationBypassAndThrow(\n    value: any, type: BypassType.Html): value is SafeHtml;\nexport function allowSanitizationBypassAndThrow(\n    value: any, type: BypassType.ResourceUrl): value is SafeResourceUrl;\nexport function allowSanitizationBypassAndThrow(\n    value: any, type: BypassType.Script): value is SafeScript;\nexport function allowSanitizationBypassAndThrow(\n    value: any, type: BypassType.Style): value is SafeStyle;\nexport function allowSanitizationBypassAndThrow(value: any, type: BypassType.Url): value is SafeUrl;\nexport function allowSanitizationBypassAndThrow(value: any, type: BypassType): boolean;\nexport function allowSanitizationBypassAndThrow(value: any, type: BypassType): boolean {\n  const actualType = getSanitizationBypassType(value);\n  if (actualType != null && actualType !== type) {\n    // Allow ResourceURLs in URL contexts, they are strictly more trusted.\n    if (actualType === BypassType.ResourceUrl && type === BypassType.Url) return true;\n    throw new Error(\n        `Required a safe ${type}, got a ${actualType} (see http://g.co/ng/security#xss)`);\n  }\n  return actualType === type;\n}\n\nexport function getSanitizationBypassType(value: any): BypassType|null {\n  return value instanceof SafeValueImpl && value.getTypeName() as BypassType || null;\n}\n\n/**\n * Mark `html` string as trusted.\n *\n * This function wraps the trusted string in `String` and brands it in a way which makes it\n * recognizable to {@link htmlSanitizer} to be trusted implicitly.\n *\n * @param trustedHtml `html` string which needs to be implicitly trusted.\n * @returns a `html` which has been branded to be implicitly trusted.\n */\nexport function bypassSanitizationTrustHtml(trustedHtml: string): SafeHtml {\n  return new SafeHtmlImpl(trustedHtml);\n}\n/**\n * Mark `style` string as trusted.\n *\n * This function wraps the trusted string in `String` and brands it in a way which makes it\n * recognizable to {@link styleSanitizer} to be trusted implicitly.\n *\n * @param trustedStyle `style` string which needs to be implicitly trusted.\n * @returns a `style` hich has been branded to be implicitly trusted.\n */\nexport function bypassSanitizationTrustStyle(trustedStyle: string): SafeStyle {\n  return new SafeStyleImpl(trustedStyle);\n}\n/**\n * Mark `script` string as trusted.\n *\n * This function wraps the trusted string in `String` and brands it in a way which makes it\n * recognizable to {@link scriptSanitizer} to be trusted implicitly.\n *\n * @param trustedScript `script` string which needs to be implicitly trusted.\n * @returns a `script` which has been branded to be implicitly trusted.\n */\nexport function bypassSanitizationTrustScript(trustedScript: string): SafeScript {\n  return new SafeScriptImpl(trustedScript);\n}\n/**\n * Mark `url` string as trusted.\n *\n * This function wraps the trusted string in `String` and brands it in a way which makes it\n * recognizable to {@link urlSanitizer} to be trusted implicitly.\n *\n * @param trustedUrl `url` string which needs to be implicitly trusted.\n * @returns a `url`  which has been branded to be implicitly trusted.\n */\nexport function bypassSanitizationTrustUrl(trustedUrl: string): SafeUrl {\n  return new SafeUrlImpl(trustedUrl);\n}\n/**\n * Mark `url` string as trusted.\n *\n * This function wraps the trusted string in `String` and brands it in a way which makes it\n * recognizable to {@link resourceUrlSanitizer} to be trusted implicitly.\n *\n * @param trustedResourceUrl `url` string which needs to be implicitly trusted.\n * @returns a `url` which has been branded to be implicitly trusted.\n */\nexport function bypassSanitizationTrustResourceUrl(trustedResourceUrl: string): SafeResourceUrl {\n  return new SafeResourceUrlImpl(trustedResourceUrl);\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * This file is used to control if the default rendering pipeline should be `ViewEngine` or `Ivy`.\n *\n * For more information on how to run and debug tests with either Ivy or View Engine (legacy),\n * please see [BAZEL.md](./docs/BAZEL.md).\n */\n\nlet _devMode: boolean = true;\nlet _runModeLocked: boolean = false;\n\n\n/**\n * Returns whether Angular is in development mode. After called once,\n * the value is locked and won't change any more.\n *\n * By default, this is true, unless a user calls `enableProdMode` before calling this.\n *\n * @publicApi\n */\nexport function isDevMode(): boolean {\n  _runModeLocked = true;\n  return _devMode;\n}\n\n/**\n * Disable Angular's development mode, which turns off assertions and other\n * checks within the framework.\n *\n * One important assertion this disables verifies that a change detection pass\n * does not result in additional changes to any bindings (also known as\n * unidirectional data flow).\n *\n * @publicApi\n */\nexport function enableProdMode(): void {\n  if (_runModeLocked) {\n    throw new Error('Cannot enable prod mode after platform setup.');\n  }\n  _devMode = false;\n}","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * This helper class is used to get hold of an inert tree of DOM elements containing dirty HTML\n * that needs sanitizing.\n * Depending upon browser support we must use one of three strategies for doing this.\n * Support: Safari 10.x -> XHR strategy\n * Support: Firefox -> DomParser strategy\n * Default: InertDocument strategy\n */\nexport class InertBodyHelper {\n  private inertDocument: Document;\n\n  constructor(private defaultDoc: Document) {\n    this.inertDocument = this.defaultDoc.implementation.createHTMLDocument('sanitization-inert');\n    let inertBodyElement = this.inertDocument.body;\n\n    if (inertBodyElement == null) {\n      // usually there should be only one body element in the document, but IE doesn't have any, so\n      // we need to create one.\n      const inertHtml = this.inertDocument.createElement('html');\n      this.inertDocument.appendChild(inertHtml);\n      inertBodyElement = this.inertDocument.createElement('body');\n      inertHtml.appendChild(inertBodyElement);\n    }\n\n    inertBodyElement.innerHTML = '<svg><g onload=\"this.parentNode.remove()\"></g></svg>';\n    if (inertBodyElement.querySelector && !inertBodyElement.querySelector('svg')) {\n      // We just hit the Safari 10.1 bug - which allows JS to run inside the SVG G element\n      // so use the XHR strategy.\n      this.getInertBodyElement = this.getInertBodyElement_XHR;\n      return;\n    }\n\n    inertBodyElement.innerHTML = '<svg><p><style><img src=\"</style><img src=x onerror=alert(1)//\">';\n    if (inertBodyElement.querySelector && inertBodyElement.querySelector('svg img')) {\n      // We just hit the Firefox bug - which prevents the inner img JS from being sanitized\n      // so use the DOMParser strategy, if it is available.\n      // If the DOMParser is not available then we are not in Firefox (Server/WebWorker?) so we\n      // fall through to the default strategy below.\n      if (isDOMParserAvailable()) {\n        this.getInertBodyElement = this.getInertBodyElement_DOMParser;\n        return;\n      }\n    }\n\n    // None of the bugs were hit so it is safe for us to use the default InertDocument strategy\n    this.getInertBodyElement = this.getInertBodyElement_InertDocument;\n  }\n\n  /**\n   * Get an inert DOM element containing DOM created from the dirty HTML string provided.\n   * The implementation of this is determined in the constructor, when the class is instantiated.\n   */\n  getInertBodyElement: (html: string) => HTMLElement | null;\n\n  /**\n   * Use XHR to create and fill an inert body element (on Safari 10.1)\n   * See\n   * https://github.com/cure53/DOMPurify/blob/a992d3a75031cb8bb032e5ea8399ba972bdf9a65/src/purify.js#L439-L449\n   */\n  private getInertBodyElement_XHR(html: string) {\n    // We add these extra elements to ensure that the rest of the content is parsed as expected\n    // e.g. leading whitespace is maintained and tags like `<meta>` do not get hoisted to the\n    // `<head>` tag.\n    html = '<body><remove></remove>' + html + '</body>';\n    try {\n      html = encodeURI(html);\n    } catch {\n      return null;\n    }\n    const xhr = new XMLHttpRequest();\n    xhr.responseType = 'document';\n    xhr.open('GET', 'data:text/html;charset=utf-8,' + html, false);\n    xhr.send(undefined);\n    const body: HTMLBodyElement = xhr.response.body;\n    body.removeChild(body.firstChild !);\n    return body;\n  }\n\n  /**\n   * Use DOMParser to create and fill an inert body element (on Firefox)\n   * See https://github.com/cure53/DOMPurify/releases/tag/0.6.7\n   *\n   */\n  private getInertBodyElement_DOMParser(html: string) {\n    // We add these extra elements to ensure that the rest of the content is parsed as expected\n    // e.g. leading whitespace is maintained and tags like `<meta>` do not get hoisted to the\n    // `<head>` tag.\n    html = '<body><remove></remove>' + html + '</body>';\n    try {\n      const body = new (window as any)\n                       .DOMParser()\n                       .parseFromString(html, 'text/html')\n                       .body as HTMLBodyElement;\n      body.removeChild(body.firstChild !);\n      return body;\n    } catch {\n      return null;\n    }\n  }\n\n  /**\n   * Use an HTML5 `template` element, if supported, or an inert body element created via\n   * `createHtmlDocument` to create and fill an inert DOM element.\n   * This is the default sane strategy to use if the browser does not require one of the specialised\n   * strategies above.\n   */\n  private getInertBodyElement_InertDocument(html: string) {\n    // Prefer using <template> element if supported.\n    const templateEl = this.inertDocument.createElement('template');\n    if ('content' in templateEl) {\n      templateEl.innerHTML = html;\n      return templateEl;\n    }\n\n    // Note that previously we used to do something like `this.inertDocument.body.innerHTML = html`\n    // and we returned the inert `body` node. This was changed, because IE seems to treat setting\n    // `innerHTML` on an inserted element differently, compared to one that hasn't been inserted\n    // yet. In particular, IE appears to split some of the text into multiple text nodes rather\n    // than keeping them in a single one which ends up messing with Ivy's i18n parsing further\n    // down the line. This has been worked around by creating a new inert `body` and using it as\n    // the root node in which we insert the HTML.\n    const inertBody = this.inertDocument.createElement('body');\n    inertBody.innerHTML = html;\n\n    // Support: IE 9-11 only\n    // strip custom-namespaced attributes on IE<=11\n    if ((this.defaultDoc as any).documentMode) {\n      this.stripCustomNsAttrs(inertBody);\n    }\n\n    return inertBody;\n  }\n\n  /**\n   * When IE9-11 comes across an unknown namespaced attribute e.g. 'xlink:foo' it adds 'xmlns:ns1'\n   * attribute to declare ns1 namespace and prefixes the attribute with 'ns1' (e.g.\n   * 'ns1:xlink:foo').\n   *\n   * This is undesirable since we don't want to allow any of these custom attributes. This method\n   * strips them all.\n   */\n  private stripCustomNsAttrs(el: Element) {\n    const elAttrs = el.attributes;\n    // loop backwards so that we can support removals.\n    for (let i = elAttrs.length - 1; 0 < i; i--) {\n      const attrib = elAttrs.item(i);\n      const attrName = attrib !.name;\n      if (attrName === 'xmlns:ns1' || attrName.indexOf('ns1:') === 0) {\n        el.removeAttribute(attrName);\n      }\n    }\n    let childNode = el.firstChild as Node | null;\n    while (childNode) {\n      if (childNode.nodeType === Node.ELEMENT_NODE) this.stripCustomNsAttrs(childNode as Element);\n      childNode = childNode.nextSibling;\n    }\n  }\n}\n\n/**\n * We need to determine whether the DOMParser exists in the global context.\n * The try-catch is because, on some browsers, trying to access this property\n * on window can actually throw an error.\n *\n * @suppress {uselessCode}\n */\nfunction isDOMParserAvailable() {\n  try {\n    return !!(window as any).DOMParser;\n  } catch {\n    return false;\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {isDevMode} from '../util/is_dev_mode';\n\n/**\n * A pattern that recognizes a commonly useful subset of URLs that are safe.\n *\n * This regular expression matches a subset of URLs that will not cause script\n * execution if used in URL context within a HTML document. Specifically, this\n * regular expression matches if (comment from here on and regex copied from\n * Soy's EscapingConventions):\n * (1) Either an allowed protocol (http, https, mailto or ftp).\n * (2) or no protocol.  A protocol must be followed by a colon. The below\n *     allows that by allowing colons only after one of the characters [/?#].\n *     A colon after a hash (#) must be in the fragment.\n *     Otherwise, a colon after a (?) must be in a query.\n *     Otherwise, a colon after a single solidus (/) must be in a path.\n *     Otherwise, a colon after a double solidus (//) must be in the authority\n *     (before port).\n *\n * The pattern disallows &, used in HTML entity declarations before\n * one of the characters in [/?#]. This disallows HTML entities used in the\n * protocol name, which should never happen, e.g. \"h&#116;tp\" for \"http\".\n * It also disallows HTML entities in the first path part of a relative path,\n * e.g. \"foo&lt;bar/baz\".  Our existing escaping functions should not produce\n * that. More importantly, it disallows masking of a colon,\n * e.g. \"javascript&#58;...\".\n *\n * This regular expression was taken from the Closure sanitization library.\n */\nconst SAFE_URL_PATTERN = /^(?:(?:https?|mailto|ftp|tel|file):|[^&:/?#]*(?:[/?#]|$))/gi;\n\n/* A pattern that matches safe srcset values */\nconst SAFE_SRCSET_PATTERN = /^(?:(?:https?|file):|[^&:/?#]*(?:[/?#]|$))/gi;\n\n/** A pattern that matches safe data URLs. Only matches image, video and audio types. */\nconst DATA_URL_PATTERN =\n    /^data:(?:image\\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\\/(?:mpeg|mp4|ogg|webm)|audio\\/(?:mp3|oga|ogg|opus));base64,[a-z0-9+\\/]+=*$/i;\n\nexport function _sanitizeUrl(url: string): string {\n  url = String(url);\n  if (url.match(SAFE_URL_PATTERN) || url.match(DATA_URL_PATTERN)) return url;\n\n  if (isDevMode()) {\n    console.warn(`WARNING: sanitizing unsafe URL value ${url} (see http://g.co/ng/security#xss)`);\n  }\n\n  return 'unsafe:' + url;\n}\n\nexport function sanitizeSrcset(srcset: string): string {\n  srcset = String(srcset);\n  return srcset.split(',').map((srcset) => _sanitizeUrl(srcset.trim())).join(', ');\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {isDevMode} from '../util/is_dev_mode';\nimport {InertBodyHelper} from './inert_body';\nimport {_sanitizeUrl, sanitizeSrcset} from './url_sanitizer';\n\nfunction tagSet(tags: string): {[k: string]: boolean} {\n  const res: {[k: string]: boolean} = {};\n  for (const t of tags.split(',')) res[t] = true;\n  return res;\n}\n\nfunction merge(...sets: {[k: string]: boolean}[]): {[k: string]: boolean} {\n  const res: {[k: string]: boolean} = {};\n  for (const s of sets) {\n    for (const v in s) {\n      if (s.hasOwnProperty(v)) res[v] = true;\n    }\n  }\n  return res;\n}\n\n// Good source of info about elements and attributes\n// http://dev.w3.org/html5/spec/Overview.html#semantics\n// http://simon.html5.org/html-elements\n\n// Safe Void Elements - HTML5\n// http://dev.w3.org/html5/spec/Overview.html#void-elements\nconst VOID_ELEMENTS = tagSet('area,br,col,hr,img,wbr');\n\n// Elements that you can, intentionally, leave open (and which close themselves)\n// http://dev.w3.org/html5/spec/Overview.html#optional-tags\nconst OPTIONAL_END_TAG_BLOCK_ELEMENTS = tagSet('colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr');\nconst OPTIONAL_END_TAG_INLINE_ELEMENTS = tagSet('rp,rt');\nconst OPTIONAL_END_TAG_ELEMENTS =\n    merge(OPTIONAL_END_TAG_INLINE_ELEMENTS, OPTIONAL_END_TAG_BLOCK_ELEMENTS);\n\n// Safe Block Elements - HTML5\nconst BLOCK_ELEMENTS = merge(\n    OPTIONAL_END_TAG_BLOCK_ELEMENTS,\n    tagSet(\n        'address,article,' +\n        'aside,blockquote,caption,center,del,details,dialog,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,' +\n        'h6,header,hgroup,hr,ins,main,map,menu,nav,ol,pre,section,summary,table,ul'));\n\n// Inline Elements - HTML5\nconst INLINE_ELEMENTS = merge(\n    OPTIONAL_END_TAG_INLINE_ELEMENTS,\n    tagSet(\n        'a,abbr,acronym,audio,b,' +\n        'bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,picture,q,ruby,rp,rt,s,' +\n        'samp,small,source,span,strike,strong,sub,sup,time,track,tt,u,var,video'));\n\nexport const VALID_ELEMENTS =\n    merge(VOID_ELEMENTS, BLOCK_ELEMENTS, INLINE_ELEMENTS, OPTIONAL_END_TAG_ELEMENTS);\n\n// Attributes that have href and hence need to be sanitized\nexport const URI_ATTRS = tagSet('background,cite,href,itemtype,longdesc,poster,src,xlink:href');\n\n// Attributes that have special href set hence need to be sanitized\nexport const SRCSET_ATTRS = tagSet('srcset');\n\nconst HTML_ATTRS = tagSet(\n    'abbr,accesskey,align,alt,autoplay,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,' +\n    'compact,controls,coords,datetime,default,dir,download,face,headers,height,hidden,hreflang,hspace,' +\n    'ismap,itemscope,itemprop,kind,label,lang,language,loop,media,muted,nohref,nowrap,open,preload,rel,rev,role,rows,rowspan,rules,' +\n    'scope,scrolling,shape,size,sizes,span,srclang,start,summary,tabindex,target,title,translate,type,usemap,' +\n    'valign,value,vspace,width');\n\n// Accessibility attributes as per WAI-ARIA 1.1 (W3C Working Draft 14 December 2018)\nconst ARIA_ATTRS = tagSet(\n    'aria-activedescendant,aria-atomic,aria-autocomplete,aria-busy,aria-checked,aria-colcount,aria-colindex,' +\n    'aria-colspan,aria-controls,aria-current,aria-describedby,aria-details,aria-disabled,aria-dropeffect,' +\n    'aria-errormessage,aria-expanded,aria-flowto,aria-grabbed,aria-haspopup,aria-hidden,aria-invalid,' +\n    'aria-keyshortcuts,aria-label,aria-labelledby,aria-level,aria-live,aria-modal,aria-multiline,' +\n    'aria-multiselectable,aria-orientation,aria-owns,aria-placeholder,aria-posinset,aria-pressed,aria-readonly,' +\n    'aria-relevant,aria-required,aria-roledescription,aria-rowcount,aria-rowindex,aria-rowspan,aria-selected,' +\n    'aria-setsize,aria-sort,aria-valuemax,aria-valuemin,aria-valuenow,aria-valuetext');\n\n// NB: This currently consciously doesn't support SVG. SVG sanitization has had several security\n// issues in the past, so it seems safer to leave it out if possible. If support for binding SVG via\n// innerHTML is required, SVG attributes should be added here.\n\n// NB: Sanitization does not allow <form> elements or other active elements (<button> etc). Those\n// can be sanitized, but they increase security surface area without a legitimate use case, so they\n// are left out here.\n\nexport const VALID_ATTRS = merge(URI_ATTRS, SRCSET_ATTRS, HTML_ATTRS, ARIA_ATTRS);\n\n// Elements whose content should not be traversed/preserved, if the elements themselves are invalid.\n//\n// Typically, `<invalid>Some content</invalid>` would traverse (and in this case preserve)\n// `Some content`, but strip `invalid-element` opening/closing tags. For some elements, though, we\n// don't want to preserve the content, if the elements themselves are going to be removed.\nconst SKIP_TRAVERSING_CONTENT_IF_INVALID_ELEMENTS = tagSet('script,style,template');\n\n/**\n * SanitizingHtmlSerializer serializes a DOM fragment, stripping out any unsafe elements and unsafe\n * attributes.\n */\nclass SanitizingHtmlSerializer {\n  // Explicitly track if something was stripped, to avoid accidentally warning of sanitization just\n  // because characters were re-encoded.\n  public sanitizedSomething = false;\n  private buf: string[] = [];\n\n  sanitizeChildren(el: Element): string {\n    // This cannot use a TreeWalker, as it has to run on Angular's various DOM adapters.\n    // However this code never accesses properties off of `document` before deleting its contents\n    // again, so it shouldn't be vulnerable to DOM clobbering.\n    let current: Node = el.firstChild !;\n    let traverseContent = true;\n    while (current) {\n      if (current.nodeType === Node.ELEMENT_NODE) {\n        traverseContent = this.startElement(current as Element);\n      } else if (current.nodeType === Node.TEXT_NODE) {\n        this.chars(current.nodeValue !);\n      } else {\n        // Strip non-element, non-text nodes.\n        this.sanitizedSomething = true;\n      }\n      if (traverseContent && current.firstChild) {\n        current = current.firstChild !;\n        continue;\n      }\n      while (current) {\n        // Leaving the element. Walk up and to the right, closing tags as we go.\n        if (current.nodeType === Node.ELEMENT_NODE) {\n          this.endElement(current as Element);\n        }\n\n        let next = this.checkClobberedElement(current, current.nextSibling !);\n\n        if (next) {\n          current = next;\n          break;\n        }\n\n        current = this.checkClobberedElement(current, current.parentNode !);\n      }\n    }\n    return this.buf.join('');\n  }\n\n  /**\n   * Sanitizes an opening element tag (if valid) and returns whether the element's contents should\n   * be traversed. Element content must always be traversed (even if the element itself is not\n   * valid/safe), unless the element is one of `SKIP_TRAVERSING_CONTENT_IF_INVALID_ELEMENTS`.\n   *\n   * @param element The element to sanitize.\n   * @return True if the element's contents should be traversed.\n   */\n  private startElement(element: Element): boolean {\n    const tagName = element.nodeName.toLowerCase();\n    if (!VALID_ELEMENTS.hasOwnProperty(tagName)) {\n      this.sanitizedSomething = true;\n      return !SKIP_TRAVERSING_CONTENT_IF_INVALID_ELEMENTS.hasOwnProperty(tagName);\n    }\n    this.buf.push('<');\n    this.buf.push(tagName);\n    const elAttrs = element.attributes;\n    for (let i = 0; i < elAttrs.length; i++) {\n      const elAttr = elAttrs.item(i);\n      const attrName = elAttr !.name;\n      const lower = attrName.toLowerCase();\n      if (!VALID_ATTRS.hasOwnProperty(lower)) {\n        this.sanitizedSomething = true;\n        continue;\n      }\n      let value = elAttr !.value;\n      // TODO(martinprobst): Special case image URIs for data:image/...\n      if (URI_ATTRS[lower]) value = _sanitizeUrl(value);\n      if (SRCSET_ATTRS[lower]) value = sanitizeSrcset(value);\n      this.buf.push(' ', attrName, '=\"', encodeEntities(value), '\"');\n    }\n    this.buf.push('>');\n    return true;\n  }\n\n  private endElement(current: Element) {\n    const tagName = current.nodeName.toLowerCase();\n    if (VALID_ELEMENTS.hasOwnProperty(tagName) && !VOID_ELEMENTS.hasOwnProperty(tagName)) {\n      this.buf.push('</');\n      this.buf.push(tagName);\n      this.buf.push('>');\n    }\n  }\n\n  private chars(chars: string) { this.buf.push(encodeEntities(chars)); }\n\n  checkClobberedElement(node: Node, nextNode: Node): Node {\n    if (nextNode &&\n        (node.compareDocumentPosition(nextNode) &\n         Node.DOCUMENT_POSITION_CONTAINED_BY) ===Â Node.DOCUMENT_POSITION_CONTAINED_BY) {\n      throw new Error(\n          `Failed to sanitize html because the element is clobbered: ${(node as Element).outerHTML}`);\n    }\n    return nextNode;\n  }\n}\n\n// Regular Expressions for parsing tags and attributes\nconst SURROGATE_PAIR_REGEXP = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g;\n// ! to ~ is the ASCII range.\nconst NON_ALPHANUMERIC_REGEXP = /([^\\#-~ |!])/g;\n\n/**\n * Escapes all potentially dangerous characters, so that the\n * resulting string can be safely inserted into attribute or\n * element text.\n * @param value\n */\nfunction encodeEntities(value: string) {\n  return value.replace(/&/g, '&amp;')\n      .replace(\n          SURROGATE_PAIR_REGEXP,\n          function(match: string) {\n            const hi = match.charCodeAt(0);\n            const low = match.charCodeAt(1);\n            return '&#' + (((hi - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000) + ';';\n          })\n      .replace(\n          NON_ALPHANUMERIC_REGEXP,\n          function(match: string) { return '&#' + match.charCodeAt(0) + ';'; })\n      .replace(/</g, '&lt;')\n      .replace(/>/g, '&gt;');\n}\n\nlet inertBodyHelper: InertBodyHelper;\n\n/**\n * Sanitizes the given unsafe, untrusted HTML fragment, and returns HTML text that is safe to add to\n * the DOM in a browser environment.\n */\nexport function _sanitizeHtml(defaultDoc: any, unsafeHtmlInput: string): string {\n  let inertBodyElement: HTMLElement|null = null;\n  try {\n    inertBodyHelper = inertBodyHelper || new InertBodyHelper(defaultDoc);\n    // Make sure unsafeHtml is actually a string (TypeScript types are not enforced at runtime).\n    let unsafeHtml = unsafeHtmlInput ? String(unsafeHtmlInput) : '';\n    inertBodyElement = inertBodyHelper.getInertBodyElement(unsafeHtml);\n\n    // mXSS protection. Repeatedly parse the document to make sure it stabilizes, so that a browser\n    // trying to auto-correct incorrect HTML cannot cause formerly inert HTML to become dangerous.\n    let mXSSAttempts = 5;\n    let parsedHtml = unsafeHtml;\n\n    do {\n      if (mXSSAttempts === 0) {\n        throw new Error('Failed to sanitize html because the input is unstable');\n      }\n      mXSSAttempts--;\n\n      unsafeHtml = parsedHtml;\n      parsedHtml = inertBodyElement !.innerHTML;\n      inertBodyElement = inertBodyHelper.getInertBodyElement(unsafeHtml);\n    } while (unsafeHtml !== parsedHtml);\n\n    const sanitizer = new SanitizingHtmlSerializer();\n    const safeHtml = sanitizer.sanitizeChildren(\n        getTemplateContent(inertBodyElement !) as Element || inertBodyElement);\n    if (isDevMode() && sanitizer.sanitizedSomething) {\n      console.warn(\n          'WARNING: sanitizing HTML stripped some content, see http://g.co/ng/security#xss');\n    }\n\n    return safeHtml;\n  } finally {\n    // In case anything goes wrong, clear out inertElement to reset the entire DOM structure.\n    if (inertBodyElement) {\n      const parent = getTemplateContent(inertBodyElement) || inertBodyElement;\n      while (parent.firstChild) {\n        parent.removeChild(parent.firstChild);\n      }\n    }\n  }\n}\n\nexport function getTemplateContent(el: Node): Node|null {\n  return 'content' in (el as any /** Microsoft/TypeScript#21517 */) && isTemplateElement(el) ?\n      el.content :\n      null;\n}\nfunction isTemplateElement(el: Node): el is HTMLTemplateElement {\n  return el.nodeType === Node.ELEMENT_NODE && el.nodeName === 'TEMPLATE';\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * A SecurityContext marks a location that has dangerous security implications, e.g. a DOM property\n * like `innerHTML` that could cause Cross Site Scripting (XSS) security bugs when improperly\n * handled.\n *\n * See DomSanitizer for more details on security in Angular applications.\n *\n * @publicApi\n */\nexport enum SecurityContext {\n  NONE = 0,\n  HTML = 1,\n  STYLE = 2,\n  SCRIPT = 3,\n  URL = 4,\n  RESOURCE_URL = 5,\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {isDevMode} from '../util/is_dev_mode';\nimport {SafeValue} from './bypass';\nimport {_sanitizeUrl} from './url_sanitizer';\n\n\n/**\n * Regular expression for safe style values.\n *\n * Quotes (\" and ') are allowed, but a check must be done elsewhere to ensure they're balanced.\n *\n * ',' allows multiple values to be assigned to the same property (e.g. background-attachment or\n * font-family) and hence could allow multiple values to get injected, but that should pose no risk\n * of XSS.\n *\n * The function expression checks only for XSS safety, not for CSS validity.\n *\n * This regular expression was taken from the Closure sanitization library, and augmented for\n * transformation values.\n */\nconst VALUES = '[-,.\"\\'%_!# a-zA-Z0-9]+';\nconst TRANSFORMATION_FNS = '(?:matrix|translate|scale|rotate|skew|perspective)(?:X|Y|Z|3d)?';\nconst COLOR_FNS = '(?:rgb|hsl)a?';\nconst GRADIENTS = '(?:repeating-)?(?:linear|radial)-gradient';\nconst CSS3_FNS = '(?:attr|calc|var)';\nconst FN_ARGS = '\\\\([-0-9.%, #a-zA-Z]+\\\\)';\nconst SAFE_STYLE_VALUE = new RegExp(\n    `^(${VALUES}|` +\n        `(?:${TRANSFORMATION_FNS}|${COLOR_FNS}|${GRADIENTS}|${CSS3_FNS})` +\n        `${FN_ARGS})$`,\n    'g');\n\n/**\n * Matches a `url(...)` value with an arbitrary argument as long as it does\n * not contain parentheses.\n *\n * The URL value still needs to be sanitized separately.\n *\n * `url(...)` values are a very common use case, e.g. for `background-image`. With carefully crafted\n * CSS style rules, it is possible to construct an information leak with `url` values in CSS, e.g.\n * by observing whether scroll bars are displayed, or character ranges used by a font face\n * definition.\n *\n * Angular only allows binding CSS values (as opposed to entire CSS rules), so it is unlikely that\n * binding a URL value without further cooperation from the page will cause an information leak, and\n * if so, it is just a leak, not a full blown XSS vulnerability.\n *\n * Given the common use case, low likelihood of attack vector, and low impact of an attack, this\n * code is permissive and allows URLs that sanitize otherwise.\n */\nconst URL_RE = /^url\\(([^)]+)\\)$/;\n\n/**\n * Checks that quotes (\" and ') are properly balanced inside a string. Assumes\n * that neither escape (\\) nor any other character that could result in\n * breaking out of a string parsing context are allowed;\n * see http://www.w3.org/TR/css3-syntax/#string-token-diagram.\n *\n * This code was taken from the Closure sanitization library.\n */\nfunction hasBalancedQuotes(value: string) {\n  let outsideSingle = true;\n  let outsideDouble = true;\n  for (let i = 0; i < value.length; i++) {\n    const c = value.charAt(i);\n    if (c === '\\'' && outsideDouble) {\n      outsideSingle = !outsideSingle;\n    } else if (c === '\"' && outsideSingle) {\n      outsideDouble = !outsideDouble;\n    }\n  }\n  return outsideSingle && outsideDouble;\n}\n\n/**\n * Sanitizes the given untrusted CSS style property value (i.e. not an entire object, just a single\n * value) and returns a value that is safe to use in a browser environment.\n */\nexport function _sanitizeStyle(value: string): string {\n  value = String(value).trim();  // Make sure it's actually a string.\n  if (!value) return '';\n\n  // Single url(...) values are supported, but only for URLs that sanitize cleanly. See above for\n  // reasoning behind this.\n  const urlMatch = value.match(URL_RE);\n  if ((urlMatch && _sanitizeUrl(urlMatch[1]) === urlMatch[1]) ||\n      value.match(SAFE_STYLE_VALUE) && hasBalancedQuotes(value)) {\n    return value;  // Safe style values.\n  }\n\n  if (isDevMode()) {\n    console.warn(\n        `WARNING: sanitizing unsafe style value ${value} (see http://g.co/ng/security#xss).`);\n  }\n\n  return 'unsafe';\n}\n\n\n/**\n * A series of flags to instruct a style sanitizer to either validate\n * or sanitize a value.\n *\n * Because sanitization is dependent on the style property (i.e. style\n * sanitization for `width` is much different than for `background-image`)\n * the sanitization function (e.g. `StyleSanitizerFn`) needs to check a\n * property value first before it actually sanitizes any values.\n *\n * This enum exist to allow a style sanitization function to either only\n * do validation (check the property to see whether a value will be\n * sanitized or not) or to sanitize the value (or both).\n *\n * @publicApi\n */\nexport const enum StyleSanitizeMode {\n  /** Just check to see if the property is required to be sanitized or not */\n  ValidateProperty = 0b01,\n  /** Skip checking the property; just sanitize the value */\n  SanitizeOnly = 0b10,\n  /** Check the property and (if true) then sanitize the value */\n  ValidateAndSanitize = 0b11,\n}\n\n/**\n * Used to intercept and sanitize style values before they are written to the renderer.\n *\n * This function is designed to be called in two modes. When a value is not provided\n * then the function will return a boolean whether a property will be sanitized later.\n * If a value is provided then the sanitized version of that will be returned.\n */\nexport interface StyleSanitizeFn {\n  (prop: string, value: string|SafeValue|null, mode?: StyleSanitizeMode): any;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {getDocument} from '../render3/interfaces/document';\nimport {SANITIZER} from '../render3/interfaces/view';\nimport {getLView} from '../render3/state';\nimport {renderStringify} from '../render3/util/misc_utils';\n\nimport {BypassType, allowSanitizationBypassAndThrow, unwrapSafeValue} from './bypass';\nimport {_sanitizeHtml as _sanitizeHtml} from './html_sanitizer';\nimport {Sanitizer} from './sanitizer';\nimport {SecurityContext} from './security';\nimport {StyleSanitizeFn, StyleSanitizeMode, _sanitizeStyle} from './style_sanitizer';\nimport {_sanitizeUrl as _sanitizeUrl} from './url_sanitizer';\n\n\n\n/**\n * An `html` sanitizer which converts untrusted `html` **string** into trusted string by removing\n * dangerous content.\n *\n * This method parses the `html` and locates potentially dangerous content (such as urls and\n * javascript) and removes it.\n *\n * It is possible to mark a string as trusted by calling {@link bypassSanitizationTrustHtml}.\n *\n * @param unsafeHtml untrusted `html`, typically from the user.\n * @returns `html` string which is safe to display to user, because all of the dangerous javascript\n * and urls have been removed.\n *\n * @publicApi\n */\nexport function ÉµÉµsanitizeHtml(unsafeHtml: any): string {\n  const sanitizer = getSanitizer();\n  if (sanitizer) {\n    return sanitizer.sanitize(SecurityContext.HTML, unsafeHtml) || '';\n  }\n  if (allowSanitizationBypassAndThrow(unsafeHtml, BypassType.Html)) {\n    return unwrapSafeValue(unsafeHtml);\n  }\n  return _sanitizeHtml(getDocument(), renderStringify(unsafeHtml));\n}\n\n/**\n * A `style` sanitizer which converts untrusted `style` **string** into trusted string by removing\n * dangerous content.\n *\n * This method parses the `style` and locates potentially dangerous content (such as urls and\n * javascript) and removes it.\n *\n * It is possible to mark a string as trusted by calling {@link bypassSanitizationTrustStyle}.\n *\n * @param unsafeStyle untrusted `style`, typically from the user.\n * @returns `style` string which is safe to bind to the `style` properties, because all of the\n * dangerous javascript and urls have been removed.\n *\n * @publicApi\n */\nexport function ÉµÉµsanitizeStyle(unsafeStyle: any): string {\n  const sanitizer = getSanitizer();\n  if (sanitizer) {\n    return sanitizer.sanitize(SecurityContext.STYLE, unsafeStyle) || '';\n  }\n  if (allowSanitizationBypassAndThrow(unsafeStyle, BypassType.Style)) {\n    return unwrapSafeValue(unsafeStyle);\n  }\n  return _sanitizeStyle(renderStringify(unsafeStyle));\n}\n\n/**\n * A `url` sanitizer which converts untrusted `url` **string** into trusted string by removing\n * dangerous\n * content.\n *\n * This method parses the `url` and locates potentially dangerous content (such as javascript) and\n * removes it.\n *\n * It is possible to mark a string as trusted by calling {@link bypassSanitizationTrustUrl}.\n *\n * @param unsafeUrl untrusted `url`, typically from the user.\n * @returns `url` string which is safe to bind to the `src` properties such as `<img src>`, because\n * all of the dangerous javascript has been removed.\n *\n * @publicApi\n */\nexport function ÉµÉµsanitizeUrl(unsafeUrl: any): string {\n  const sanitizer = getSanitizer();\n  if (sanitizer) {\n    return sanitizer.sanitize(SecurityContext.URL, unsafeUrl) || '';\n  }\n  if (allowSanitizationBypassAndThrow(unsafeUrl, BypassType.Url)) {\n    return unwrapSafeValue(unsafeUrl);\n  }\n  return _sanitizeUrl(renderStringify(unsafeUrl));\n}\n\n/**\n * A `url` sanitizer which only lets trusted `url`s through.\n *\n * This passes only `url`s marked trusted by calling {@link bypassSanitizationTrustResourceUrl}.\n *\n * @param unsafeResourceUrl untrusted `url`, typically from the user.\n * @returns `url` string which is safe to bind to the `src` properties such as `<img src>`, because\n * only trusted `url`s have been allowed to pass.\n *\n * @publicApi\n */\nexport function ÉµÉµsanitizeResourceUrl(unsafeResourceUrl: any): string {\n  const sanitizer = getSanitizer();\n  if (sanitizer) {\n    return sanitizer.sanitize(SecurityContext.RESOURCE_URL, unsafeResourceUrl) || '';\n  }\n  if (allowSanitizationBypassAndThrow(unsafeResourceUrl, BypassType.ResourceUrl)) {\n    return unwrapSafeValue(unsafeResourceUrl);\n  }\n  throw new Error('unsafe value used in a resource URL context (see http://g.co/ng/security#xss)');\n}\n\n/**\n * A `script` sanitizer which only lets trusted javascript through.\n *\n * This passes only `script`s marked trusted by calling {@link\n * bypassSanitizationTrustScript}.\n *\n * @param unsafeScript untrusted `script`, typically from the user.\n * @returns `url` string which is safe to bind to the `<script>` element such as `<img src>`,\n * because only trusted `scripts` have been allowed to pass.\n *\n * @publicApi\n */\nexport function ÉµÉµsanitizeScript(unsafeScript: any): string {\n  const sanitizer = getSanitizer();\n  if (sanitizer) {\n    return sanitizer.sanitize(SecurityContext.SCRIPT, unsafeScript) || '';\n  }\n  if (allowSanitizationBypassAndThrow(unsafeScript, BypassType.Script)) {\n    return unwrapSafeValue(unsafeScript);\n  }\n  throw new Error('unsafe value used in a script context');\n}\n\n/**\n * Detects which sanitizer to use for URL property, based on tag name and prop name.\n *\n * The rules are based on the RESOURCE_URL context config from\n * `packages/compiler/src/schema/dom_security_schema.ts`.\n * If tag and prop names don't match Resource URL schema, use URL sanitizer.\n */\nexport function getUrlSanitizer(tag: string, prop: string) {\n  if ((prop === 'src' && (tag === 'embed' || tag === 'frame' || tag === 'iframe' ||\n                          tag === 'media' || tag === 'script')) ||\n      (prop === 'href' && (tag === 'base' || tag === 'link'))) {\n    return ÉµÉµsanitizeResourceUrl;\n  }\n  return ÉµÉµsanitizeUrl;\n}\n\n/**\n * Sanitizes URL, selecting sanitizer function based on tag and property names.\n *\n * This function is used in case we can't define security context at compile time, when only prop\n * name is available. This happens when we generate host bindings for Directives/Components. The\n * host element is unknown at compile time, so we defer calculation of specific sanitizer to\n * runtime.\n *\n * @param unsafeUrl untrusted `url`, typically from the user.\n * @param tag target element tag name.\n * @param prop name of the property that contains the value.\n * @returns `url` string which is safe to bind.\n *\n * @publicApi\n */\nexport function ÉµÉµsanitizeUrlOrResourceUrl(unsafeUrl: any, tag: string, prop: string): any {\n  return getUrlSanitizer(tag, prop)(unsafeUrl);\n}\n\n/**\n * The default style sanitizer will handle sanitization for style properties by\n * sanitizing any CSS property that can include a `url` value (usually image-based properties)\n *\n * @publicApi\n */\nexport const ÉµÉµdefaultStyleSanitizer =\n    (function(prop: string, value: string|null, mode?: StyleSanitizeMode): string | boolean | null {\n      if (value === undefined && mode === undefined) {\n        // This is a workaround for the fact that `StyleSanitizeFn` should not exist once PR#34480\n        // lands. For now the `StyleSanitizeFn` and should act like `(value: any) => string` as a\n        // work around.\n        return ÉµÉµsanitizeStyle(prop);\n      }\n      mode = mode || StyleSanitizeMode.ValidateAndSanitize;\n      let doSanitizeValue = true;\n      if (mode & StyleSanitizeMode.ValidateProperty) {\n        doSanitizeValue = stylePropNeedsSanitization(prop);\n      }\n\n      if (mode & StyleSanitizeMode.SanitizeOnly) {\n        return doSanitizeValue ? ÉµÉµsanitizeStyle(value) : unwrapSafeValue(value);\n      } else {\n        return doSanitizeValue;\n      }\n    } as StyleSanitizeFn);\n\nexport function stylePropNeedsSanitization(prop: string): boolean {\n  return prop === 'background-image' || prop === 'backgroundImage' || prop === 'background' ||\n      prop === 'border-image' || prop === 'borderImage' || prop === 'border-image-source' ||\n      prop === 'borderImageSource' || prop === 'filter' || prop === 'list-style' ||\n      prop === 'listStyle' || prop === 'list-style-image' || prop === 'listStyleImage' ||\n      prop === 'clip-path' || prop === 'clipPath';\n}\n\nexport function validateAgainstEventProperties(name: string) {\n  if (name.toLowerCase().startsWith('on')) {\n    const msg = `Binding to event property '${name}' is disallowed for security reasons, ` +\n        `please use (${name.slice(2)})=...` +\n        `\\nIf '${name}' is a directive input, make sure the directive is imported by the` +\n        ` current module.`;\n    throw new Error(msg);\n  }\n}\n\nexport function validateAgainstEventAttributes(name: string) {\n  if (name.toLowerCase().startsWith('on')) {\n    const msg = `Binding to event attribute '${name}' is disallowed for security reasons, ` +\n        `please use (${name.slice(2)})=...`;\n    throw new Error(msg);\n  }\n}\n\nfunction getSanitizer(): Sanitizer|null {\n  const lView = getLView();\n  return lView && lView[SANITIZER];\n}\n","\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport './ng_dev_mode';\n\n/**\n * THIS FILE CONTAINS CODE WHICH SHOULD BE TREE SHAKEN AND NEVER CALLED FROM PRODUCTION CODE!!!\n */\n\n\n/**\n * Creates an `Array` construction with a given name. This is useful when\n * looking for memory consumption to see what time of array it is.\n *\n *\n * @param name Name to give to the constructor\n * @returns A subclass of `Array` if possible. This can only be done in\n *          environments which support `class` construct.\n */\nexport function createNamedArrayType(name: string): typeof Array {\n  // This should never be called in prod mode, so let's verify that is the case.\n  if (ngDevMode) {\n    try {\n      // We need to do it this way so that TypeScript does not down-level the below code.\n      const FunctionConstructor: any = createNamedArrayType.constructor;\n      return (new FunctionConstructor('Array', `return class ${name} extends Array{}`))(Array);\n    } catch (e) {\n      // If it does not work just give up and fall back to regular Array.\n      return Array;\n    }\n  } else {\n    throw new Error(\n        'Looks like we are in \\'prod mode\\', but we are creating a named Array type, which is wrong! Check your code');\n  }\n}","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nexport function normalizeDebugBindingName(name: string) {\n  // Attribute names with `$` (eg `x-y$`) are valid per spec, but unsupported by some browsers\n  name = camelCaseToDashCase(name.replace(/[$@]/g, '_'));\n  return `ng-reflect-${name}`;\n}\n\nconst CAMEL_CASE_REGEXP = /([A-Z])/g;\n\nfunction camelCaseToDashCase(input: string): string {\n  return input.replace(CAMEL_CASE_REGEXP, (...m: any[]) => '-' + m[1].toLowerCase());\n}\n\nexport function normalizeDebugBindingValue(value: any): string {\n  try {\n    // Limit the size of the value as otherwise the DOM just gets polluted.\n    return value != null ? value.toString().slice(0, 30) : value;\n  } catch (e) {\n    return '[ERROR] Exception while trying to serialize the value';\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nimport {RNode} from './renderer';\nimport {LView} from './view';\n\n/**\n * This property will be monkey-patched on elements, components and directives\n */\nexport const MONKEY_PATCH_KEY_NAME = '__ngContext__';\n\n/**\n * The internal view context which is specific to a given DOM element, directive or\n * component instance. Each value in here (besides the LView and element node details)\n * can be present, null or undefined. If undefined then it implies the value has not been\n * looked up yet, otherwise, if null, then a lookup was executed and nothing was found.\n *\n * Each value will get filled when the respective value is examined within the getContext\n * function. The component, element and each directive instance will share the same instance\n * of the context.\n */\nexport interface LContext {\n  /**\n   * The component's parent view data.\n   */\n  lView: LView;\n\n  /**\n   * The index instance of the node.\n   */\n  nodeIndex: number;\n\n  /**\n   * The instance of the DOM node that is attached to the lNode.\n   */\n  native: RNode;\n\n  /**\n   * The instance of the Component node.\n   */\n  component: {}|null|undefined;\n\n  /**\n   * The list of active directives that exist on this element.\n   */\n  directives: any[]|null|undefined;\n\n  /**\n   * The map of local references (local reference name => element or directive instance) that exist\n   * on this element.\n   */\n  localRefs: {[key: string]: any}|null|undefined;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {assertDataInRange, assertDefined, assertDomNode, assertGreaterThan, assertLessThan} from '../../util/assert';\nimport {assertTNodeForLView} from '../assert';\nimport {ACTIVE_INDEX, ActiveIndexFlag, LContainer, TYPE} from '../interfaces/container';\nimport {LContext, MONKEY_PATCH_KEY_NAME} from '../interfaces/context';\nimport {TConstants, TNode} from '../interfaces/node';\nimport {RNode, isProceduralRenderer} from '../interfaces/renderer';\nimport {isLContainer, isLView} from '../interfaces/type_checks';\nimport {FLAGS, HEADER_OFFSET, HOST, LView, LViewFlags, PARENT, PREORDER_HOOK_FLAGS, RENDERER, TData, TView} from '../interfaces/view';\n\n\n\n/**\n * For efficiency reasons we often put several different data types (`RNode`, `LView`, `LContainer`)\n * in same location in `LView`. This is because we don't want to pre-allocate space for it\n * because the storage is sparse. This file contains utilities for dealing with such data types.\n *\n * How do we know what is stored at a given location in `LView`.\n * - `Array.isArray(value) === false` => `RNode` (The normal storage value)\n * - `Array.isArray(value) === true` => then the `value[0]` represents the wrapped value.\n *   - `typeof value[TYPE] === 'object'` => `LView`\n *      - This happens when we have a component at a given location\n *   - `typeof value[TYPE] === true` => `LContainer`\n *      - This happens when we have `LContainer` binding at a given location.\n *\n *\n * NOTE: it is assumed that `Array.isArray` and `typeof` operations are very efficient.\n */\n\n/**\n * Returns `RNode`.\n * @param value wrapped value of `RNode`, `LView`, `LContainer`\n */\nexport function unwrapRNode(value: RNode | LView | LContainer): RNode {\n  while (Array.isArray(value)) {\n    value = value[HOST] as any;\n  }\n  return value as RNode;\n}\n\n/**\n * Returns `LView` or `null` if not found.\n * @param value wrapped value of `RNode`, `LView`, `LContainer`\n */\nexport function unwrapLView(value: RNode | LView | LContainer): LView|null {\n  while (Array.isArray(value)) {\n    // This check is same as `isLView()` but we don't call at as we don't want to call\n    // `Array.isArray()` twice and give JITer more work for inlining.\n    if (typeof value[TYPE] === 'object') return value as LView;\n    value = value[HOST] as any;\n  }\n  return null;\n}\n\n/**\n * Returns `LContainer` or `null` if not found.\n * @param value wrapped value of `RNode`, `LView`, `LContainer`\n */\nexport function unwrapLContainer(value: RNode | LView | LContainer): LContainer|null {\n  while (Array.isArray(value)) {\n    // This check is same as `isLContainer()` but we don't call at as we don't want to call\n    // `Array.isArray()` twice and give JITer more work for inlining.\n    if (value[TYPE] === true) return value as LContainer;\n    value = value[HOST] as any;\n  }\n  return null;\n}\n\n/**\n * Retrieves an element value from the provided `viewData`, by unwrapping\n * from any containers, component views, or style contexts.\n */\nexport function getNativeByIndex(index: number, lView: LView): RNode {\n  return unwrapRNode(lView[index + HEADER_OFFSET]);\n}\n\n/**\n * Retrieve an `RNode` for a given `TNode` and `LView`.\n *\n * This function guarantees in dev mode to retrieve a non-null `RNode`.\n *\n * @param tNode\n * @param lView\n */\nexport function getNativeByTNode(tNode: TNode, lView: LView): RNode {\n  ngDevMode && assertTNodeForLView(tNode, lView);\n  ngDevMode && assertDataInRange(lView, tNode.index);\n  const node: RNode = unwrapRNode(lView[tNode.index]);\n  ngDevMode && !isProceduralRenderer(lView[RENDERER]) && assertDomNode(node);\n  return node;\n}\n\n/**\n * Retrieve an `RNode` or `null` for a given `TNode` and `LView`.\n *\n * Some `TNode`s don't have associated `RNode`s. For example `Projection`\n *\n * @param tNode\n * @param lView\n */\nexport function getNativeByTNodeOrNull(tNode: TNode, lView: LView): RNode|null {\n  const index = tNode.index;\n  if (index !== -1) {\n    ngDevMode && assertTNodeForLView(tNode, lView);\n    const node: RNode|null = unwrapRNode(lView[index]);\n    ngDevMode && node !== null && !isProceduralRenderer(lView[RENDERER]) && assertDomNode(node);\n    return node;\n  }\n  return null;\n}\n\n\nexport function getTNode(tView: TView, index: number): TNode {\n  ngDevMode && assertGreaterThan(index, -1, 'wrong index for TNode');\n  ngDevMode && assertLessThan(index, tView.data.length, 'wrong index for TNode');\n  return tView.data[index + HEADER_OFFSET] as TNode;\n}\n\n/** Retrieves a value from any `LView` or `TData`. */\nexport function load<T>(view: LView | TData, index: number): T {\n  ngDevMode && assertDataInRange(view, index + HEADER_OFFSET);\n  return view[index + HEADER_OFFSET];\n}\n\nexport function getComponentLViewByIndex(nodeIndex: number, hostView: LView): LView {\n  // Could be an LView or an LContainer. If LContainer, unwrap to find LView.\n  ngDevMode && assertDataInRange(hostView, nodeIndex);\n  const slotValue = hostView[nodeIndex];\n  const lView = isLView(slotValue) ? slotValue : slotValue[HOST];\n  return lView;\n}\n\n\n/**\n * Returns the monkey-patch value data present on the target (which could be\n * a component, directive or a DOM node).\n */\nexport function readPatchedData(target: any): LView|LContext|null {\n  ngDevMode && assertDefined(target, 'Target expected');\n  return target[MONKEY_PATCH_KEY_NAME] || null;\n}\n\nexport function readPatchedLView(target: any): LView|null {\n  const value = readPatchedData(target);\n  if (value) {\n    return Array.isArray(value) ? value : (value as LContext).lView;\n  }\n  return null;\n}\n\n/** Checks whether a given view is in creation mode */\nexport function isCreationMode(view: LView): boolean {\n  return (view[FLAGS] & LViewFlags.CreationMode) === LViewFlags.CreationMode;\n}\n\n/**\n * Returns a boolean for whether the view is attached to the change detection tree.\n *\n * Note: This determines whether a view should be checked, not whether it's inserted\n * into a container. For that, you'll want `viewAttachedToContainer` below.\n */\nexport function viewAttachedToChangeDetector(view: LView): boolean {\n  return (view[FLAGS] & LViewFlags.Attached) === LViewFlags.Attached;\n}\n\n/** Returns a boolean for whether the view is attached to a container. */\nexport function viewAttachedToContainer(view: LView): boolean {\n  return isLContainer(view[PARENT]);\n}\n\n/** Returns a constant from `TConstants` instance. */\nexport function getConstant<T>(consts: TConstants | null, index: number | null | undefined): T|\n    null {\n  return consts === null || index == null ? null : consts[index] as unknown as T;\n}\n\n/**\n * Resets the pre-order hook flags of the view.\n * @param lView the LView on which the flags are reset\n */\nexport function resetPreOrderHookFlags(lView: LView) {\n  lView[PREORDER_HOOK_FLAGS] = 0;\n}\n\nexport function getLContainerActiveIndex(lContainer: LContainer) {\n  return lContainer[ACTIVE_INDEX] >> ActiveIndexFlag.SHIFT;\n}\n\nexport function setLContainerActiveIndex(lContainer: LContainer, index: number) {\n  lContainer[ACTIVE_INDEX] = index << ActiveIndexFlag.SHIFT;\n}","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport '../util/ng_dev_mode';\n\nimport {assertDomNode} from '../util/assert';\n\nimport {EMPTY_ARRAY} from './empty';\nimport {LContext, MONKEY_PATCH_KEY_NAME} from './interfaces/context';\nimport {TNode, TNodeFlags} from './interfaces/node';\nimport {RElement, RNode} from './interfaces/renderer';\nimport {CONTEXT, HEADER_OFFSET, HOST, LView, TVIEW} from './interfaces/view';\nimport {getComponentLViewByIndex, getNativeByTNodeOrNull, readPatchedData, unwrapRNode} from './util/view_utils';\n\n\n\n/** Returns the matching `LContext` data for a given DOM node, directive or component instance.\n *\n * This function will examine the provided DOM element, component, or directive instance\\'s\n * monkey-patched property to derive the `LContext` data. Once called then the monkey-patched\n * value will be that of the newly created `LContext`.\n *\n * If the monkey-patched value is the `LView` instance then the context value for that\n * target will be created and the monkey-patch reference will be updated. Therefore when this\n * function is called it may mutate the provided element\\'s, component\\'s or any of the associated\n * directive\\'s monkey-patch values.\n *\n * If the monkey-patch value is not detected then the code will walk up the DOM until an element\n * is found which contains a monkey-patch reference. When that occurs then the provided element\n * will be updated with a new context (which is then returned). If the monkey-patch value is not\n * detected for a component/directive instance then it will throw an error (all components and\n * directives should be automatically monkey-patched by ivy).\n *\n * @param target Component, Directive or DOM Node.\n */\nexport function getLContext(target: any): LContext|null {\n  let mpValue = readPatchedData(target);\n  if (mpValue) {\n    // only when it's an array is it considered an LView instance\n    // ... otherwise it's an already constructed LContext instance\n    if (Array.isArray(mpValue)) {\n      const lView: LView = mpValue !;\n      let nodeIndex: number;\n      let component: any = undefined;\n      let directives: any[]|null|undefined = undefined;\n\n      if (isComponentInstance(target)) {\n        nodeIndex = findViaComponent(lView, target);\n        if (nodeIndex == -1) {\n          throw new Error('The provided component was not found in the application');\n        }\n        component = target;\n      } else if (isDirectiveInstance(target)) {\n        nodeIndex = findViaDirective(lView, target);\n        if (nodeIndex == -1) {\n          throw new Error('The provided directive was not found in the application');\n        }\n        directives = getDirectivesAtNodeIndex(nodeIndex, lView, false);\n      } else {\n        nodeIndex = findViaNativeElement(lView, target as RElement);\n        if (nodeIndex == -1) {\n          return null;\n        }\n      }\n\n      // the goal is not to fill the entire context full of data because the lookups\n      // are expensive. Instead, only the target data (the element, component, container, ICU\n      // expression or directive details) are filled into the context. If called multiple times\n      // with different target values then the missing target data will be filled in.\n      const native = unwrapRNode(lView[nodeIndex]);\n      const existingCtx = readPatchedData(native);\n      const context: LContext = (existingCtx && !Array.isArray(existingCtx)) ?\n          existingCtx :\n          createLContext(lView, nodeIndex, native);\n\n      // only when the component has been discovered then update the monkey-patch\n      if (component && context.component === undefined) {\n        context.component = component;\n        attachPatchData(context.component, context);\n      }\n\n      // only when the directives have been discovered then update the monkey-patch\n      if (directives && context.directives === undefined) {\n        context.directives = directives;\n        for (let i = 0; i < directives.length; i++) {\n          attachPatchData(directives[i], context);\n        }\n      }\n\n      attachPatchData(context.native, context);\n      mpValue = context;\n    }\n  } else {\n    const rElement = target as RElement;\n    ngDevMode && assertDomNode(rElement);\n\n    // if the context is not found then we need to traverse upwards up the DOM\n    // to find the nearest element that has already been monkey patched with data\n    let parent = rElement as any;\n    while (parent = parent.parentNode) {\n      const parentContext = readPatchedData(parent);\n      if (parentContext) {\n        let lView: LView|null;\n        if (Array.isArray(parentContext)) {\n          lView = parentContext as LView;\n        } else {\n          lView = parentContext.lView;\n        }\n\n        // the edge of the app was also reached here through another means\n        // (maybe because the DOM was changed manually).\n        if (!lView) {\n          return null;\n        }\n\n        const index = findViaNativeElement(lView, rElement);\n        if (index >= 0) {\n          const native = unwrapRNode(lView[index]);\n          const context = createLContext(lView, index, native);\n          attachPatchData(native, context);\n          mpValue = context;\n          break;\n        }\n      }\n    }\n  }\n  return (mpValue as LContext) || null;\n}\n\n/**\n * Creates an empty instance of a `LContext` context\n */\nfunction createLContext(lView: LView, nodeIndex: number, native: RNode): LContext {\n  return {\n    lView,\n    nodeIndex,\n    native,\n    component: undefined,\n    directives: undefined,\n    localRefs: undefined,\n  };\n}\n\n/**\n * Takes a component instance and returns the view for that component.\n *\n * @param componentInstance\n * @returns The component's view\n */\nexport function getComponentViewByInstance(componentInstance: {}): LView {\n  let lView = readPatchedData(componentInstance);\n  let view: LView;\n\n  if (Array.isArray(lView)) {\n    const nodeIndex = findViaComponent(lView, componentInstance);\n    view = getComponentLViewByIndex(nodeIndex, lView);\n    const context = createLContext(lView, nodeIndex, view[HOST] as RElement);\n    context.component = componentInstance;\n    attachPatchData(componentInstance, context);\n    attachPatchData(context.native, context);\n  } else {\n    const context = lView as any as LContext;\n    view = getComponentLViewByIndex(context.nodeIndex, context.lView);\n  }\n  return view;\n}\n\n/**\n * Assigns the given data to the given target (which could be a component,\n * directive or DOM node instance) using monkey-patching.\n */\nexport function attachPatchData(target: any, data: LView | LContext) {\n  target[MONKEY_PATCH_KEY_NAME] = data;\n}\n\nexport function isComponentInstance(instance: any): boolean {\n  return instance && instance.constructor && instance.constructor.Éµcmp;\n}\n\nexport function isDirectiveInstance(instance: any): boolean {\n  return instance && instance.constructor && instance.constructor.Éµdir;\n}\n\n/**\n * Locates the element within the given LView and returns the matching index\n */\nfunction findViaNativeElement(lView: LView, target: RElement): number {\n  let tNode = lView[TVIEW].firstChild;\n  while (tNode) {\n    const native = getNativeByTNodeOrNull(tNode, lView) !;\n    if (native === target) {\n      return tNode.index;\n    }\n    tNode = traverseNextElement(tNode);\n  }\n\n  return -1;\n}\n\n/**\n * Locates the next tNode (child, sibling or parent).\n */\nfunction traverseNextElement(tNode: TNode): TNode|null {\n  if (tNode.child) {\n    return tNode.child;\n  } else if (tNode.next) {\n    return tNode.next;\n  } else {\n    // Let's take the following template: <div><span>text</span></div><component/>\n    // After checking the text node, we need to find the next parent that has a \"next\" TNode,\n    // in this case the parent `div`, so that we can find the component.\n    while (tNode.parent && !tNode.parent.next) {\n      tNode = tNode.parent;\n    }\n    return tNode.parent && tNode.parent.next;\n  }\n}\n\n/**\n * Locates the component within the given LView and returns the matching index\n */\nfunction findViaComponent(lView: LView, componentInstance: {}): number {\n  const componentIndices = lView[TVIEW].components;\n  if (componentIndices) {\n    for (let i = 0; i < componentIndices.length; i++) {\n      const elementComponentIndex = componentIndices[i];\n      const componentView = getComponentLViewByIndex(elementComponentIndex, lView);\n      if (componentView[CONTEXT] === componentInstance) {\n        return elementComponentIndex;\n      }\n    }\n  } else {\n    const rootComponentView = getComponentLViewByIndex(HEADER_OFFSET, lView);\n    const rootComponent = rootComponentView[CONTEXT];\n    if (rootComponent === componentInstance) {\n      // we are dealing with the root element here therefore we know that the\n      // element is the very first element after the HEADER data in the lView\n      return HEADER_OFFSET;\n    }\n  }\n  return -1;\n}\n\n/**\n * Locates the directive within the given LView and returns the matching index\n */\nfunction findViaDirective(lView: LView, directiveInstance: {}): number {\n  // if a directive is monkey patched then it will (by default)\n  // have a reference to the LView of the current view. The\n  // element bound to the directive being search lives somewhere\n  // in the view data. We loop through the nodes and check their\n  // list of directives for the instance.\n  let tNode = lView[TVIEW].firstChild;\n  while (tNode) {\n    const directiveIndexStart = tNode.directiveStart;\n    const directiveIndexEnd = tNode.directiveEnd;\n    for (let i = directiveIndexStart; i < directiveIndexEnd; i++) {\n      if (lView[i] === directiveInstance) {\n        return tNode.index;\n      }\n    }\n    tNode = traverseNextElement(tNode);\n  }\n  return -1;\n}\n\n/**\n * Returns a list of directives extracted from the given view based on the\n * provided list of directive index values.\n *\n * @param nodeIndex The node index\n * @param lView The target view data\n * @param includeComponents Whether or not to include components in returned directives\n */\nexport function getDirectivesAtNodeIndex(\n    nodeIndex: number, lView: LView, includeComponents: boolean): any[]|null {\n  const tNode = lView[TVIEW].data[nodeIndex] as TNode;\n  let directiveStartIndex = tNode.directiveStart;\n  if (directiveStartIndex == 0) return EMPTY_ARRAY;\n  const directiveEndIndex = tNode.directiveEnd;\n  if (!includeComponents && tNode.flags & TNodeFlags.isComponentHost) directiveStartIndex++;\n  return lView.slice(directiveStartIndex, directiveEndIndex);\n}\n\nexport function getComponentAtNodeIndex(nodeIndex: number, lView: LView): {}|null {\n  const tNode = lView[TVIEW].data[nodeIndex] as TNode;\n  let directiveStartIndex = tNode.directiveStart;\n  return tNode.flags & TNodeFlags.isComponentHost ? lView[directiveStartIndex] : null;\n}\n\n/**\n * Returns a map of local references (local reference name => element or directive instance) that\n * exist on a given element.\n */\nexport function discoverLocalRefs(lView: LView, nodeIndex: number): {[key: string]: any}|null {\n  const tNode = lView[TVIEW].data[nodeIndex] as TNode;\n  if (tNode && tNode.localNames) {\n    const result: {[key: string]: any} = {};\n    let localIndex = tNode.index + 1;\n    for (let i = 0; i < tNode.localNames.length; i += 2) {\n      result[tNode.localNames[i]] = lView[localIndex];\n      localIndex++;\n    }\n    return result;\n  }\n\n  return null;\n}\n","\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {InjectorType} from '../di/interface/defs';\nimport {stringify} from '../util/stringify';\n\nimport {TNode} from './interfaces/node';\nimport {LView, TVIEW} from './interfaces/view';\nimport {INTERPOLATION_DELIMITER} from './util/misc_utils';\n\n\n\n/** Called when directives inject each other (creating a circular dependency) */\nexport function throwCyclicDependencyError(token: any): never {\n  throw new Error(`Cannot instantiate cyclic dependency! ${token}`);\n}\n\n/** Called when there are multiple component selectors that match a given node */\nexport function throwMultipleComponentError(tNode: TNode): never {\n  throw new Error(`Multiple components match node with tagname ${tNode.tagName}`);\n}\n\nexport function throwMixedMultiProviderError() {\n  throw new Error(`Cannot mix multi providers and regular providers`);\n}\n\nexport function throwInvalidProviderError(\n    ngModuleType?: InjectorType<any>, providers?: any[], provider?: any) {\n  let ngModuleDetail = '';\n  if (ngModuleType && providers) {\n    const providerDetail = providers.map(v => v == provider ? '?' + provider + '?' : '...');\n    ngModuleDetail =\n        ` - only instances of Provider and Type are allowed, got: [${providerDetail.join(', ')}]`;\n  }\n\n  throw new Error(\n      `Invalid provider for the NgModule '${stringify(ngModuleType)}'` + ngModuleDetail);\n}\n\n/** Throws an ExpressionChangedAfterChecked error if checkNoChanges mode is on. */\nexport function throwErrorIfNoChangesMode(\n    creationMode: boolean, oldValue: any, currValue: any, propName?: string): never|void {\n  const field = propName ? ` for '${propName}'` : '';\n  let msg =\n      `ExpressionChangedAfterItHasBeenCheckedError: Expression has changed after it was checked. Previous value${field}: '${oldValue}'. Current value: '${currValue}'.`;\n  if (creationMode) {\n    msg +=\n        ` It seems like the view has been created after its parent and its children have been dirty checked.` +\n        ` Has it been created in a change detection hook?`;\n  }\n  // TODO: include debug context, see `viewDebugError` function in\n  // `packages/core/src/view/errors.ts` for reference.\n  // tslint:disable-next-line\n  debugger;  // Left intentionally for better debugger experience.\n  throw new Error(msg);\n}\n\nfunction constructDetailsForInterpolation(\n    lView: LView, rootIndex: number, expressionIndex: number, meta: string, changedValue: any) {\n  const [propName, prefix, ...chunks] = meta.split(INTERPOLATION_DELIMITER);\n  let oldValue = prefix, newValue = prefix;\n  for (let i = 0; i < chunks.length; i++) {\n    const slotIdx = rootIndex + i;\n    oldValue += `${lView[slotIdx]}${chunks[i]}`;\n    newValue += `${slotIdx === expressionIndex ? changedValue : lView[slotIdx]}${chunks[i]}`;\n  }\n  return {propName, oldValue, newValue};\n}\n\n/**\n * Constructs an object that contains details for the ExpressionChangedAfterItHasBeenCheckedError:\n * - property name (for property bindings or interpolations)\n * - old and new values, enriched using information from metadata\n *\n * More information on the metadata storage format can be found in `storePropertyBindingMetadata`\n * function description.\n */\nexport function getExpressionChangedErrorDetails(\n    lView: LView, bindingIndex: number, oldValue: any,\n    newValue: any): {propName?: string, oldValue: any, newValue: any} {\n  const tData = lView[TVIEW].data;\n  const metadata = tData[bindingIndex];\n\n  if (typeof metadata === 'string') {\n    // metadata for property interpolation\n    if (metadata.indexOf(INTERPOLATION_DELIMITER) > -1) {\n      return constructDetailsForInterpolation(\n          lView, bindingIndex, bindingIndex, metadata, newValue);\n    }\n    // metadata for property binding\n    return {propName: metadata, oldValue, newValue};\n  }\n\n  // metadata is not available for this expression, check if this expression is a part of the\n  // property interpolation by going from the current binding index left and look for a string that\n  // contains INTERPOLATION_DELIMITER, the layout in tView.data for this case will look like this:\n  // [..., 'idï¿½Prefix ï¿½ and ï¿½ suffix', null, null, null, ...]\n  if (metadata === null) {\n    let idx = bindingIndex - 1;\n    while (typeof tData[idx] !== 'string' && tData[idx + 1] === null) {\n      idx--;\n    }\n    const meta = tData[idx];\n    if (typeof meta === 'string') {\n      const matches = meta.match(new RegExp(INTERPOLATION_DELIMITER, 'g'));\n      // first interpolation delimiter separates property name from interpolation parts (in case of\n      // property interpolations), so we subtract one from total number of found delimiters\n      if (matches && (matches.length - 1) > bindingIndex - idx) {\n        return constructDetailsForInterpolation(lView, idx, bindingIndex, meta, newValue);\n      }\n    }\n  }\n  return {propName: undefined, oldValue, newValue};\n}","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {KeyValueArray} from '../../util/array_utils';\nimport {TStylingRange} from '../interfaces/styling';\n\nimport {DirectiveDef} from './definition';\nimport {CssSelector} from './projection';\nimport {RNode} from './renderer';\nimport {LView, TView} from './view';\n\n\n\n/**\n * TNodeType corresponds to the {@link TNode} `type` property.\n */\nexport const enum TNodeType {\n  /**\n   * The TNode contains information about an {@link LContainer} for embedded views.\n   */\n  Container = 0,\n  /**\n   * The TNode contains information about an `<ng-content>` projection\n   */\n  Projection = 1,\n  /**\n   * The TNode contains information about an {@link LView}\n   */\n  View = 2,\n  /**\n   * The TNode contains information about a DOM element aka {@link RNode}.\n   */\n  Element = 3,\n  /**\n   * The TNode contains information about an `<ng-container>` element {@link RNode}.\n   */\n  ElementContainer = 4,\n  /**\n   * The TNode contains information about an ICU comment used in `i18n`.\n   */\n  IcuContainer = 5,\n}\n\n/**\n * Corresponds to the TNode.flags property.\n */\nexport const enum TNodeFlags {\n  /** Bit #1 - This bit is set if the node is a host for any directive (including a component) */\n  isDirectiveHost = 0x1,\n\n  /**\n   * Bit #2 - This bit is set if the node is a host for a component.\n   *\n   * Setting this bit implies that the `isDirectiveHost` bit is set as well.\n   * */\n  isComponentHost = 0x2,\n\n  /** Bit #3 - This bit is set if the node has been projected */\n  isProjected = 0x4,\n\n  /** Bit #4 - This bit is set if any directive on this node has content queries */\n  hasContentQuery = 0x8,\n\n  /** Bit #5 - This bit is set if the node has any \"class\" inputs */\n  hasClassInput = 0x10,\n\n  /** Bit #6 - This bit is set if the node has any \"style\" inputs */\n  hasStyleInput = 0x20,\n\n  /** Bit #7 This bit is set if the node has been detached by i18n */\n  isDetached = 0x40,\n\n  /**\n   * Bit #8 - This bit is set if the node has directives with host bindings.\n   *\n   * This flags allows us to guard host-binding logic and invoke it only on nodes\n   * that actually have directives with host bindings.\n   */\n  hasHostBindings = 0x80,\n}\n\n/**\n * Corresponds to the TNode.providerIndexes property.\n */\nexport const enum TNodeProviderIndexes {\n  /** The index of the first provider on this node is encoded on the least significant bits */\n  ProvidersStartIndexMask = 0b00000000000000001111111111111111,\n\n  /** The count of view providers from the component on this node is encoded on the 16 most\n     significant bits */\n  CptViewProvidersCountShift = 16,\n  CptViewProvidersCountShifter = 0b00000000000000010000000000000000,\n}\n/**\n * A set of marker values to be used in the attributes arrays. These markers indicate that some\n * items are not regular attributes and the processing should be adapted accordingly.\n */\nexport const enum AttributeMarker {\n  /**\n   * An implicit marker which indicates that the value in the array are of `attributeKey`,\n   * `attributeValue` format.\n   *\n   * NOTE: This is implicit as it is the type when no marker is present in array. We indicate that\n   * it should not be present at runtime by the negative number.\n   */\n  ImplicitAttributes = -1,\n\n  /**\n   * Marker indicates that the following 3 values in the attributes array are:\n   * namespaceUri, attributeName, attributeValue\n   * in that order.\n   */\n  NamespaceURI = 0,\n\n  /**\n    * Signals class declaration.\n    *\n    * Each value following `Classes` designates a class name to include on the element.\n    * ## Example:\n    *\n    * Given:\n    * ```\n    * <div class=\"foo bar baz\">...<d/vi>\n    * ```\n    *\n    * the generated code is:\n    * ```\n    * var _c1 = [AttributeMarker.Classes, 'foo', 'bar', 'baz'];\n    * ```\n    */\n  Classes = 1,\n\n  /**\n   * Signals style declaration.\n   *\n   * Each pair of values following `Styles` designates a style name and value to include on the\n   * element.\n   * ## Example:\n   *\n   * Given:\n   * ```\n   * <div style=\"width:100px; height:200px; color:red\">...</div>\n   * ```\n   *\n   * the generated code is:\n   * ```\n   * var _c1 = [AttributeMarker.Styles, 'width', '100px', 'height'. '200px', 'color', 'red'];\n   * ```\n   */\n  Styles = 2,\n\n  /**\n   * Signals that the following attribute names were extracted from input or output bindings.\n   *\n   * For example, given the following HTML:\n   *\n   * ```\n   * <div moo=\"car\" [foo]=\"exp\" (bar)=\"doSth()\">\n   * ```\n   *\n   * the generated code is:\n   *\n   * ```\n   * var _c1 = ['moo', 'car', AttributeMarker.Bindings, 'foo', 'bar'];\n   * ```\n   */\n  Bindings = 3,\n\n  /**\n   * Signals that the following attribute names were hoisted from an inline-template declaration.\n   *\n   * For example, given the following HTML:\n   *\n   * ```\n   * <div *ngFor=\"let value of values; trackBy:trackBy\" dirA [dirB]=\"value\">\n   * ```\n   *\n   * the generated code for the `template()` instruction would include:\n   *\n   * ```\n   * ['dirA', '', AttributeMarker.Bindings, 'dirB', AttributeMarker.Template, 'ngFor', 'ngForOf',\n   * 'ngForTrackBy', 'let-value']\n   * ```\n   *\n   * while the generated code for the `element()` instruction inside the template function would\n   * include:\n   *\n   * ```\n   * ['dirA', '', AttributeMarker.Bindings, 'dirB']\n   * ```\n   */\n  Template = 4,\n\n  /**\n   * Signals that the following attribute is `ngProjectAs` and its value is a parsed `CssSelector`.\n   *\n   * For example, given the following HTML:\n   *\n   * ```\n   * <h1 attr=\"value\" ngProjectAs=\"[title]\">\n   * ```\n   *\n   * the generated code for the `element()` instruction would include:\n   *\n   * ```\n   * ['attr', 'value', AttributeMarker.ProjectAs, ['', 'title', '']]\n   * ```\n   */\n  ProjectAs = 5,\n\n  /**\n   * Signals that the following attribute will be translated by runtime i18n\n   *\n   * For example, given the following HTML:\n   *\n   * ```\n   * <div moo=\"car\" foo=\"value\" i18n-foo [bar]=\"binding\" i18n-bar>\n   * ```\n   *\n   * the generated code is:\n   *\n   * ```\n   * var _c1 = ['moo', 'car', AttributeMarker.I18n, 'foo', 'bar'];\n   */\n  I18n = 6,\n}\n\n/**\n * A combination of:\n * - Attribute names and values.\n * - Special markers acting as flags to alter attributes processing.\n * - Parsed ngProjectAs selectors.\n */\nexport type TAttributes = (string | AttributeMarker | CssSelector)[];\n\n/**\n * Constants that are associated with a view. Includes:\n * - Attribute arrays.\n * - Local definition arrays.\n */\nexport type TConstants = (TAttributes | string)[];\n\n/**\n * Binding data (flyweight) for a particular node that is shared between all templates\n * of a specific type.\n *\n * If a property is:\n *    - PropertyAliases: that property's data was generated and this is it\n *    - Null: that property's data was already generated and nothing was found.\n *    - Undefined: that property's data has not yet been generated\n *\n * see: https://en.wikipedia.org/wiki/Flyweight_pattern for more on the Flyweight pattern\n */\nexport interface TNode {\n  /** The type of the TNode. See TNodeType. */\n  type: TNodeType;\n\n  /**\n   * Index of the TNode in TView.data and corresponding native element in LView.\n   *\n   * This is necessary to get from any TNode to its corresponding native element when\n   * traversing the node tree.\n   *\n   * If index is -1, this is a dynamically created container node or embedded view node.\n   */\n  index: number;\n\n  /**\n   * The index of the closest injector in this node's LView.\n   *\n   * If the index === -1, there is no injector on this node or any ancestor node in this view.\n   *\n   * If the index !== -1, it is the index of this node's injector OR the index of a parent injector\n   * in the same view. We pass the parent injector index down the node tree of a view so it's\n   * possible to find the parent injector without walking a potentially deep node tree. Injector\n   * indices are not set across view boundaries because there could be multiple component hosts.\n   *\n   * If tNode.injectorIndex === tNode.parent.injectorIndex, then the index belongs to a parent\n   * injector.\n   */\n  injectorIndex: number;\n\n  /**\n   * Stores starting index of the directives.\n   */\n  directiveStart: number;\n\n  /**\n   * Stores final exclusive index of the directives.\n   */\n  directiveEnd: number;\n\n  /**\n   * Stores the last directive which had a styling instruction.\n   *\n   * Initial value of this is `-1` which means that no `hostBindings` styling instruction has\n   * executed. As `hostBindings` instructions execute they set the value to the index of the\n   * `DirectiveDef` which contained the last `hostBindings` styling instruction.\n   *\n   * Valid values are:\n   * - `-1` No `hostBindings` instruction has executed.\n   * - `directiveStart <= directiveStylingLast < directiveEnd`: Points to the `DirectiveDef` of the\n   *   last styling instruction which executed in the `hostBindings`.\n   *\n   * This data is needed so that styling instructions know which static styling data needs to be\n   * collected from the `DirectiveDef.hostAttrs`. A styling instruction needs to collect all data\n   * since last styling instruction.\n   */\n  directiveStylingLast: number;\n\n  /**\n   * Stores indexes of property bindings. This field is only set in the ngDevMode and holds indexes\n   * of property bindings so TestBed can get bound property metadata for a given node.\n   */\n  propertyBindings: number[]|null;\n\n  /**\n   * Stores if Node isComponent, isProjected, hasContentQuery, hasClassInput and hasStyleInput etc.\n   */\n  flags: TNodeFlags;\n\n  /**\n   * This number stores two values using its bits:\n   *\n   * - the index of the first provider on that node (first 16 bits)\n   * - the count of view providers from the component on this node (last 16 bits)\n   */\n  // TODO(misko): break this into actual vars.\n  providerIndexes: TNodeProviderIndexes;\n\n  /** The tag name associated with this node. */\n  tagName: string|null;\n\n  /**\n   * Attributes associated with an element. We need to store attributes to support various use-cases\n   * (attribute injection, content projection with selectors, directives matching).\n   * Attributes are stored statically because reading them from the DOM would be way too slow for\n   * content projection and queries.\n   *\n   * Since attrs will always be calculated first, they will never need to be marked undefined by\n   * other instructions.\n   *\n   * For regular attributes a name of an attribute and its value alternate in the array.\n   * e.g. ['role', 'checkbox']\n   * This array can contain flags that will indicate \"special attributes\" (attributes with\n   * namespaces, attributes extracted from bindings and outputs).\n   */\n  attrs: TAttributes|null;\n\n  /**\n   * Same as `TNode.attrs` but contains merged data across all directive host bindings.\n   *\n   * We need to keep `attrs` as unmerged so that it can be used for attribute selectors.\n   * We merge attrs here so that it can be used in a performant way for initial rendering.\n   *\n   * The `attrs` are merged in first pass in following order:\n   * - Component's `hostAttrs`\n   * - Directives' `hostAttrs`\n   * - Template `TNode.attrs` associated with the current `TNode`.\n   */\n  mergedAttrs: TAttributes|null;\n\n  /**\n   * A set of local names under which a given element is exported in a template and\n   * visible to queries. An entry in this array can be created for different reasons:\n   * - an element itself is referenced, ex.: `<div #foo>`\n   * - a component is referenced, ex.: `<my-cmpt #foo>`\n   * - a directive is referenced, ex.: `<my-cmpt #foo=\"directiveExportAs\">`.\n   *\n   * A given element might have different local names and those names can be associated\n   * with a directive. We store local names at even indexes while odd indexes are reserved\n   * for directive index in a view (or `-1` if there is no associated directive).\n   *\n   * Some examples:\n   * - `<div #foo>` => `[\"foo\", -1]`\n   * - `<my-cmpt #foo>` => `[\"foo\", myCmptIdx]`\n   * - `<my-cmpt #foo #bar=\"directiveExportAs\">` => `[\"foo\", myCmptIdx, \"bar\", directiveIdx]`\n   * - `<div #foo #bar=\"directiveExportAs\">` => `[\"foo\", -1, \"bar\", directiveIdx]`\n   */\n  localNames: (string|number)[]|null;\n\n  /** Information about input properties that need to be set once from attribute data. */\n  initialInputs: InitialInputData|null|undefined;\n\n  /**\n   * Input data for all directives on this node. `null` means that there are no directives with\n   * inputs on this node.\n   */\n  inputs: PropertyAliases|null;\n\n  /**\n   * Output data for all directives on this node. `null` means that there are no directives with\n   * outputs on this node.\n   */\n  outputs: PropertyAliases|null;\n\n  /**\n   * The TView or TViews attached to this node.\n   *\n   * If this TNode corresponds to an LContainer with inline views, the container will\n   * need to store separate static data for each of its view blocks (TView[]). Otherwise,\n   * nodes in inline views with the same index as nodes in their parent views will overwrite\n   * each other, as they are in the same template.\n   *\n   * Each index in this array corresponds to the static data for a certain\n   * view. So if you had V(0) and V(1) in a container, you might have:\n   *\n   * [\n   *   [{tagName: 'div', attrs: ...}, null],     // V(0) TView\n   *   [{tagName: 'button', attrs ...}, null]    // V(1) TView\n   *\n   * If this TNode corresponds to an LContainer with a template (e.g. structural\n   * directive), the template's TView will be stored here.\n   *\n   * If this TNode corresponds to an element, tViews will be null .\n   */\n  tViews: TView|TView[]|null;\n\n  /**\n   * The next sibling node. Necessary so we can propagate through the root nodes of a view\n   * to insert them or remove them from the DOM.\n   */\n  next: TNode|null;\n\n  /**\n   * The next projected sibling. Since in Angular content projection works on the node-by-node basis\n   * the act of projecting nodes might change nodes relationship at the insertion point (target\n   * view). At the same time we need to keep initial relationship between nodes as expressed in\n   * content view.\n   */\n  projectionNext: TNode|null;\n\n  /**\n   * First child of the current node.\n   *\n   * For component nodes, the child will always be a ContentChild (in same view).\n   * For embedded view nodes, the child will be in their child view.\n   */\n  child: TNode|null;\n\n  /**\n   * Parent node (in the same view only).\n   *\n   * We need a reference to a node's parent so we can append the node to its parent's native\n   * element at the appropriate time.\n   *\n   * If the parent would be in a different view (e.g. component host), this property will be null.\n   * It's important that we don't try to cross component boundaries when retrieving the parent\n   * because the parent will change (e.g. index, attrs) depending on where the component was\n   * used (and thus shouldn't be stored on TNode). In these cases, we retrieve the parent through\n   * LView.node instead (which will be instance-specific).\n   *\n   * If this is an inline view node (V), the parent will be its container.\n   */\n  parent: TElementNode|TContainerNode|null;\n\n  /**\n   * List of projected TNodes for a given component host element OR index into the said nodes.\n   *\n   * For easier discussion assume this example:\n   * `<parent>`'s view definition:\n   * ```\n   * <child id=\"c1\">content1</child>\n   * <child id=\"c2\"><span>content2</span></child>\n   * ```\n   * `<child>`'s view definition:\n   * ```\n   * <ng-content id=\"cont1\"></ng-content>\n   * ```\n   *\n   * If `Array.isArray(projection)` then `TNode` is a host element:\n   * - `projection` stores the content nodes which are to be projected.\n   *    - The nodes represent categories defined by the selector: For example:\n   *      `<ng-content/><ng-content select=\"abc\"/>` would represent the heads for `<ng-content/>`\n   *      and `<ng-content select=\"abc\"/>` respectively.\n   *    - The nodes we store in `projection` are heads only, we used `.next` to get their\n   *      siblings.\n   *    - The nodes `.next` is sorted/rewritten as part of the projection setup.\n   *    - `projection` size is equal to the number of projections `<ng-content>`. The size of\n   *      `c1` will be `1` because `<child>` has only one `<ng-content>`.\n   * - we store `projection` with the host (`c1`, `c2`) rather than the `<ng-content>` (`cont1`)\n   *   because the same component (`<child>`) can be used in multiple locations (`c1`, `c2`) and as\n   *   a result have different set of nodes to project.\n   * - without `projection` it would be difficult to efficiently traverse nodes to be projected.\n   *\n   * If `typeof projection == 'number'` then `TNode` is a `<ng-content>` element:\n   * - `projection` is an index of the host's `projection`Nodes.\n   *   - This would return the first head node to project:\n   *     `getHost(currentTNode).projection[currentTNode.projection]`.\n   * - When projecting nodes the parent node retrieved may be a `<ng-content>` node, in which case\n   *   the process is recursive in nature.\n   *\n   * If `projection` is of type `RNode[][]` than we have a collection of native nodes passed as\n   * projectable nodes during dynamic component creation.\n   */\n  projection: (TNode|RNode[])[]|number|null;\n\n  /**\n   * A collection of all style static values for an element.\n   *\n   * This field will be populated if and when:\n   *\n   * - There are one or more initial styles on an element (e.g. `<div style=\"width:200px\">`)\n   */\n  styles: string|null;\n\n  /**\n   * A `KeyValueArray` version of residual `styles`.\n   *\n   * When there are styling instructions than each instruction stores the static styling\n   * which is of lower priority than itself. This means that there may be a higher priority styling\n   * than the instruction.\n   *\n   * Imagine:\n   * ```\n   * <div style=\"color: highest;\" my-dir>\n   *\n   * @Directive({\n   *   host: {\n   *     style: 'color: lowest; ',\n   *     '[styles.color]': 'exp' // ÉµÉµstyleProp('color', ctx.exp);\n   *   }\n   * })\n   * ```\n   *\n   * In the above case:\n   * - `color: lowest` is stored with `ÉµÉµstyleProp('color', ctx.exp);` instruction\n   * -  `color: highest` is the residual and is stored here.\n   *\n   * - `undefined': not initialized.\n   * - `null`: initialized but `styles` is `null`\n   * - `KeyValueArray`: parsed version of `styles`.\n   */\n  residualStyles: KeyValueArray<any>|undefined|null;\n\n  /**\n   * A collection of all class static values for an element.\n   *\n   * This field will be populated if and when:\n   *\n   * - There are one or more initial classes on an element (e.g. `<div class=\"one two three\">`)\n   */\n  classes: string|null;\n\n  /**\n   * A `KeyValueArray` version of residual `classes`.\n   *\n   * Same as `TNode.residualStyles` but for classes.\n   *\n   * - `undefined': not initialized.\n   * - `null`: initialized but `classes` is `null`\n   * - `KeyValueArray`: parsed version of `classes`.\n   */\n  residualClasses: KeyValueArray<any>|undefined|null;\n\n  /**\n   * Stores the head/tail index of the class bindings.\n   *\n   * - If no bindings, the head and tail will both be 0.\n   * - If there are template bindings, stores the head/tail of the class bindings in the template.\n   * - If no template bindings but there are host bindings, the head value will point to the last\n   *   host binding for \"class\" (not the head of the linked list), tail will be 0.\n   *\n   * See: `style_binding_list.ts` for details.\n   *\n   * This is used by `insertTStylingBinding` to know where the next styling binding should be\n   * inserted so that they can be sorted in priority order.\n   */\n  classBindings: TStylingRange;\n\n  /**\n   * Stores the head/tail index of the class bindings.\n   *\n   * - If no bindings, the head and tail will both be 0.\n   * - If there are template bindings, stores the head/tail of the style bindings in the template.\n   * - If no template bindings but there are host bindings, the head value will point to the last\n   *   host binding for \"style\" (not the head of the linked list), tail will be 0.\n   *\n   * See: `style_binding_list.ts` for details.\n   *\n   * This is used by `insertTStylingBinding` to know where the next styling binding should be\n   * inserted so that they can be sorted in priority order.\n   */\n  styleBindings: TStylingRange;\n}\n\n/** Static data for an element  */\nexport interface TElementNode extends TNode {\n  /** Index in the data[] array */\n  index: number;\n  child: TElementNode|TTextNode|TElementContainerNode|TContainerNode|TProjectionNode|null;\n  /**\n   * Element nodes will have parents unless they are the first node of a component or\n   * embedded view (which means their parent is in a different view and must be\n   * retrieved using viewData[HOST_NODE]).\n   */\n  parent: TElementNode|TElementContainerNode|null;\n  tViews: null;\n\n  /**\n   * If this is a component TNode with projection, this will be an array of projected\n   * TNodes or native nodes (see TNode.projection for more info). If it's a regular element node or\n   * a component without projection, it will be null.\n   */\n  projection: (TNode|RNode[])[]|null;\n}\n\n/** Static data for a text node */\nexport interface TTextNode extends TNode {\n  /** Index in the data[] array */\n  index: number;\n  child: null;\n  /**\n   * Text nodes will have parents unless they are the first node of a component or\n   * embedded view (which means their parent is in a different view and must be\n   * retrieved using LView.node).\n   */\n  parent: TElementNode|TElementContainerNode|null;\n  tViews: null;\n  projection: null;\n}\n\n/** Static data for an LContainer */\nexport interface TContainerNode extends TNode {\n  /**\n   * Index in the data[] array.\n   *\n   * If it's -1, this is a dynamically created container node that isn't stored in\n   * data[] (e.g. when you inject ViewContainerRef) .\n   */\n  index: number;\n  child: null;\n\n  /**\n   * Container nodes will have parents unless:\n   *\n   * - They are the first node of a component or embedded view\n   * - They are dynamically created\n   */\n  parent: TElementNode|TElementContainerNode|null;\n  tViews: TView|TView[]|null;\n  projection: null;\n}\n\n/** Static data for an <ng-container> */\nexport interface TElementContainerNode extends TNode {\n  /** Index in the LView[] array. */\n  index: number;\n  child: TElementNode|TTextNode|TContainerNode|TElementContainerNode|TProjectionNode|null;\n  parent: TElementNode|TElementContainerNode|null;\n  tViews: null;\n  projection: null;\n}\n\n/** Static data for an ICU expression */\nexport interface TIcuContainerNode extends TNode {\n  /** Index in the LView[] array. */\n  index: number;\n  child: TElementNode|TTextNode|null;\n  parent: TElementNode|TElementContainerNode|null;\n  tViews: null;\n  projection: null;\n  /**\n   * Indicates the current active case for an ICU expression.\n   * It is null when there is no active case.\n   */\n  activeCaseIndex: number|null;\n}\n\n/** Static data for a view  */\nexport interface TViewNode extends TNode {\n  /** If -1, it's a dynamically created view. Otherwise, it is the view block ID. */\n  index: number;\n  child: TElementNode|TTextNode|TElementContainerNode|TContainerNode|TProjectionNode|null;\n  parent: TContainerNode|null;\n  tViews: null;\n  projection: null;\n}\n\n/** Static data for an LProjectionNode  */\nexport interface TProjectionNode extends TNode {\n  /** Index in the data[] array */\n  child: null;\n  /**\n   * Projection nodes will have parents unless they are the first node of a component\n   * or embedded view (which means their parent is in a different view and must be\n   * retrieved using LView.node).\n   */\n  parent: TElementNode|TElementContainerNode|null;\n  tViews: null;\n\n  /** Index of the projection node. (See TNode.projection for more info.) */\n  projection: number;\n}\n\n/**\n * A union type representing all TNode types that can host a directive.\n */\nexport type TDirectiveHostNode = TElementNode | TContainerNode | TElementContainerNode;\n\n/**\n * This mapping is necessary so we can set input properties and output listeners\n * properly at runtime when property names are minified or aliased.\n *\n * Key: unminified / public input or output name\n * Value: array containing minified / internal name and related directive index\n *\n * The value must be an array to support inputs and outputs with the same name\n * on the same node.\n */\nexport type PropertyAliases = {\n  // This uses an object map because using the Map type would be too slow\n  [key: string]: PropertyAliasValue\n};\n\n/**\n * Store the runtime input or output names for all the directives.\n *\n * i+0: directive instance index\n * i+1: privateName\n *\n * e.g. [0, 'change-minified']\n */\nexport type PropertyAliasValue = (number | string)[];\n\n/**\n * This array contains information about input properties that\n * need to be set once from attribute data. It's ordered by\n * directive index (relative to element) so it's simple to\n * look up a specific directive's initial input data.\n *\n * Within each sub-array:\n *\n * i+0: attribute name\n * i+1: minified/internal input name\n * i+2: initial value\n *\n * If a directive on a node does not have any input properties\n * that should be set from attributes, its index is set to null\n * to avoid a sparse array.\n *\n * e.g. [null, ['role-min', 'minified-input', 'button']]\n */\nexport type InitialInputData = (InitialInputs | null)[];\n\n/**\n * Used by InitialInputData to store input properties\n * that should be set once from attributes.\n *\n * i+0: attribute name\n * i+1: minified/internal input name\n * i+2: initial value\n *\n * e.g. ['role-min', 'minified-input', 'button']\n */\nexport type InitialInputs = string[];\n\n// Note: This hack is necessary so we don't erroneously get a circular dependency\n// failure based on types.\nexport const unusedValueExportToPlacateAjd = 1;\n\n/**\n * Type representing a set of TNodes that can have local refs (`#foo`) placed on them.\n */\nexport type TNodeWithLocalRefs = TContainerNode | TElementNode | TElementContainerNode;\n\n/**\n * Type for a function that extracts a value for a local refs.\n * Example:\n * - `<div #nativeDivEl>` - `nativeDivEl` should point to the native `<div>` element;\n * - `<ng-template #tplRef>` - `tplRef` should point to the `TemplateRef` instance;\n */\nexport type LocalRefExtractor = (tNode: TNodeWithLocalRefs, currentView: LView) => any;\n\n/**\n * Returns `true` if the `TNode` has a directive which has `@Input()` for `class` binding.\n *\n * ```\n * <div my-dir [class]=\"exp\"></div>\n * ```\n * and\n * ```\n * @Directive({\n * })\n * class MyDirective {\n *   @Input()\n *   class: string;\n * }\n * ```\n *\n * In the above case it is necessary to write the reconciled styling information into the\n * directive's input.\n *\n * @param tNode\n */\nexport function hasClassInput(tNode: TNode) {\n  return (tNode.flags & TNodeFlags.hasClassInput) !== 0;\n}\n\n/**\n * Returns `true` if the `TNode` has a directive which has `@Input()` for `style` binding.\n *\n * ```\n * <div my-dir [style]=\"exp\"></div>\n * ```\n * and\n * ```\n * @Directive({\n * })\n * class MyDirective {\n *   @Input()\n *   class: string;\n * }\n * ```\n *\n * In the above case it is necessary to write the reconciled styling information into the\n * directive's input.\n *\n * @param tNode\n */\nexport function hasStyleInput(tNode: TNode) {\n  return (tNode.flags & TNodeFlags.hasStyleInput) !== 0;\n}\n","\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\n/**\n * Expresses a single CSS Selector.\n *\n * Beginning of array\n * - First index: element name\n * - Subsequent odd indices: attr keys\n * - Subsequent even indices: attr values\n *\n * After SelectorFlags.CLASS flag\n * - Class name values\n *\n * SelectorFlags.NOT flag\n * - Changes the mode to NOT\n * - Can be combined with other flags to set the element / attr / class mode\n *\n * e.g. SelectorFlags.NOT | SelectorFlags.ELEMENT\n *\n * Example:\n * Original: `div.foo.bar[attr1=val1][attr2]`\n * Parsed: ['div', 'attr1', 'val1', 'attr2', '', SelectorFlags.CLASS, 'foo', 'bar']\n *\n * Original: 'div[attr1]:not(.foo[attr2])\n * Parsed: [\n *  'div', 'attr1', '',\n *  SelectorFlags.NOT | SelectorFlags.ATTRIBUTE 'attr2', '', SelectorFlags.CLASS, 'foo'\n * ]\n *\n * See more examples in node_selector_matcher_spec.ts\n */\nexport type CssSelector = (string | SelectorFlags)[];\n\n/**\n * A list of CssSelectors.\n *\n * A directive or component can have multiple selectors. This type is used for\n * directive defs so any of the selectors in the list will match that directive.\n *\n * Original: 'form, [ngForm]'\n * Parsed: [['form'], ['', 'ngForm', '']]\n */\nexport type CssSelectorList = CssSelector[];\n\n/**\n * List of slots for a projection. A slot can be either based on a parsed CSS selector\n * which will be used to determine nodes which are projected into that slot.\n *\n * When set to \"*\", the slot is reserved and can be used for multi-slot projection\n * using {@link ViewContainerRef#createComponent}. The last slot that specifies the\n * wildcard selector will retrieve all projectable nodes which do not match any selector.\n */\nexport type ProjectionSlots = (CssSelectorList | '*')[];\n\n/** Flags used to build up CssSelectors */\nexport const enum SelectorFlags {\n  /** Indicates this is the beginning of a new negative selector */\n  NOT = 0b0001,\n\n  /** Mode for matching attributes */\n  ATTRIBUTE = 0b0010,\n\n  /** Mode for matching tag names */\n  ELEMENT = 0b0100,\n\n  /** Mode for matching class names */\n  CLASS = 0b1000,\n}\n\n// Note: This hack is necessary so we don't erroneously get a circular dependency\n// failure based on types.\nexport const unusedValueExportToPlacateAjd = 1;\n","/**\n* @license\n* Copyright Google Inc. All Rights Reserved.\n*\n* Use of this source code is governed by an MIT-style license that can be\n* found in the LICENSE file at https://angular.io/license\n*/\n\nimport {assertNotEqual} from '../../util/assert';\nimport {CharCode} from '../../util/char_code';\n\n\n/**\n * Returns an index of `classToSearch` in `className` taking token boundaries into account.\n *\n * `classIndexOf('AB A', 'A', 0)` will be 3 (not 0 since `AB!==A`)\n *\n * @param className A string containing classes (whitespace separated)\n * @param classToSearch A class name to locate\n * @param startingIndex Starting location of search\n * @returns an index of the located class (or -1 if not found)\n */\nexport function classIndexOf(\n    className: string, classToSearch: string, startingIndex: number): number {\n  ngDevMode && assertNotEqual(classToSearch, '', 'can not look for \"\" string.');\n  let end = className.length;\n  while (true) {\n    const foundIndex = className.indexOf(classToSearch, startingIndex);\n    if (foundIndex === -1) return foundIndex;\n    if (foundIndex === 0 || className.charCodeAt(foundIndex - 1) <= CharCode.SPACE) {\n      // Ensure that it has leading whitespace\n      const length = classToSearch.length;\n      if (foundIndex + length === end ||\n          className.charCodeAt(foundIndex + length) <= CharCode.SPACE) {\n        // Ensure that it has trailing whitespace\n        return foundIndex;\n      }\n    }\n    // False positive, keep searching from where we left off.\n    startingIndex = foundIndex + 1;\n  }\n}","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport '../util/ng_dev_mode';\n\nimport {assertDefined, assertEqual, assertNotEqual} from '../util/assert';\n\nimport {AttributeMarker, TAttributes, TNode, TNodeType, unusedValueExportToPlacateAjd as unused1} from './interfaces/node';\nimport {CssSelector, CssSelectorList, SelectorFlags, unusedValueExportToPlacateAjd as unused2} from './interfaces/projection';\nimport {classIndexOf} from './styling/class_differ';\nimport {isNameOnlyAttributeMarker} from './util/attrs_utils';\n\nconst unusedValueToPlacateAjd = unused1 + unused2;\n\nconst NG_TEMPLATE_SELECTOR = 'ng-template';\n\n/**\n * Search the `TAttributes` to see if it contains `cssClassToMatch` (case insensitive)\n *\n * @param attrs `TAttributes` to search through.\n * @param cssClassToMatch class to match (lowercase)\n * @param isProjectionMode Whether or not class matching should look into the attribute `class` in\n *    addition to the `AttributeMarker.Classes`.\n */\nfunction isCssClassMatching(\n    attrs: TAttributes, cssClassToMatch: string, isProjectionMode: boolean): boolean {\n  // TODO(misko): The fact that this function needs to know about `isProjectionMode` seems suspect.\n  // It is strange to me that sometimes the class information comes in form of `class` attribute\n  // and sometimes in form of `AttributeMarker.Classes`. Some investigation is needed to determine\n  // if that is the right behavior.\n  ngDevMode &&\n      assertEqual(\n          cssClassToMatch, cssClassToMatch.toLowerCase(), 'Class name expected to be lowercase.');\n  let i = 0;\n  while (i < attrs.length) {\n    let item = attrs[i++];\n    if (isProjectionMode && item === 'class') {\n      item = attrs[i] as string;\n      if (classIndexOf(item.toLowerCase(), cssClassToMatch, 0) !== -1) {\n        return true;\n      }\n    } else if (item === AttributeMarker.Classes) {\n      // We found the classes section. Start searching for the class.\n      while (i < attrs.length && typeof(item = attrs[i++]) == 'string') {\n        // while we have strings\n        if (item.toLowerCase() === cssClassToMatch) return true;\n      }\n      return false;\n    }\n  }\n  return false;\n}\n\n/**\n * Function that checks whether a given tNode matches tag-based selector and has a valid type.\n *\n * Matching can be performed in 2 modes: projection mode (when we project nodes) and regular\n * directive matching mode:\n * - in the \"directive matching\" mode we do _not_ take TContainer's tagName into account if it is\n * different from NG_TEMPLATE_SELECTOR (value different from NG_TEMPLATE_SELECTOR indicates that a\n * tag name was extracted from * syntax so we would match the same directive twice);\n * - in the \"projection\" mode, we use a tag name potentially extracted from the * syntax processing\n * (applicable to TNodeType.Container only).\n */\nfunction hasTagAndTypeMatch(\n    tNode: TNode, currentSelector: string, isProjectionMode: boolean): boolean {\n  const tagNameToCompare = tNode.type === TNodeType.Container && !isProjectionMode ?\n      NG_TEMPLATE_SELECTOR :\n      tNode.tagName;\n  return currentSelector === tagNameToCompare;\n}\n\n/**\n * A utility function to match an Ivy node static data against a simple CSS selector\n *\n * @param node static data of the node to match\n * @param selector The selector to try matching against the node.\n * @param isProjectionMode if `true` we are matching for content projection, otherwise we are doing\n * directive matching.\n * @returns true if node matches the selector.\n */\nexport function isNodeMatchingSelector(\n    tNode: TNode, selector: CssSelector, isProjectionMode: boolean): boolean {\n  ngDevMode && assertDefined(selector[0], 'Selector should have a tag name');\n  let mode: SelectorFlags = SelectorFlags.ELEMENT;\n  const nodeAttrs = tNode.attrs || [];\n\n  // Find the index of first attribute that has no value, only a name.\n  const nameOnlyMarkerIdx = getNameOnlyMarkerIndex(nodeAttrs);\n\n  // When processing \":not\" selectors, we skip to the next \":not\" if the\n  // current one doesn't match\n  let skipToNextSelector = false;\n\n  for (let i = 0; i < selector.length; i++) {\n    const current = selector[i];\n    if (typeof current === 'number') {\n      // If we finish processing a :not selector and it hasn't failed, return false\n      if (!skipToNextSelector && !isPositive(mode) && !isPositive(current)) {\n        return false;\n      }\n      // If we are skipping to the next :not() and this mode flag is positive,\n      // it's a part of the current :not() selector, and we should keep skipping\n      if (skipToNextSelector && isPositive(current)) continue;\n      skipToNextSelector = false;\n      mode = (current as number) | (mode & SelectorFlags.NOT);\n      continue;\n    }\n\n    if (skipToNextSelector) continue;\n\n    if (mode & SelectorFlags.ELEMENT) {\n      mode = SelectorFlags.ATTRIBUTE | mode & SelectorFlags.NOT;\n      if (current !== '' && !hasTagAndTypeMatch(tNode, current, isProjectionMode) ||\n          current === '' && selector.length === 1) {\n        if (isPositive(mode)) return false;\n        skipToNextSelector = true;\n      }\n    } else {\n      const selectorAttrValue = mode & SelectorFlags.CLASS ? current : selector[++i];\n\n      // special case for matching against classes when a tNode has been instantiated with\n      // class and style values as separate attribute values (e.g. ['title', CLASS, 'foo'])\n      if ((mode & SelectorFlags.CLASS) && tNode.attrs !== null) {\n        if (!isCssClassMatching(tNode.attrs, selectorAttrValue as string, isProjectionMode)) {\n          if (isPositive(mode)) return false;\n          skipToNextSelector = true;\n        }\n        continue;\n      }\n\n      const isInlineTemplate =\n          tNode.type == TNodeType.Container && tNode.tagName !== NG_TEMPLATE_SELECTOR;\n      const attrName = (mode & SelectorFlags.CLASS) ? 'class' : current;\n      const attrIndexInNode =\n          findAttrIndexInNode(attrName, nodeAttrs, isInlineTemplate, isProjectionMode);\n\n      if (attrIndexInNode === -1) {\n        if (isPositive(mode)) return false;\n        skipToNextSelector = true;\n        continue;\n      }\n\n      if (selectorAttrValue !== '') {\n        let nodeAttrValue: string;\n        if (attrIndexInNode > nameOnlyMarkerIdx) {\n          nodeAttrValue = '';\n        } else {\n          ngDevMode && assertNotEqual(\n                           nodeAttrs[attrIndexInNode], AttributeMarker.NamespaceURI,\n                           'We do not match directives on namespaced attributes');\n          // we lowercase the attribute value to be able to match\n          // selectors without case-sensitivity\n          // (selectors are already in lowercase when generated)\n          nodeAttrValue = (nodeAttrs[attrIndexInNode + 1] as string).toLowerCase();\n        }\n\n        const compareAgainstClassName = mode & SelectorFlags.CLASS ? nodeAttrValue : null;\n        if (compareAgainstClassName &&\n                classIndexOf(compareAgainstClassName, selectorAttrValue as string, 0) !== -1 ||\n            mode & SelectorFlags.ATTRIBUTE && selectorAttrValue !== nodeAttrValue) {\n          if (isPositive(mode)) return false;\n          skipToNextSelector = true;\n        }\n      }\n    }\n  }\n\n  return isPositive(mode) || skipToNextSelector;\n}\n\nfunction isPositive(mode: SelectorFlags): boolean {\n  return (mode & SelectorFlags.NOT) === 0;\n}\n\n/**\n * Examines the attribute's definition array for a node to find the index of the\n * attribute that matches the given `name`.\n *\n * NOTE: This will not match namespaced attributes.\n *\n * Attribute matching depends upon `isInlineTemplate` and `isProjectionMode`.\n * The following table summarizes which types of attributes we attempt to match:\n *\n * ===========================================================================================================\n * Modes                   | Normal Attributes | Bindings Attributes | Template Attributes | I18n\n * Attributes\n * ===========================================================================================================\n * Inline + Projection     | YES               | YES                 | NO                  | YES\n * -----------------------------------------------------------------------------------------------------------\n * Inline + Directive      | NO                | NO                  | YES                 | NO\n * -----------------------------------------------------------------------------------------------------------\n * Non-inline + Projection | YES               | YES                 | NO                  | YES\n * -----------------------------------------------------------------------------------------------------------\n * Non-inline + Directive  | YES               | YES                 | NO                  | YES\n * ===========================================================================================================\n *\n * @param name the name of the attribute to find\n * @param attrs the attribute array to examine\n * @param isInlineTemplate true if the node being matched is an inline template (e.g. `*ngFor`)\n * rather than a manually expanded template node (e.g `<ng-template>`).\n * @param isProjectionMode true if we are matching against content projection otherwise we are\n * matching against directives.\n */\nfunction findAttrIndexInNode(\n    name: string, attrs: TAttributes | null, isInlineTemplate: boolean,\n    isProjectionMode: boolean): number {\n  if (attrs === null) return -1;\n\n  let i = 0;\n\n  if (isProjectionMode || !isInlineTemplate) {\n    let bindingsMode = false;\n    while (i < attrs.length) {\n      const maybeAttrName = attrs[i];\n      if (maybeAttrName === name) {\n        return i;\n      } else if (\n          maybeAttrName === AttributeMarker.Bindings || maybeAttrName === AttributeMarker.I18n) {\n        bindingsMode = true;\n      } else if (\n          maybeAttrName === AttributeMarker.Classes || maybeAttrName === AttributeMarker.Styles) {\n        let value = attrs[++i];\n        // We should skip classes here because we have a separate mechanism for\n        // matching classes in projection mode.\n        while (typeof value === 'string') {\n          value = attrs[++i];\n        }\n        continue;\n      } else if (maybeAttrName === AttributeMarker.Template) {\n        // We do not care about Template attributes in this scenario.\n        break;\n      } else if (maybeAttrName === AttributeMarker.NamespaceURI) {\n        // Skip the whole namespaced attribute and value. This is by design.\n        i += 4;\n        continue;\n      }\n      // In binding mode there are only names, rather than name-value pairs.\n      i += bindingsMode ? 1 : 2;\n    }\n    // We did not match the attribute\n    return -1;\n  } else {\n    return matchTemplateAttribute(attrs, name);\n  }\n}\n\nexport function isNodeMatchingSelectorList(\n    tNode: TNode, selector: CssSelectorList, isProjectionMode: boolean = false): boolean {\n  for (let i = 0; i < selector.length; i++) {\n    if (isNodeMatchingSelector(tNode, selector[i], isProjectionMode)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nexport function getProjectAsAttrValue(tNode: TNode): CssSelector|null {\n  const nodeAttrs = tNode.attrs;\n  if (nodeAttrs != null) {\n    const ngProjectAsAttrIdx = nodeAttrs.indexOf(AttributeMarker.ProjectAs);\n    // only check for ngProjectAs in attribute names, don't accidentally match attribute's value\n    // (attribute names are stored at even indexes)\n    if ((ngProjectAsAttrIdx & 1) === 0) {\n      return nodeAttrs[ngProjectAsAttrIdx + 1] as CssSelector;\n    }\n  }\n  return null;\n}\n\nfunction getNameOnlyMarkerIndex(nodeAttrs: TAttributes) {\n  for (let i = 0; i < nodeAttrs.length; i++) {\n    const nodeAttr = nodeAttrs[i];\n    if (isNameOnlyAttributeMarker(nodeAttr)) {\n      return i;\n    }\n  }\n  return nodeAttrs.length;\n}\n\nfunction matchTemplateAttribute(attrs: TAttributes, name: string): number {\n  let i = attrs.indexOf(AttributeMarker.Template);\n  if (i > -1) {\n    i++;\n    while (i < attrs.length) {\n      if (attrs[i] === name) return i;\n      i++;\n    }\n  }\n  return -1;\n}\n\n/**\n * Checks whether a selector is inside a CssSelectorList\n * @param selector Selector to be checked.\n * @param list List in which to look for the selector.\n */\nexport function isSelectorInSelectorList(selector: CssSelector, list: CssSelectorList): boolean {\n  selectorListLoop: for (let i = 0; i < list.length; i++) {\n    const currentSelectorInList = list[i];\n    if (selector.length !== currentSelectorInList.length) {\n      continue;\n    }\n    for (let j = 0; j < selector.length; j++) {\n      if (selector[j] !== currentSelectorInList[j]) {\n        continue selectorListLoop;\n      }\n    }\n    return true;\n  }\n  return false;\n}\n\nfunction maybeWrapInNotSelector(isNegativeMode: boolean, chunk: string): string {\n  return isNegativeMode ? ':not(' + chunk.trim() + ')' : chunk;\n}\n\nfunction stringifyCSSSelector(selector: CssSelector): string {\n  let result = selector[0] as string;\n  let i = 1;\n  let mode = SelectorFlags.ATTRIBUTE;\n  let currentChunk = '';\n  let isNegativeMode = false;\n  while (i < selector.length) {\n    let valueOrMarker = selector[i];\n    if (typeof valueOrMarker === 'string') {\n      if (mode & SelectorFlags.ATTRIBUTE) {\n        const attrValue = selector[++i] as string;\n        currentChunk +=\n            '[' + valueOrMarker + (attrValue.length > 0 ? '=\"' + attrValue + '\"' : '') + ']';\n      } else if (mode & SelectorFlags.CLASS) {\n        currentChunk += '.' + valueOrMarker;\n      } else if (mode & SelectorFlags.ELEMENT) {\n        currentChunk += ' ' + valueOrMarker;\n      }\n    } else {\n      //\n      // Append current chunk to the final result in case we come across SelectorFlag, which\n      // indicates that the previous section of a selector is over. We need to accumulate content\n      // between flags to make sure we wrap the chunk later in :not() selector if needed, e.g.\n      // ```\n      //  ['', Flags.CLASS, '.classA', Flags.CLASS | Flags.NOT, '.classB', '.classC']\n      // ```\n      // should be transformed to `.classA :not(.classB .classC)`.\n      //\n      // Note: for negative selector part, we accumulate content between flags until we find the\n      // next negative flag. This is needed to support a case where `:not()` rule contains more than\n      // one chunk, e.g. the following selector:\n      // ```\n      //  ['', Flags.ELEMENT | Flags.NOT, 'p', Flags.CLASS, 'foo', Flags.CLASS | Flags.NOT, 'bar']\n      // ```\n      // should be stringified to `:not(p.foo) :not(.bar)`\n      //\n      if (currentChunk !== '' && !isPositive(valueOrMarker)) {\n        result += maybeWrapInNotSelector(isNegativeMode, currentChunk);\n        currentChunk = '';\n      }\n      mode = valueOrMarker;\n      // According to CssSelector spec, once we come across `SelectorFlags.NOT` flag, the negative\n      // mode is maintained for remaining chunks of a selector.\n      isNegativeMode = isNegativeMode || !isPositive(mode);\n    }\n    i++;\n  }\n  if (currentChunk !== '') {\n    result += maybeWrapInNotSelector(isNegativeMode, currentChunk);\n  }\n  return result;\n}\n\n/**\n * Generates string representation of CSS selector in parsed form.\n *\n * ComponentDef and DirectiveDef are generated with the selector in parsed form to avoid doing\n * additional parsing at runtime (for example, for directive matching). However in some cases (for\n * example, while bootstrapping a component), a string version of the selector is required to query\n * for the host element on the page. This function takes the parsed form of a selector and returns\n * its string representation.\n *\n * @param selectorList selector in parsed form\n * @returns string representation of a given selector\n */\nexport function stringifyCSSSelectorList(selectorList: CssSelectorList): string {\n  return selectorList.map(stringifyCSSSelector).join(',');\n}","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nexport interface NO_CHANGE {\n  // This is a brand that ensures that this type can never match anything else\n  __brand__: 'NO_CHANGE';\n}\n\n/** A special value which designates that a value has not changed. */\nexport const NO_CHANGE: NO_CHANGE =\n    (typeof ngDevMode === 'undefined' || ngDevMode) ? {__brand__: 'NO_CHANGE'} : ({} as NO_CHANGE);\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {assertDefined} from '../../util/assert';\nimport {assertLView} from '../assert';\nimport {isLContainer, isLView} from '../interfaces/type_checks';\nimport {CONTEXT, FLAGS, LView, LViewFlags, PARENT, RootContext} from '../interfaces/view';\nimport {readPatchedLView} from './view_utils';\n\n\n/**\n * Gets the parent LView of the passed LView, if the PARENT is an LContainer, will get the parent of\n * that LContainer, which is an LView\n * @param lView the lView whose parent to get\n */\nexport function getLViewParent(lView: LView): LView|null {\n  ngDevMode && assertLView(lView);\n  const parent = lView[PARENT];\n  return isLContainer(parent) ? parent[PARENT] ! : parent;\n}\n\n/**\n * Retrieve the root view from any component or `LView` by walking the parent `LView` until\n * reaching the root `LView`.\n *\n * @param componentOrLView any component or `LView`\n */\nexport function getRootView(componentOrLView: LView | {}): LView {\n  ngDevMode && assertDefined(componentOrLView, 'component');\n  let lView = isLView(componentOrLView) ? componentOrLView : readPatchedLView(componentOrLView) !;\n  while (lView && !(lView[FLAGS] & LViewFlags.IsRoot)) {\n    lView = getLViewParent(lView) !;\n  }\n  ngDevMode && assertLView(lView);\n  return lView;\n}\n\n/**\n * Returns the `RootContext` instance that is associated with\n * the application where the target is situated. It does this by walking the parent views until it\n * gets to the root view, then getting the context off of that.\n *\n * @param viewOrComponent the `LView` or component to get the root context for.\n */\nexport function getRootContext(viewOrComponent: LView | {}): RootContext {\n  const rootView = getRootView(viewOrComponent);\n  ngDevMode &&\n      assertDefined(rootView[CONTEXT], 'RootView has no context. Perhaps it is disconnected?');\n  return rootView[CONTEXT] as RootContext;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {assertDataInRange, assertGreaterThan} from '../../util/assert';\nimport {executeCheckHooks, executeInitAndCheckHooks} from '../hooks';\nimport {FLAGS, HEADER_OFFSET, InitPhaseState, LView, LViewFlags, TView} from '../interfaces/view';\nimport {getCheckNoChangesMode, getLView, getSelectedIndex, getTView, setSelectedIndex} from '../state';\n\n\n/**\n * Advances to an element for later binding instructions.\n *\n * Used in conjunction with instructions like {@link property} to act on elements with specified\n * indices, for example those created with {@link element} or {@link elementStart}.\n *\n * ```ts\n * (rf: RenderFlags, ctx: any) => {\n  *   if (rf & 1) {\n  *     text(0, 'Hello');\n  *     text(1, 'Goodbye')\n  *     element(2, 'div');\n  *   }\n  *   if (rf & 2) {\n  *     advance(2); // Advance twice to the <div>.\n  *     property('title', 'test');\n  *   }\n  *  }\n  * ```\n  * @param delta Number of elements to advance forwards by.\n  *\n  * @codeGenApi\n  */\nexport function ÉµÉµadvance(delta: number): void {\n  ngDevMode && assertGreaterThan(delta, 0, 'Can only advance forward');\n  selectIndexInternal(getTView(), getLView(), getSelectedIndex() + delta, getCheckNoChangesMode());\n}\n\n/**\n * Selects an element for later binding instructions.\n * @deprecated No longer being generated, but still used in unit tests.\n * @codeGenApi\n */\nexport function ÉµÉµselect(index: number): void {\n  // TODO(misko): Remove this function as it is no longer being used.\n  selectIndexInternal(getTView(), getLView(), index, getCheckNoChangesMode());\n}\n\nexport function selectIndexInternal(\n    tView: TView, lView: LView, index: number, checkNoChangesMode: boolean) {\n  ngDevMode && assertGreaterThan(index, -1, 'Invalid index');\n  ngDevMode && assertDataInRange(lView, index + HEADER_OFFSET);\n\n  // Flush the initial hooks for elements in the view that have been added up to this point.\n  // PERF WARNING: do NOT extract this to a separate function without running benchmarks\n  if (!checkNoChangesMode) {\n    const hooksInitPhaseCompleted =\n        (lView[FLAGS] & LViewFlags.InitPhaseStateMask) === InitPhaseState.InitPhaseCompleted;\n    if (hooksInitPhaseCompleted) {\n      const preOrderCheckHooks = tView.preOrderCheckHooks;\n      if (preOrderCheckHooks !== null) {\n        executeCheckHooks(lView, preOrderCheckHooks, index);\n      }\n    } else {\n      const preOrderHooks = tView.preOrderHooks;\n      if (preOrderHooks !== null) {\n        executeInitAndCheckHooks(lView, preOrderHooks, InitPhaseState.OnInitHooksToBeRun, index);\n      }\n    }\n  }\n\n  // We must set the selected index *after* running the hooks, because hooks may have side-effects\n  // that cause other template functions to run, thus updating the selected index, which is global\n  // state. If we run `setSelectedIndex` *before* we run the hooks, in some cases the selected index\n  // will be altered by the time we leave the `ÉµÉµadvance` instruction.\n  setSelectedIndex(index);\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * `I18nMutateOpCode` defines OpCodes for `I18nMutateOpCodes` array.\n *\n * OpCodes contain three parts:\n *  1) Parent node index offset.\n *  2) Reference node index offset.\n *  3) The OpCode to execute.\n *\n * See: `I18nCreateOpCodes` for example of usage.\n */\nimport {SanitizerFn} from './sanitization';\n\nexport const enum I18nMutateOpCode {\n  /**\n   * Stores shift amount for bits 17-3 that contain reference index.\n   */\n  SHIFT_REF = 3,\n  /**\n   * Stores shift amount for bits 31-17 that contain parent index.\n   */\n  SHIFT_PARENT = 17,\n  /**\n   * Mask for OpCode\n   */\n  MASK_OPCODE = 0b111,\n\n  /**\n   * OpCode to select a node. (next OpCode will contain the operation.)\n   */\n  Select = 0b000,\n  /**\n   * OpCode to append the current node to `PARENT`.\n   */\n  AppendChild = 0b001,\n  /**\n   * OpCode to remove the `REF` node from `PARENT`.\n   */\n  Remove = 0b011,\n  /**\n   * OpCode to set the attribute of a node.\n   */\n  Attr = 0b100,\n  /**\n   * OpCode to simulate elementEnd()\n   */\n  ElementEnd = 0b101,\n  /**\n   * OpCode to read the remove OpCodes for the nested ICU\n   */\n  RemoveNestedIcu = 0b110,\n}\n\n/**\n * Marks that the next string is for element.\n *\n * See `I18nMutateOpCodes` documentation.\n */\nexport const ELEMENT_MARKER: ELEMENT_MARKER = {\n  marker: 'element'\n};\nexport interface ELEMENT_MARKER { marker: 'element'; }\n\n/**\n * Marks that the next string is for comment.\n *\n * See `I18nMutateOpCodes` documentation.\n */\nexport const COMMENT_MARKER: COMMENT_MARKER = {\n  marker: 'comment'\n};\n\nexport interface COMMENT_MARKER { marker: 'comment'; }\n\n/**\n * Array storing OpCode for dynamically creating `i18n` blocks.\n *\n * Example:\n * ```ts\n * <I18nCreateOpCode>[\n *   // For adding text nodes\n *   // ---------------------\n *   // Equivalent to:\n *   //   const node = lView[index++] = document.createTextNode('abc');\n *   //   lView[1].insertBefore(node, lView[2]);\n *   'abc', 1 << SHIFT_PARENT | 2 << SHIFT_REF | InsertBefore,\n *\n *   // Equivalent to:\n *   //   const node = lView[index++] = document.createTextNode('xyz');\n *   //   lView[1].appendChild(node);\n *   'xyz', 1 << SHIFT_PARENT | AppendChild,\n *\n *   // For adding element nodes\n *   // ---------------------\n *   // Equivalent to:\n *   //   const node = lView[index++] = document.createElement('div');\n *   //   lView[1].insertBefore(node, lView[2]);\n *   ELEMENT_MARKER, 'div', 1 << SHIFT_PARENT | 2 << SHIFT_REF | InsertBefore,\n *\n *   // Equivalent to:\n *   //   const node = lView[index++] = document.createElement('div');\n *   //   lView[1].appendChild(node);\n *   ELEMENT_MARKER, 'div', 1 << SHIFT_PARENT | AppendChild,\n *\n *   // For adding comment nodes\n *   // ---------------------\n *   // Equivalent to:\n *   //   const node = lView[index++] = document.createComment('');\n *   //   lView[1].insertBefore(node, lView[2]);\n *   COMMENT_MARKER, '', 1 << SHIFT_PARENT | 2 << SHIFT_REF | InsertBefore,\n *\n *   // Equivalent to:\n *   //   const node = lView[index++] = document.createComment('');\n *   //   lView[1].appendChild(node);\n *   COMMENT_MARKER, '', 1 << SHIFT_PARENT | AppendChild,\n *\n *   // For moving existing nodes to a different location\n *   // --------------------------------------------------\n *   // Equivalent to:\n *   //   const node = lView[1];\n *   //   lView[2].insertBefore(node, lView[3]);\n *   1 << SHIFT_REF | Select, 2 << SHIFT_PARENT | 3 << SHIFT_REF | InsertBefore,\n *\n *   // Equivalent to:\n *   //   const node = lView[1];\n *   //   lView[2].appendChild(node);\n *   1 << SHIFT_REF | Select, 2 << SHIFT_PARENT | AppendChild,\n *\n *   // For removing existing nodes\n *   // --------------------------------------------------\n *   //   const node = lView[1];\n *   //   removeChild(tView.data(1), node, lView);\n *   1 << SHIFT_REF | Remove,\n *\n *   // For writing attributes\n *   // --------------------------------------------------\n *   //   const node = lView[1];\n *   //   node.setAttribute('attr', 'value');\n *   1 << SHIFT_REF | Select, 'attr', 'value'\n *            // NOTE: Select followed by two string (vs select followed by OpCode)\n * ];\n * ```\n * NOTE:\n *   - `index` is initial location where the extra nodes should be stored in the EXPANDO section of\n * `LVIewData`.\n *\n * See: `applyI18nCreateOpCodes`;\n */\nexport interface I18nMutateOpCodes extends Array<number|string|ELEMENT_MARKER|COMMENT_MARKER|null> {\n}\n\nexport const enum I18nUpdateOpCode {\n  /**\n   * Stores shift amount for bits 17-2 that contain reference index.\n   */\n  SHIFT_REF = 2,\n  /**\n   * Mask for OpCode\n   */\n  MASK_OPCODE = 0b11,\n\n  /**\n   * OpCode to update a text node.\n   */\n  Text = 0b00,\n  /**\n   * OpCode to update a attribute of a node.\n   */\n  Attr = 0b01,\n  /**\n   * OpCode to switch the current ICU case.\n   */\n  IcuSwitch = 0b10,\n  /**\n   * OpCode to update the current ICU case.\n   */\n  IcuUpdate = 0b11,\n}\n\n/**\n * Stores DOM operations which need to be applied to update DOM render tree due to changes in\n * expressions.\n *\n * The basic idea is that `i18nExp` OpCodes capture expression changes and update a change\n * mask bit. (Bit 1 for expression 1, bit 2 for expression 2 etc..., bit 32 for expression 32 and\n * higher.) The OpCodes then compare its own change mask against the expression change mask to\n * determine if the OpCodes should execute.\n *\n * These OpCodes can be used by both the i18n block as well as ICU sub-block.\n *\n * ## Example\n *\n * Assume\n * ```ts\n *   if (rf & RenderFlags.Update) {\n *    i18nExp(ctx.exp1); // If changed set mask bit 1\n *    i18nExp(ctx.exp2); // If changed set mask bit 2\n *    i18nExp(ctx.exp3); // If changed set mask bit 3\n *    i18nExp(ctx.exp4); // If changed set mask bit 4\n *    i18nApply(0);            // Apply all changes by executing the OpCodes.\n *  }\n * ```\n * We can assume that each call to `i18nExp` sets an internal `changeMask` bit depending on the\n * index of `i18nExp`.\n *\n * ### OpCodes\n * ```ts\n * <I18nUpdateOpCodes>[\n *   // The following OpCodes represent: `<div i18n-title=\"pre{{exp1}}in{{exp2}}post\">`\n *   // If `changeMask & 0b11`\n *   //        has changed then execute update OpCodes.\n *   //        has NOT changed then skip `7` values and start processing next OpCodes.\n *   0b11, 7,\n *   // Concatenate `newValue = 'pre'+lView[bindIndex-4]+'in'+lView[bindIndex-3]+'post';`.\n *   'pre', -4, 'in', -3, 'post',\n *   // Update attribute: `elementAttribute(1, 'title', sanitizerFn(newValue));`\n *   1 << SHIFT_REF | Attr, 'title', sanitizerFn,\n *\n *   // The following OpCodes represent: `<div i18n>Hello {{exp3}}!\">`\n *   // If `changeMask & 0b100`\n *   //        has changed then execute update OpCodes.\n *   //        has NOT changed then skip `4` values and start processing next OpCodes.\n *   0b100, 4,\n *   // Concatenate `newValue = 'Hello ' + lView[bindIndex -2] + '!';`.\n *   'Hello ', -2, '!',\n *   // Update text: `lView[1].textContent = newValue;`\n *   1 << SHIFT_REF | Text,\n *\n *   // The following OpCodes represent: `<div i18n>{exp4, plural, ... }\">`\n *   // If `changeMask & 0b1000`\n *   //        has changed then execute update OpCodes.\n *   //        has NOT changed then skip `4` values and start processing next OpCodes.\n *   0b1000, 4,\n *   // Concatenate `newValue = lView[bindIndex -1];`.\n *   -1,\n *   // Switch ICU: `icuSwitchCase(lView[1], 0, newValue);`\n *   0 << SHIFT_ICU | 1 << SHIFT_REF | IcuSwitch,\n *\n *   // Note `changeMask & -1` is always true, so the IcuUpdate will always execute.\n *   -1, 1,\n *   // Update ICU: `icuUpdateCase(lView[1], 0);`\n *   0 << SHIFT_ICU | 1 << SHIFT_REF | IcuUpdate,\n *\n * ];\n * ```\n *\n */\nexport interface I18nUpdateOpCodes extends Array<string|number|SanitizerFn|null> {}\n\n/**\n * Store information for the i18n translation block.\n */\nexport interface TI18n {\n  /**\n   * Number of slots to allocate in expando.\n   *\n   * This is the max number of DOM elements which will be created by this i18n + ICU blocks. When\n   * the DOM elements are being created they are stored in the EXPANDO, so that update OpCodes can\n   * write into them.\n   */\n  vars: number;\n\n  /**\n   * A set of OpCodes which will create the Text Nodes and ICU anchors for the translation blocks.\n   *\n   * NOTE: The ICU anchors are filled in with ICU Update OpCode.\n   */\n  create: I18nMutateOpCodes;\n\n  /**\n   * A set of OpCodes which will be executed on each change detection to determine if any changes to\n   * DOM are required.\n   */\n  update: I18nUpdateOpCodes;\n\n  /**\n   * A list of ICUs in a translation block (or `null` if block has no ICUs).\n   *\n   * Example:\n   * Given: `<div i18n>You have {count, plural, ...} and {state, switch, ...}</div>`\n   * There would be 2 ICUs in this array.\n   *   1. `{count, plural, ...}`\n   *   2. `{state, switch, ...}`\n   */\n  icus: TIcu[]|null;\n}\n\n/**\n * Defines the ICU type of `select` or `plural`\n */\nexport const enum IcuType {\n  select = 0,\n  plural = 1,\n}\n\nexport interface TIcu {\n  /**\n   * Defines the ICU type of `select` or `plural`\n   */\n  type: IcuType;\n\n  /**\n   * Number of slots to allocate in expando for each case.\n   *\n   * This is the max number of DOM elements which will be created by this i18n + ICU blocks. When\n   * the DOM elements are being created they are stored in the EXPANDO, so that update OpCodes can\n   * write into them.\n   */\n  vars: number[];\n\n  /**\n   * An optional array of child/sub ICUs.\n   *\n   * In case of nested ICUs such as:\n   * ```\n   * {ï¿½0ï¿½, plural,\n   *   =0 {zero}\n   *   other {ï¿½0ï¿½ {ï¿½1ï¿½, select,\n   *                     cat {cats}\n   *                     dog {dogs}\n   *                     other {animals}\n   *                   }!\n   *   }\n   * }\n   * ```\n   * When the parent ICU is changing it must clean up child ICUs as well. For this reason it needs\n   * to know which child ICUs to run clean up for as well.\n   *\n   * In the above example this would be:\n   * ```ts\n   * [\n   *   [],   // `=0` has no sub ICUs\n   *   [1],  // `other` has one subICU at `1`st index.\n   * ]\n   * ```\n   *\n   * The reason why it is Array of Arrays is because first array represents the case, and second\n   * represents the child ICUs to clean up. There may be more than one child ICUs per case.\n   */\n  childIcus: number[][];\n\n  /**\n   * A list of case values which the current ICU will try to match.\n   *\n   * The last value is `other`\n   */\n  cases: any[];\n\n  /**\n   * A set of OpCodes to apply in order to build up the DOM render tree for the ICU\n   */\n  create: I18nMutateOpCodes[];\n\n  /**\n   * A set of OpCodes to apply in order to destroy the DOM render tree for the ICU.\n   */\n  remove: I18nMutateOpCodes[];\n\n  /**\n   * A set of OpCodes to apply in order to update the DOM render tree for the ICU bindings.\n   */\n  update: I18nUpdateOpCodes[];\n}\n\n// Note: This hack is necessary so we don't erroneously get a circular dependency\n// failure based on types.\nexport const unusedValueExportToPlacateAjd = 1;\n","/**\n* @license\n* Copyright Google Inc. All Rights Reserved.\n*\n* Use of this source code is governed by an MIT-style license that can be\n* found in the LICENSE file at https://angular.io/license\n*/\n\nimport {KeyValueArray} from '../../util/array_utils';\nimport {assertNumber, assertNumberInRange} from '../../util/assert';\n\n/**\n * Value stored in the `TData` which is needed to re-concatenate the styling.\n *\n * See: `TStylingKeyPrimitive` and `TStylingStatic`\n */\nexport type TStylingKey = TStylingKeyPrimitive | TStylingStatic;\n\n\n/**\n * The primitive portion (`TStylingStatic` removed) of the value stored in the `TData` which is\n * needed to re-concatenate the styling.\n *\n * - `string`: Stores the property name. Used with `ÉµÉµstyleProp`/`ÉµÉµclassProp` instruction.\n * - `null`: Represents map, so there is no name. Used with `ÉµÉµstyleMap`/`ÉµÉµclassMap`.\n * - `false`: Represents an ignore case. This happens when `ÉµÉµstyleProp`/`ÉµÉµclassProp` instruction\n *   is combined with directive which shadows its input `@Input('class')`. That way the binding\n *   should not participate in the styling resolution.\n */\nexport type TStylingKeyPrimitive = string | null | false;\n\n/**\n * Store the static values for the styling binding.\n *\n * The `TStylingStatic` is just `KeyValueArray` where key `\"\"` (stored at location 0) contains the\n * `TStylingKey` (stored at location 1). In other words this wraps the `TStylingKey` such that the\n * `\"\"` contains the wrapped value.\n *\n * When instructions are resolving styling they may need to look forward or backwards in the linked\n * list to resolve the value. For this reason we have to make sure that he linked list also contains\n * the static values. However the list only has space for one item per styling instruction. For this\n * reason we store the static values here as part of the `TStylingKey`. This means that the\n * resolution function when looking for a value needs to first look at the binding value, and than\n * at `TStylingKey` (if it exists).\n *\n * Imagine we have:\n *\n * ```\n * <div class=\"TEMPLATE\" my-dir>\n *\n * @Directive({\n *   host: {\n *     class: 'DIR',\n *     '[class.dynamic]': 'exp' // ÉµÉµclassProp('dynamic', ctx.exp);\n *   }\n * })\n * ```\n *\n * In the above case the linked list will contain one item:\n *\n * ```\n *   // assume binding location: 10 for `ÉµÉµclassProp('dynamic', ctx.exp);`\n *   tData[10] = <TStylingStatic>[\n *     '': 'dynamic', // This is the wrapped value of `TStylingKey`\n *     'DIR': true,   // This is the default static value of directive binding.\n *   ];\n *   tData[10 + 1] = 0; // We don't have prev/next.\n *\n *   lView[10] = undefined;     // assume `ctx.exp` is `undefined`\n *   lView[10 + 1] = undefined; // Just normalized `lView[10]`\n * ```\n *\n * So when the function is resolving styling value, it first needs to look into the linked list\n * (there is none) and than into the static `TStylingStatic` too see if there is a default value for\n * `dynamic` (there is not). Therefore it is safe to remove it.\n *\n * If setting `true` case:\n * ```\n *   lView[10] = true;     // assume `ctx.exp` is `true`\n *   lView[10 + 1] = true; // Just normalized `lView[10]`\n * ```\n * So when the function is resolving styling value, it first needs to look into the linked list\n * (there is none) and than into `TNode.residualClass` (TNode.residualStyle) which contains\n * ```\n *   tNode.residualClass = [\n *     'TEMPLATE': true,\n *   ];\n * ```\n *\n * This means that it is safe to add class.\n */\nexport interface TStylingStatic extends KeyValueArray<any> {}\n\n/**\n * This is a branded number which contains previous and next index.\n *\n * When we come across styling instructions we need to store the `TStylingKey` in the correct\n * order so that we can re-concatenate the styling value in the desired priority.\n *\n * The insertion can happen either at the:\n * - end of template as in the case of coming across additional styling instruction in the template\n * - in front of the template in the case of coming across additional instruction in the\n *   `hostBindings`.\n *\n * We use `TStylingRange` to store the previous and next index into the `TData` where the template\n * bindings can be found.\n *\n * - bit 0 is used to mark that the previous index has a duplicate for current value.\n * - bit 1 is used to mark that the next index has a duplicate for the current value.\n * - bits 2-16 are used to encode the next/tail of the template.\n * - bits 17-32 are used to encode the previous/head of template.\n *\n * NODE: *duplicate* false implies that it is statically known that this binding will not collide\n * with other bindings and therefore there is no need to check other bindings. For example the\n * bindings in `<div [style.color]=\"exp\" [style.width]=\"exp\">` will never collide and will have\n * their bits set accordingly. Previous duplicate means that we may need to check previous if the\n * current binding is `null`. Next duplicate means that we may need to check next bindings if the\n * current binding is not `null`.\n *\n * NOTE: `0` has special significance and represents `null` as in no additional pointer.\n */\nexport interface TStylingRange { __brand__: 'TStylingRange'; }\n\n/**\n * Shift and masks constants for encoding two numbers into and duplicate info into a single number.\n */\nexport const enum StylingRange {\n  /// Number of bits to shift for the previous pointer\n  PREV_SHIFT = 17,\n  /// Previous pointer mask.\n  PREV_MASK = 0xFFFE0000,\n\n  /// Number of bits to shift for the next pointer\n  NEXT_SHIFT = 2,\n  /// Next pointer mask.\n  NEXT_MASK = 0x001FFFC,\n\n  // Mask to remove nagative bit. (interpret number as positive)\n  UNSIGNED_MASK = 0x7FFF,\n\n  /**\n   * This bit is set if the previous bindings contains a binding which could possibly cause a\n   * duplicate. For example: `<div [style]=\"map\" [style.width]=\"width\">`, the `width` binding will\n   * have previous duplicate set. The implication is that if `width` binding becomes `null`, it is\n   * necessary to defer the value to `map.width`. (Because `width` overwrites `map.width`.)\n   */\n  PREV_DUPLICATE = 0x02,\n\n  /**\n   * This bit is set to if the next binding contains a binding which could possibly cause a\n   * duplicate. For example: `<div [style]=\"map\" [style.width]=\"width\">`, the `map` binding will\n   * have next duplicate set. The implication is that if `map.width` binding becomes not `null`, it\n   * is necessary to defer the value to `width`. (Because `width` overwrites `map.width`.)\n   */\n  NEXT_DUPLICATE = 0x01,\n}\n\n\nexport function toTStylingRange(prev: number, next: number): TStylingRange {\n  ngDevMode && assertNumberInRange(prev, 0, StylingRange.UNSIGNED_MASK);\n  ngDevMode && assertNumberInRange(next, 0, StylingRange.UNSIGNED_MASK);\n  return (prev << StylingRange.PREV_SHIFT | next << StylingRange.NEXT_SHIFT) as any;\n}\n\nexport function getTStylingRangePrev(tStylingRange: TStylingRange): number {\n  ngDevMode && assertNumber(tStylingRange, 'expected number');\n  return ((tStylingRange as any as number) >> StylingRange.PREV_SHIFT) & StylingRange.UNSIGNED_MASK;\n}\n\nexport function getTStylingRangePrevDuplicate(tStylingRange: TStylingRange): boolean {\n  ngDevMode && assertNumber(tStylingRange, 'expected number');\n  return ((tStylingRange as any as number) & StylingRange.PREV_DUPLICATE) ==\n      StylingRange.PREV_DUPLICATE;\n}\n\nexport function setTStylingRangePrev(\n    tStylingRange: TStylingRange, previous: number): TStylingRange {\n  ngDevMode && assertNumber(tStylingRange, 'expected number');\n  ngDevMode && assertNumberInRange(previous, 0, StylingRange.UNSIGNED_MASK);\n  return (\n      ((tStylingRange as any as number) & ~StylingRange.PREV_MASK) |\n      (previous << StylingRange.PREV_SHIFT)) as any;\n}\n\nexport function setTStylingRangePrevDuplicate(tStylingRange: TStylingRange): TStylingRange {\n  ngDevMode && assertNumber(tStylingRange, 'expected number');\n  return ((tStylingRange as any as number) | StylingRange.PREV_DUPLICATE) as any;\n}\n\nexport function getTStylingRangeNext(tStylingRange: TStylingRange): number {\n  ngDevMode && assertNumber(tStylingRange, 'expected number');\n  return ((tStylingRange as any as number) & StylingRange.NEXT_MASK) >> StylingRange.NEXT_SHIFT;\n}\n\nexport function setTStylingRangeNext(tStylingRange: TStylingRange, next: number): TStylingRange {\n  ngDevMode && assertNumber(tStylingRange, 'expected number');\n  ngDevMode && assertNumberInRange(next, 0, StylingRange.UNSIGNED_MASK);\n  return (\n      ((tStylingRange as any as number) & ~StylingRange.NEXT_MASK) |  //\n      next << StylingRange.NEXT_SHIFT) as any;\n}\n\nexport function getTStylingRangeNextDuplicate(tStylingRange: TStylingRange): boolean {\n  ngDevMode && assertNumber(tStylingRange, 'expected number');\n  return ((tStylingRange as any as number) & StylingRange.NEXT_DUPLICATE) ===\n      StylingRange.NEXT_DUPLICATE;\n}\n\nexport function setTStylingRangeNextDuplicate(tStylingRange: TStylingRange): TStylingRange {\n  ngDevMode && assertNumber(tStylingRange, 'expected number');\n  return ((tStylingRange as any as number) | StylingRange.NEXT_DUPLICATE) as any;\n}\n\nexport function getTStylingRangeTail(tStylingRange: TStylingRange): number {\n  ngDevMode && assertNumber(tStylingRange, 'expected number');\n  const next = getTStylingRangeNext(tStylingRange);\n  return next === 0 ? getTStylingRangePrev(tStylingRange) : next;\n}","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nexport function attachDebugObject(obj: any, debug: any) {\n  Object.defineProperty(obj, 'debug', {value: debug, enumerable: false});\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {AttributeMarker, ComponentTemplate} from '..';\nimport {SchemaMetadata} from '../../core';\nimport {KeyValueArray} from '../../util/array_utils';\nimport {assertDefined} from '../../util/assert';\nimport {createNamedArrayType} from '../../util/named_array_type';\nimport {initNgDevMode} from '../../util/ng_dev_mode';\nimport {ACTIVE_INDEX, ActiveIndexFlag, CONTAINER_HEADER_OFFSET, LContainer, MOVED_VIEWS, NATIVE} from '../interfaces/container';\nimport {DirectiveDefList, PipeDefList, ViewQueriesFunction} from '../interfaces/definition';\nimport {COMMENT_MARKER, ELEMENT_MARKER, I18nMutateOpCode, I18nMutateOpCodes, I18nUpdateOpCode, I18nUpdateOpCodes, TIcu} from '../interfaces/i18n';\nimport {PropertyAliases, TConstants, TContainerNode, TElementNode, TNode as ITNode, TNodeFlags, TNodeProviderIndexes, TNodeType, TViewNode} from '../interfaces/node';\nimport {SelectorFlags} from '../interfaces/projection';\nimport {TQueries} from '../interfaces/query';\nimport {RComment, RElement, RNode} from '../interfaces/renderer';\nimport {TStylingKey, TStylingRange, getTStylingRangeNext, getTStylingRangeNextDuplicate, getTStylingRangePrev, getTStylingRangePrevDuplicate} from '../interfaces/styling';\nimport {CHILD_HEAD, CHILD_TAIL, CLEANUP, CONTEXT, DECLARATION_VIEW, ExpandoInstructions, FLAGS, HEADER_OFFSET, HOST, HookData, INJECTOR, LView, LViewFlags, NEXT, PARENT, QUERIES, RENDERER, RENDERER_FACTORY, SANITIZER, TData, TVIEW, TView as ITView, TView, TViewType, T_HOST} from '../interfaces/view';\nimport {attachDebugObject} from '../util/debug_utils';\nimport {getLContainerActiveIndex, getTNode, unwrapRNode} from '../util/view_utils';\n\nconst NG_DEV_MODE = ((typeof ngDevMode === 'undefined' || !!ngDevMode) && initNgDevMode());\n\n/*\n * This file contains conditionally attached classes which provide human readable (debug) level\n * information for `LView`, `LContainer` and other internal data structures. These data structures\n * are stored internally as array which makes it very difficult during debugging to reason about the\n * current state of the system.\n *\n * Patching the array with extra property does change the array's hidden class' but it does not\n * change the cost of access, therefore this patching should not have significant if any impact in\n * `ngDevMode` mode. (see: https://jsperf.com/array-vs-monkey-patch-array)\n *\n * So instead of seeing:\n * ```\n * Array(30) [Object, 659, null, â¦]\n * ```\n *\n * You get to see:\n * ```\n * LViewDebug {\n *   views: [...],\n *   flags: {attached: true, ...}\n *   nodes: [\n *     {html: '<div id=\"123\">', ..., nodes: [\n *       {html: '<span>', ..., nodes: null}\n *     ]}\n *   ]\n * }\n * ```\n */\n\nlet LVIEW_COMPONENT_CACHE !: Map<string|null, Array<any>>;\nlet LVIEW_EMBEDDED_CACHE !: Map<string|null, Array<any>>;\nlet LVIEW_ROOT !: Array<any>;\n\ninterface TViewDebug extends ITView {\n  type: TViewType;\n}\n\n/**\n * This function clones a blueprint and creates LView.\n *\n * Simple slice will keep the same type, and we need it to be LView\n */\nexport function cloneToLViewFromTViewBlueprint(tView: TView): LView {\n  const debugTView = tView as TViewDebug;\n  const lView = getLViewToClone(debugTView.type, tView.template && tView.template.name);\n  return lView.concat(tView.blueprint) as any;\n}\n\nfunction getLViewToClone(type: TViewType, name: string | null): Array<any> {\n  switch (type) {\n    case TViewType.Root:\n      if (LVIEW_ROOT === undefined) LVIEW_ROOT = new (createNamedArrayType('LRootView'))();\n      return LVIEW_ROOT;\n    case TViewType.Component:\n      if (LVIEW_COMPONENT_CACHE === undefined) LVIEW_COMPONENT_CACHE = new Map();\n      let componentArray = LVIEW_COMPONENT_CACHE.get(name);\n      if (componentArray === undefined) {\n        componentArray = new (createNamedArrayType('LComponentView' + nameSuffix(name)))();\n        LVIEW_COMPONENT_CACHE.set(name, componentArray);\n      }\n      return componentArray;\n    case TViewType.Embedded:\n      if (LVIEW_EMBEDDED_CACHE === undefined) LVIEW_EMBEDDED_CACHE = new Map();\n      let embeddedArray = LVIEW_EMBEDDED_CACHE.get(name);\n      if (embeddedArray === undefined) {\n        embeddedArray = new (createNamedArrayType('LEmbeddedView' + nameSuffix(name)))();\n        LVIEW_EMBEDDED_CACHE.set(name, embeddedArray);\n      }\n      return embeddedArray;\n  }\n  throw new Error('unreachable code');\n}\n\nfunction nameSuffix(text: string | null | undefined): string {\n  if (text == null) return '';\n  const index = text.lastIndexOf('_Template');\n  return '_' + (index === -1 ? text : text.substr(0, index));\n}\n\n/**\n * This class is a debug version of Object literal so that we can have constructor name show up\n * in\n * debug tools in ngDevMode.\n */\nexport const TViewConstructor = class TView implements ITView {\n  constructor(\n      public type: TViewType,                                //\n      public id: number,                                     //\n      public blueprint: LView,                               //\n      public template: ComponentTemplate<{}>|null,           //\n      public queries: TQueries|null,                         //\n      public viewQuery: ViewQueriesFunction<{}>|null,        //\n      public node: TViewNode|TElementNode|null,              //\n      public data: TData,                                    //\n      public bindingStartIndex: number,                      //\n      public expandoStartIndex: number,                      //\n      public expandoInstructions: ExpandoInstructions|null,  //\n      public firstCreatePass: boolean,                       //\n      public firstUpdatePass: boolean,                       //\n      public staticViewQueries: boolean,                     //\n      public staticContentQueries: boolean,                  //\n      public preOrderHooks: HookData|null,                   //\n      public preOrderCheckHooks: HookData|null,              //\n      public contentHooks: HookData|null,                    //\n      public contentCheckHooks: HookData|null,               //\n      public viewHooks: HookData|null,                       //\n      public viewCheckHooks: HookData|null,                  //\n      public destroyHooks: HookData|null,                    //\n      public cleanup: any[]|null,                            //\n      public contentQueries: number[]|null,                  //\n      public components: number[]|null,                      //\n      public directiveRegistry: DirectiveDefList|null,       //\n      public pipeRegistry: PipeDefList|null,                 //\n      public firstChild: ITNode|null,                        //\n      public schemas: SchemaMetadata[]|null,                 //\n      public consts: TConstants|null,                        //\n      ) {}\n\n  get template_(): string {\n    const buf: string[] = [];\n    processTNodeChildren(this.firstChild, buf);\n    return buf.join('');\n  }\n};\n\nclass TNode implements ITNode {\n  constructor(\n      public tView_: TView,                                                          //\n      public type: TNodeType,                                                        //\n      public index: number,                                                          //\n      public injectorIndex: number,                                                  //\n      public directiveStart: number,                                                 //\n      public directiveEnd: number,                                                   //\n      public directiveStylingLast: number,                                           //\n      public propertyBindings: number[]|null,                                        //\n      public flags: TNodeFlags,                                                      //\n      public providerIndexes: TNodeProviderIndexes,                                  //\n      public tagName: string|null,                                                   //\n      public attrs: (string|AttributeMarker|(string|SelectorFlags)[])[]|null,        //\n      public mergedAttrs: (string|AttributeMarker|(string|SelectorFlags)[])[]|null,  //\n      public localNames: (string|number)[]|null,                                     //\n      public initialInputs: (string[]|null)[]|null|undefined,                        //\n      public inputs: PropertyAliases|null,                                           //\n      public outputs: PropertyAliases|null,                                          //\n      public tViews: ITView|ITView[]|null,                                           //\n      public next: ITNode|null,                                                      //\n      public projectionNext: ITNode|null,                                            //\n      public child: ITNode|null,                                                     //\n      public parent: TElementNode|TContainerNode|null,                               //\n      public projection: number|(ITNode|RNode[])[]|null,                             //\n      public styles: string|null,                                                    //\n      public residualStyles: KeyValueArray<any>|undefined|null,                      //\n      public classes: string|null,                                                   //\n      public residualClasses: KeyValueArray<any>|undefined|null,                     //\n      public classBindings: TStylingRange,                                           //\n      public styleBindings: TStylingRange,                                           //\n      ) {}\n\n  get type_(): string {\n    switch (this.type) {\n      case TNodeType.Container:\n        return 'TNodeType.Container';\n      case TNodeType.Element:\n        return 'TNodeType.Element';\n      case TNodeType.ElementContainer:\n        return 'TNodeType.ElementContainer';\n      case TNodeType.IcuContainer:\n        return 'TNodeType.IcuContainer';\n      case TNodeType.Projection:\n        return 'TNodeType.Projection';\n      case TNodeType.View:\n        return 'TNodeType.View';\n      default:\n        return 'TNodeType.???';\n    }\n  }\n\n  get flags_(): string {\n    const flags: string[] = [];\n    if (this.flags & TNodeFlags.hasClassInput) flags.push('TNodeFlags.hasClassInput');\n    if (this.flags & TNodeFlags.hasContentQuery) flags.push('TNodeFlags.hasContentQuery');\n    if (this.flags & TNodeFlags.hasStyleInput) flags.push('TNodeFlags.hasStyleInput');\n    if (this.flags & TNodeFlags.hasHostBindings) flags.push('TNodeFlags.hasHostBindings');\n    if (this.flags & TNodeFlags.isComponentHost) flags.push('TNodeFlags.isComponentHost');\n    if (this.flags & TNodeFlags.isDirectiveHost) flags.push('TNodeFlags.isDirectiveHost');\n    if (this.flags & TNodeFlags.isDetached) flags.push('TNodeFlags.isDetached');\n    if (this.flags & TNodeFlags.isProjected) flags.push('TNodeFlags.isProjected');\n    return flags.join('|');\n  }\n\n  get template_(): string {\n    const buf: string[] = [];\n    buf.push('<', this.tagName || this.type_);\n    if (this.attrs) {\n      for (let i = 0; i < this.attrs.length;) {\n        const attrName = this.attrs[i++];\n        if (typeof attrName == 'number') {\n          break;\n        }\n        const attrValue = this.attrs[i++];\n        buf.push(' ', attrName as string, '=\"', attrValue as string, '\"');\n      }\n    }\n    buf.push('>');\n    processTNodeChildren(this.child, buf);\n    buf.push('</', this.tagName || this.type_, '>');\n    return buf.join('');\n  }\n\n  get styleBindings_(): DebugStyleBindings { return toDebugStyleBinding(this, false); }\n  get classBindings_(): DebugStyleBindings { return toDebugStyleBinding(this, true); }\n}\nexport const TNodeDebug = TNode;\nexport type TNodeDebug = TNode;\n\nexport interface DebugStyleBindings extends\n    Array<KeyValueArray<any>|DebugStyleBinding|string|null> {}\nexport interface DebugStyleBinding {\n  key: TStylingKey;\n  index: number;\n  isTemplate: boolean;\n  prevDuplicate: boolean;\n  nextDuplicate: boolean;\n  prevIndex: number;\n  nextIndex: number;\n}\n\nfunction toDebugStyleBinding(tNode: TNode, isClassBased: boolean): DebugStyleBindings {\n  const tData = tNode.tView_.data;\n  const bindings: DebugStyleBindings = [] as any;\n  const range = isClassBased ? tNode.classBindings : tNode.styleBindings;\n  const prev = getTStylingRangePrev(range);\n  const next = getTStylingRangeNext(range);\n  let isTemplate = next !== 0;\n  let cursor = isTemplate ? next : prev;\n  while (cursor !== 0) {\n    const itemKey = tData[cursor] as TStylingKey;\n    const itemRange = tData[cursor + 1] as TStylingRange;\n    bindings.unshift({\n      key: itemKey,\n      index: cursor,\n      isTemplate: isTemplate,\n      prevDuplicate: getTStylingRangePrevDuplicate(itemRange),\n      nextDuplicate: getTStylingRangeNextDuplicate(itemRange),\n      nextIndex: getTStylingRangeNext(itemRange),\n      prevIndex: getTStylingRangePrev(itemRange),\n    });\n    if (cursor === prev) isTemplate = false;\n    cursor = getTStylingRangePrev(itemRange);\n  }\n  bindings.push((isClassBased ? tNode.residualClasses : tNode.residualStyles) || null);\n  return bindings;\n}\n\nfunction processTNodeChildren(tNode: ITNode | null, buf: string[]) {\n  while (tNode) {\n    buf.push((tNode as any as{template_: string}).template_);\n    tNode = tNode.next;\n  }\n}\n\nconst TViewData = NG_DEV_MODE && createNamedArrayType('TViewData') || null !as ArrayConstructor;\nlet TVIEWDATA_EMPTY:\n    unknown[];  // can't initialize here or it will not be tree shaken, because `LView`\n                // constructor could have side-effects.\n/**\n * This function clones a blueprint and creates TData.\n *\n * Simple slice will keep the same type, and we need it to be TData\n */\nexport function cloneToTViewData(list: any[]): TData {\n  if (TVIEWDATA_EMPTY === undefined) TVIEWDATA_EMPTY = new TViewData();\n  return TVIEWDATA_EMPTY.concat(list) as any;\n}\n\nexport const LViewBlueprint =\n    NG_DEV_MODE && createNamedArrayType('LViewBlueprint') || null !as ArrayConstructor;\nexport const MatchesArray =\n    NG_DEV_MODE && createNamedArrayType('MatchesArray') || null !as ArrayConstructor;\nexport const TViewComponents =\n    NG_DEV_MODE && createNamedArrayType('TViewComponents') || null !as ArrayConstructor;\nexport const TNodeLocalNames =\n    NG_DEV_MODE && createNamedArrayType('TNodeLocalNames') || null !as ArrayConstructor;\nexport const TNodeInitialInputs =\n    NG_DEV_MODE && createNamedArrayType('TNodeInitialInputs') || null !as ArrayConstructor;\nexport const TNodeInitialData =\n    NG_DEV_MODE && createNamedArrayType('TNodeInitialData') || null !as ArrayConstructor;\nexport const LCleanup =\n    NG_DEV_MODE && createNamedArrayType('LCleanup') || null !as ArrayConstructor;\nexport const TCleanup =\n    NG_DEV_MODE && createNamedArrayType('TCleanup') || null !as ArrayConstructor;\n\n\n\nexport function attachLViewDebug(lView: LView) {\n  attachDebugObject(lView, new LViewDebug(lView));\n}\n\nexport function attachLContainerDebug(lContainer: LContainer) {\n  attachDebugObject(lContainer, new LContainerDebug(lContainer));\n}\n\nexport function toDebug(obj: LView): LViewDebug;\nexport function toDebug(obj: LView | null): LViewDebug|null;\nexport function toDebug(obj: LView | LContainer | null): LViewDebug|LContainerDebug|null;\nexport function toDebug(obj: any): any {\n  if (obj) {\n    const debug = (obj as any).debug;\n    assertDefined(debug, 'Object does not have a debug representation.');\n    return debug;\n  } else {\n    return obj;\n  }\n}\n\n/**\n * Use this method to unwrap a native element in `LView` and convert it into HTML for easier\n * reading.\n *\n * @param value possibly wrapped native DOM node.\n * @param includeChildren If `true` then the serialized HTML form will include child elements\n * (same\n * as `outerHTML`). If `false` then the serialized HTML form will only contain the element\n * itself\n * (will not serialize child elements).\n */\nfunction toHtml(value: any, includeChildren: boolean = false): string|null {\n  const node: HTMLElement|null = unwrapRNode(value) as any;\n  if (node) {\n    const isTextNode = node.nodeType === Node.TEXT_NODE;\n    const outerHTML = (isTextNode ? node.textContent : node.outerHTML) || '';\n    if (includeChildren || isTextNode) {\n      return outerHTML;\n    } else {\n      const innerHTML = '>' + node.innerHTML + '<';\n      return (outerHTML.split(innerHTML)[0]) + '>';\n    }\n  } else {\n    return null;\n  }\n}\n\nexport class LViewDebug {\n  constructor(private readonly _raw_lView: LView) {}\n\n  /**\n   * Flags associated with the `LView` unpacked into a more readable state.\n   */\n  get flags() {\n    const flags = this._raw_lView[FLAGS];\n    return {\n      __raw__flags__: flags,\n      initPhaseState: flags & LViewFlags.InitPhaseStateMask,\n      creationMode: !!(flags & LViewFlags.CreationMode),\n      firstViewPass: !!(flags & LViewFlags.FirstLViewPass),\n      checkAlways: !!(flags & LViewFlags.CheckAlways),\n      dirty: !!(flags & LViewFlags.Dirty),\n      attached: !!(flags & LViewFlags.Attached),\n      destroyed: !!(flags & LViewFlags.Destroyed),\n      isRoot: !!(flags & LViewFlags.IsRoot),\n      indexWithinInitPhase: flags >> LViewFlags.IndexWithinInitPhaseShift,\n    };\n  }\n  get parent(): LViewDebug|LContainerDebug|null { return toDebug(this._raw_lView[PARENT]); }\n  get host(): string|null { return toHtml(this._raw_lView[HOST], true); }\n  get html(): string { return (this.nodes || []).map(node => toHtml(node.native, true)).join(''); }\n  get context(): {}|null { return this._raw_lView[CONTEXT]; }\n  /**\n   * The tree of nodes associated with the current `LView`. The nodes have been normalized into\n   * a\n   * tree structure with relevant details pulled out for readability.\n   */\n  get nodes(): DebugNode[]|null {\n    const lView = this._raw_lView;\n    const tNode = lView[TVIEW].firstChild;\n    return toDebugNodes(tNode, lView);\n  }\n\n  get tView() { return this._raw_lView[TVIEW]; }\n  get cleanup() { return this._raw_lView[CLEANUP]; }\n  get injector() { return this._raw_lView[INJECTOR]; }\n  get rendererFactory() { return this._raw_lView[RENDERER_FACTORY]; }\n  get renderer() { return this._raw_lView[RENDERER]; }\n  get sanitizer() { return this._raw_lView[SANITIZER]; }\n  get childHead() { return toDebug(this._raw_lView[CHILD_HEAD]); }\n  get next() { return toDebug(this._raw_lView[NEXT]); }\n  get childTail() { return toDebug(this._raw_lView[CHILD_TAIL]); }\n  get declarationView() { return toDebug(this._raw_lView[DECLARATION_VIEW]); }\n  get queries() { return this._raw_lView[QUERIES]; }\n  get tHost() { return this._raw_lView[T_HOST]; }\n\n  /**\n   * Normalized view of child views (and containers) attached at this location.\n   */\n  get childViews(): Array<LViewDebug|LContainerDebug> {\n    const childViews: Array<LViewDebug|LContainerDebug> = [];\n    let child = this.childHead;\n    while (child) {\n      childViews.push(child);\n      child = child.next;\n    }\n    return childViews;\n  }\n}\n\nexport interface DebugNode {\n  html: string|null;\n  native: Node;\n  nodes: DebugNode[]|null;\n  component: LViewDebug|null;\n}\n\n/**\n * Turns a flat list of nodes into a tree by walking the associated `TNode` tree.\n *\n * @param tNode\n * @param lView\n */\nexport function toDebugNodes(tNode: ITNode | null, lView: LView): DebugNode[]|null {\n  if (tNode) {\n    const debugNodes: DebugNode[] = [];\n    let tNodeCursor: ITNode|null = tNode;\n    while (tNodeCursor) {\n      debugNodes.push(buildDebugNode(tNodeCursor, lView, tNodeCursor.index));\n      tNodeCursor = tNodeCursor.next;\n    }\n    return debugNodes;\n  } else {\n    return null;\n  }\n}\n\nexport function buildDebugNode(tNode: ITNode, lView: LView, nodeIndex: number): DebugNode {\n  const rawValue = lView[nodeIndex];\n  const native = unwrapRNode(rawValue);\n  const componentLViewDebug = toDebug(readLViewValue(rawValue));\n  return {\n    html: toHtml(native),\n    native: native as any,\n    nodes: toDebugNodes(tNode.child, lView),\n    component: componentLViewDebug,\n  };\n}\n\nexport class LContainerDebug {\n  constructor(private readonly _raw_lContainer: LContainer) {}\n\n  get activeIndex(): number { return getLContainerActiveIndex(this._raw_lContainer); }\n  get hasTransplantedViews(): boolean {\n    return (this._raw_lContainer[ACTIVE_INDEX] & ActiveIndexFlag.HAS_TRANSPLANTED_VIEWS) ===\n        ActiveIndexFlag.HAS_TRANSPLANTED_VIEWS;\n  }\n  get views(): LViewDebug[] {\n    return this._raw_lContainer.slice(CONTAINER_HEADER_OFFSET)\n        .map(toDebug as(l: LView) => LViewDebug);\n  }\n  get parent(): LViewDebug|LContainerDebug|null { return toDebug(this._raw_lContainer[PARENT]); }\n  get movedViews(): LView[]|null { return this._raw_lContainer[MOVED_VIEWS]; }\n  get host(): RElement|RComment|LView { return this._raw_lContainer[HOST]; }\n  get native(): RComment { return this._raw_lContainer[NATIVE]; }\n  get next() { return toDebug(this._raw_lContainer[NEXT]); }\n}\n\n/**\n * Return an `LView` value if found.\n *\n * @param value `LView` if any\n */\nexport function readLViewValue(value: any): LView|null {\n  while (Array.isArray(value)) {\n    // This check is not quite right, as it does not take into account `StylingContext`\n    // This is why it is in debug, not in util.ts\n    if (value.length >= HEADER_OFFSET - 1) return value as LView;\n    value = value[HOST];\n  }\n  return null;\n}\n\nexport class I18NDebugItem {\n  [key: string]: any;\n\n  get tNode() { return getTNode(this._lView[TVIEW], this.nodeIndex); }\n\n  constructor(\n      public __raw_opCode: any, private _lView: LView, public nodeIndex: number,\n      public type: string) {}\n}\n\n/**\n * Turns a list of \"Create\" & \"Update\" OpCodes into a human-readable list of operations for\n * debugging purposes.\n * @param mutateOpCodes mutation opCodes to read\n * @param updateOpCodes update opCodes to read\n * @param icus list of ICU expressions\n * @param lView The view the opCodes are acting on\n */\nexport function attachI18nOpCodesDebug(\n    mutateOpCodes: I18nMutateOpCodes, updateOpCodes: I18nUpdateOpCodes, icus: TIcu[] | null,\n    lView: LView) {\n  attachDebugObject(mutateOpCodes, new I18nMutateOpCodesDebug(mutateOpCodes, lView));\n  attachDebugObject(updateOpCodes, new I18nUpdateOpCodesDebug(updateOpCodes, icus, lView));\n\n  if (icus) {\n    icus.forEach(icu => {\n      icu.create.forEach(\n          icuCase => { attachDebugObject(icuCase, new I18nMutateOpCodesDebug(icuCase, lView)); });\n      icu.update.forEach(icuCase => {\n        attachDebugObject(icuCase, new I18nUpdateOpCodesDebug(icuCase, icus, lView));\n      });\n    });\n  }\n}\n\nexport class I18nMutateOpCodesDebug implements I18nOpCodesDebug {\n  constructor(private readonly __raw_opCodes: I18nMutateOpCodes, private readonly __lView: LView) {}\n\n  /**\n   * A list of operation information about how the OpCodes will act on the view.\n   */\n  get operations() {\n    const {__lView, __raw_opCodes} = this;\n    const results: any[] = [];\n\n    for (let i = 0; i < __raw_opCodes.length; i++) {\n      const opCode = __raw_opCodes[i];\n      let result: any;\n      if (typeof opCode === 'string') {\n        result = {\n          __raw_opCode: opCode,\n          type: 'Create Text Node',\n          nodeIndex: __raw_opCodes[++i],\n          text: opCode,\n        };\n      }\n\n      if (typeof opCode === 'number') {\n        switch (opCode & I18nMutateOpCode.MASK_OPCODE) {\n          case I18nMutateOpCode.AppendChild:\n            const destinationNodeIndex = opCode >>> I18nMutateOpCode.SHIFT_PARENT;\n            result = new I18NDebugItem(opCode, __lView, destinationNodeIndex, 'AppendChild');\n            break;\n          case I18nMutateOpCode.Select:\n            const nodeIndex = opCode >>> I18nMutateOpCode.SHIFT_REF;\n            result = new I18NDebugItem(opCode, __lView, nodeIndex, 'Select');\n            break;\n          case I18nMutateOpCode.ElementEnd:\n            let elementIndex = opCode >>> I18nMutateOpCode.SHIFT_REF;\n            result = new I18NDebugItem(opCode, __lView, elementIndex, 'ElementEnd');\n            break;\n          case I18nMutateOpCode.Attr:\n            elementIndex = opCode >>> I18nMutateOpCode.SHIFT_REF;\n            result = new I18NDebugItem(opCode, __lView, elementIndex, 'Attr');\n            result['attrName'] = __raw_opCodes[++i];\n            result['attrValue'] = __raw_opCodes[++i];\n            break;\n        }\n      }\n\n      if (!result) {\n        switch (opCode) {\n          case COMMENT_MARKER:\n            result = {\n              __raw_opCode: opCode,\n              type: 'COMMENT_MARKER',\n              commentValue: __raw_opCodes[++i],\n              nodeIndex: __raw_opCodes[++i],\n            };\n            break;\n          case ELEMENT_MARKER:\n            result = {\n              __raw_opCode: opCode,\n              type: 'ELEMENT_MARKER',\n            };\n            break;\n        }\n      }\n\n      if (!result) {\n        result = {\n          __raw_opCode: opCode,\n          type: 'Unknown Op Code',\n          code: opCode,\n        };\n      }\n\n      results.push(result);\n    }\n\n    return results;\n  }\n}\n\nexport class I18nUpdateOpCodesDebug implements I18nOpCodesDebug {\n  constructor(\n      private readonly __raw_opCodes: I18nUpdateOpCodes, private readonly icus: TIcu[]|null,\n      private readonly __lView: LView) {}\n\n  /**\n   * A list of operation information about how the OpCodes will act on the view.\n   */\n  get operations() {\n    const {__lView, __raw_opCodes, icus} = this;\n    const results: any[] = [];\n\n    for (let i = 0; i < __raw_opCodes.length; i++) {\n      // bit code to check if we should apply the next update\n      const checkBit = __raw_opCodes[i] as number;\n      // Number of opCodes to skip until next set of update codes\n      const skipCodes = __raw_opCodes[++i] as number;\n      let value = '';\n      for (let j = i + 1; j <= (i + skipCodes); j++) {\n        const opCode = __raw_opCodes[j];\n        if (typeof opCode === 'string') {\n          value += opCode;\n        } else if (typeof opCode == 'number') {\n          if (opCode < 0) {\n            // It's a binding index whose value is negative\n            // We cannot know the value of the binding so we only show the index\n            value += `ï¿½${-opCode - 1}ï¿½`;\n          } else {\n            const nodeIndex = opCode >>> I18nUpdateOpCode.SHIFT_REF;\n            let tIcuIndex: number;\n            let tIcu: TIcu;\n            switch (opCode & I18nUpdateOpCode.MASK_OPCODE) {\n              case I18nUpdateOpCode.Attr:\n                const attrName = __raw_opCodes[++j] as string;\n                const sanitizeFn = __raw_opCodes[++j];\n                results.push({\n                  __raw_opCode: opCode,\n                  checkBit,\n                  type: 'Attr',\n                  attrValue: value, attrName, sanitizeFn,\n                });\n                break;\n              case I18nUpdateOpCode.Text:\n                results.push({\n                  __raw_opCode: opCode,\n                  checkBit,\n                  type: 'Text', nodeIndex,\n                  text: value,\n                });\n                break;\n              case I18nUpdateOpCode.IcuSwitch:\n                tIcuIndex = __raw_opCodes[++j] as number;\n                tIcu = icus ![tIcuIndex];\n                let result = new I18NDebugItem(opCode, __lView, nodeIndex, 'IcuSwitch');\n                result['tIcuIndex'] = tIcuIndex;\n                result['checkBit'] = checkBit;\n                result['mainBinding'] = value;\n                result['tIcu'] = tIcu;\n                results.push(result);\n                break;\n              case I18nUpdateOpCode.IcuUpdate:\n                tIcuIndex = __raw_opCodes[++j] as number;\n                tIcu = icus ![tIcuIndex];\n                result = new I18NDebugItem(opCode, __lView, nodeIndex, 'IcuUpdate');\n                result['tIcuIndex'] = tIcuIndex;\n                result['checkBit'] = checkBit;\n                result['tIcu'] = tIcu;\n                results.push(result);\n                break;\n            }\n          }\n        }\n      }\n      i += skipCodes;\n    }\n    return results;\n  }\n}\n\nexport interface I18nOpCodesDebug { operations: any[]; }\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {Injector} from '../../di';\nimport {ErrorHandler} from '../../error_handler';\nimport {CUSTOM_ELEMENTS_SCHEMA, NO_ERRORS_SCHEMA, SchemaMetadata} from '../../metadata/schema';\nimport {ViewEncapsulation} from '../../metadata/view';\nimport {validateAgainstEventAttributes, validateAgainstEventProperties} from '../../sanitization/sanitization';\nimport {Sanitizer} from '../../sanitization/sanitizer';\nimport {assertDataInRange, assertDefined, assertDomNode, assertEqual, assertGreaterThan, assertNotEqual, assertNotSame, assertSame} from '../../util/assert';\nimport {createNamedArrayType} from '../../util/named_array_type';\nimport {initNgDevMode} from '../../util/ng_dev_mode';\nimport {normalizeDebugBindingName, normalizeDebugBindingValue} from '../../util/ng_reflect';\nimport {assertFirstCreatePass, assertLContainer, assertLView} from '../assert';\nimport {attachPatchData} from '../context_discovery';\nimport {getFactoryDef} from '../definition';\nimport {diPublicInInjector, getNodeInjectable, getOrCreateNodeInjectorForNode} from '../di';\nimport {throwMultipleComponentError} from '../errors';\nimport {executeCheckHooks, executeInitAndCheckHooks, incrementInitPhaseFlags} from '../hooks';\nimport {ACTIVE_INDEX, ActiveIndexFlag, CONTAINER_HEADER_OFFSET, LContainer, MOVED_VIEWS} from '../interfaces/container';\nimport {ComponentDef, ComponentTemplate, DirectiveDef, DirectiveDefListOrFactory, PipeDefListOrFactory, RenderFlags, ViewQueriesFunction} from '../interfaces/definition';\nimport {INJECTOR_BLOOM_PARENT_SIZE, NodeInjectorFactory} from '../interfaces/injector';\nimport {AttributeMarker, InitialInputData, InitialInputs, LocalRefExtractor, PropertyAliasValue, PropertyAliases, TAttributes, TConstants, TContainerNode, TDirectiveHostNode, TElementContainerNode, TElementNode, TIcuContainerNode, TNode, TNodeFlags, TNodeProviderIndexes, TNodeType, TProjectionNode, TViewNode} from '../interfaces/node';\nimport {RComment, RElement, RNode, RText, Renderer3, RendererFactory3, isProceduralRenderer} from '../interfaces/renderer';\nimport {SanitizerFn} from '../interfaces/sanitization';\nimport {isComponentDef, isComponentHost, isContentQueryHost, isLContainer, isRootView} from '../interfaces/type_checks';\nimport {CHILD_HEAD, CHILD_TAIL, CLEANUP, CONTEXT, DECLARATION_COMPONENT_VIEW, DECLARATION_VIEW, FLAGS, HEADER_OFFSET, HOST, INJECTOR, InitPhaseState, LView, LViewFlags, NEXT, PARENT, RENDERER, RENDERER_FACTORY, RootContext, RootContextFlags, SANITIZER, TData, TVIEW, TView, TViewType, T_HOST} from '../interfaces/view';\nimport {assertNodeOfPossibleTypes} from '../node_assert';\nimport {isNodeMatchingSelectorList} from '../node_selector_matcher';\nimport {enterView, getBindingsEnabled, getCheckNoChangesMode, getIsParent, getPreviousOrParentTNode, getSelectedIndex, getTView, leaveView, setBindingIndex, setBindingRootForHostBindings, setCheckNoChangesMode, setCurrentQueryIndex, setPreviousOrParentTNode, setSelectedIndex} from '../state';\nimport {NO_CHANGE} from '../tokens';\nimport {isAnimationProp, mergeHostAttrs} from '../util/attrs_utils';\nimport {INTERPOLATION_DELIMITER, renderStringify, stringifyForError} from '../util/misc_utils';\nimport {getLViewParent} from '../util/view_traversal_utils';\nimport {getComponentLViewByIndex, getNativeByIndex, getNativeByTNode, getTNode, isCreationMode, readPatchedLView, resetPreOrderHookFlags, viewAttachedToChangeDetector} from '../util/view_utils';\n\nimport {selectIndexInternal} from './advance';\nimport {LCleanup, LViewBlueprint, MatchesArray, TCleanup, TNodeDebug, TNodeInitialInputs, TNodeLocalNames, TViewComponents, TViewConstructor, attachLContainerDebug, attachLViewDebug, cloneToLViewFromTViewBlueprint, cloneToTViewData} from './lview_debug';\n\n\n\n/**\n * A permanent marker promise which signifies that the current CD tree is\n * clean.\n */\nconst _CLEAN_PROMISE = (() => Promise.resolve(null))();\n\n/**\n * Process the `TView.expandoInstructions`. (Execute the `hostBindings`.)\n *\n * @param tView `TView` containing the `expandoInstructions`\n * @param lView `LView` associated with the `TView`\n */\nexport function setHostBindingsByExecutingExpandoInstructions(tView: TView, lView: LView): void {\n  ngDevMode && assertSame(tView, lView[TVIEW], '`LView` is not associated with the `TView`!');\n  try {\n    const expandoInstructions = tView.expandoInstructions;\n    if (expandoInstructions !== null) {\n      let bindingRootIndex = tView.expandoStartIndex;\n      let currentDirectiveIndex = -1;\n      let currentElementIndex = -1;\n      // TODO(misko): PERF It is possible to get here with `TView.expandoInstructions` containing no\n      // functions to execute. This is wasteful as there is no work to be done, but we still need\n      // to iterate over the instructions.\n      // In example of this is in this test: `host_binding_spec.ts`\n      // `fit('should not cause problems if detectChanges is called when a property updates', ...`\n      // In the above test we get here with expando [0, 0, 1] which requires a lot of processing but\n      // there is no function to execute.\n      for (let i = 0; i < expandoInstructions.length; i++) {\n        const instruction = expandoInstructions[i];\n        if (typeof instruction === 'number') {\n          if (instruction <= 0) {\n            // Negative numbers mean that we are starting new EXPANDO block and need to update\n            // the current element and directive index.\n            // Important: In JS `-x` and `0-x` is not the same! If `x===0` then `-x` will produce\n            // `-0` which requires non standard math arithmetic and it can prevent VM optimizations.\n            // `0-0` will always produce `0` and will not cause a potential deoptimization in VM.\n            // TODO(misko): PERF This should be refactored to use `~instruction` as that does not\n            // suffer from `-0` and it is faster/more compact.\n            currentElementIndex = 0 - instruction;\n            setSelectedIndex(currentElementIndex);\n\n            // Injector block and providers are taken into account.\n            const providerCount = (expandoInstructions[++i] as number);\n            bindingRootIndex += INJECTOR_BLOOM_PARENT_SIZE + providerCount;\n\n            currentDirectiveIndex = bindingRootIndex;\n          } else {\n            // This is either the injector size (so the binding root can skip over directives\n            // and get to the first set of host bindings on this node) or the host var count\n            // (to get to the next set of host bindings on this node).\n            bindingRootIndex += instruction;\n          }\n        } else {\n          // If it's not a number, it's a host binding function that needs to be executed.\n          if (instruction !== null) {\n            setBindingRootForHostBindings(bindingRootIndex, currentDirectiveIndex);\n            const hostCtx = lView[currentDirectiveIndex];\n            instruction(RenderFlags.Update, hostCtx);\n          }\n          // TODO(misko): PERF Relying on incrementing the `currentDirectiveIndex` here is\n          // sub-optimal. The implications are that if we have a lot of directives but none of them\n          // have host bindings we nevertheless need to iterate over the expando instructions to\n          // update the counter. It would be much better if we could encode the\n          // `currentDirectiveIndex` into the `expandoInstruction` array so that we only need to\n          // iterate over those directives which actually have `hostBindings`.\n          currentDirectiveIndex++;\n        }\n      }\n    }\n  } finally {\n    setSelectedIndex(-1);\n  }\n}\n\n/** Refreshes all content queries declared by directives in a given view */\nfunction refreshContentQueries(tView: TView, lView: LView): void {\n  const contentQueries = tView.contentQueries;\n  if (contentQueries !== null) {\n    for (let i = 0; i < contentQueries.length; i += 2) {\n      const queryStartIdx = contentQueries[i];\n      const directiveDefIdx = contentQueries[i + 1];\n      if (directiveDefIdx !== -1) {\n        const directiveDef = tView.data[directiveDefIdx] as DirectiveDef<any>;\n        ngDevMode &&\n            assertDefined(directiveDef.contentQueries, 'contentQueries function should be defined');\n        setCurrentQueryIndex(queryStartIdx);\n        directiveDef.contentQueries !(RenderFlags.Update, lView[directiveDefIdx], directiveDefIdx);\n      }\n    }\n  }\n}\n\n/** Refreshes child components in the current view (update mode). */\nfunction refreshChildComponents(hostLView: LView, components: number[]): void {\n  for (let i = 0; i < components.length; i++) {\n    refreshComponent(hostLView, components[i]);\n  }\n}\n\n/** Renders child components in the current view (creation mode). */\nfunction renderChildComponents(hostLView: LView, components: number[]): void {\n  for (let i = 0; i < components.length; i++) {\n    renderComponent(hostLView, components[i]);\n  }\n}\n\n/**\n * Creates a native element from a tag name, using a renderer.\n * @param name the tag name\n * @param renderer A renderer to use\n * @returns the element created\n */\nexport function elementCreate(\n    name: string, renderer: Renderer3, namespace: string | null): RElement {\n  if (isProceduralRenderer(renderer)) {\n    return renderer.createElement(name, namespace);\n  } else {\n    return namespace === null ? renderer.createElement(name) :\n                                renderer.createElementNS(namespace, name);\n  }\n}\n\nexport function createLView<T>(\n    parentLView: LView | null, tView: TView, context: T | null, flags: LViewFlags,\n    host: RElement | null, tHostNode: TViewNode | TElementNode | null,\n    rendererFactory?: RendererFactory3 | null, renderer?: Renderer3 | null,\n    sanitizer?: Sanitizer | null, injector?: Injector | null): LView {\n  const lView =\n      ngDevMode ? cloneToLViewFromTViewBlueprint(tView) : tView.blueprint.slice() as LView;\n  lView[HOST] = host;\n  lView[FLAGS] = flags | LViewFlags.CreationMode | LViewFlags.Attached | LViewFlags.FirstLViewPass;\n  resetPreOrderHookFlags(lView);\n  lView[PARENT] = lView[DECLARATION_VIEW] = parentLView;\n  lView[CONTEXT] = context;\n  lView[RENDERER_FACTORY] = (rendererFactory || parentLView && parentLView[RENDERER_FACTORY]) !;\n  ngDevMode && assertDefined(lView[RENDERER_FACTORY], 'RendererFactory is required');\n  lView[RENDERER] = (renderer || parentLView && parentLView[RENDERER]) !;\n  ngDevMode && assertDefined(lView[RENDERER], 'Renderer is required');\n  lView[SANITIZER] = sanitizer || parentLView && parentLView[SANITIZER] || null !;\n  lView[INJECTOR as any] = injector || parentLView && parentLView[INJECTOR] || null;\n  lView[T_HOST] = tHostNode;\n  ngDevMode && assertEqual(\n                   tView.type == TViewType.Embedded ? parentLView !== null : true, true,\n                   'Embedded views must have parentLView');\n  lView[DECLARATION_COMPONENT_VIEW] =\n      tView.type == TViewType.Embedded ? parentLView ![DECLARATION_COMPONENT_VIEW] : lView;\n  ngDevMode && attachLViewDebug(lView);\n  return lView;\n}\n\n/**\n * Create and stores the TNode, and hooks it up to the tree.\n *\n * @param tView The current `TView`.\n * @param tHostNode This is a hack and we should not have to pass this value in. It is only used to\n * determine if the parent belongs to a different tView. Instead we should not have parentTView\n * point to TView other the current one.\n * @param index The index at which the TNode should be saved (null if view, since they are not\n * saved).\n * @param type The type of TNode to create\n * @param native The native element for this node, if applicable\n * @param name The tag name of the associated native element, if applicable\n * @param attrs Any attrs for the native element, if applicable\n */\nexport function getOrCreateTNode(\n    tView: TView, tHostNode: TNode | null, index: number, type: TNodeType.Element,\n    name: string | null, attrs: TAttributes | null): TElementNode;\nexport function getOrCreateTNode(\n    tView: TView, tHostNode: TNode | null, index: number, type: TNodeType.Container,\n    name: string | null, attrs: TAttributes | null): TContainerNode;\nexport function getOrCreateTNode(\n    tView: TView, tHostNode: TNode | null, index: number, type: TNodeType.Projection, name: null,\n    attrs: TAttributes | null): TProjectionNode;\nexport function getOrCreateTNode(\n    tView: TView, tHostNode: TNode | null, index: number, type: TNodeType.ElementContainer,\n    name: string | null, attrs: TAttributes | null): TElementContainerNode;\nexport function getOrCreateTNode(\n    tView: TView, tHostNode: TNode | null, index: number, type: TNodeType.IcuContainer, name: null,\n    attrs: TAttributes | null): TElementContainerNode;\nexport function getOrCreateTNode(\n    tView: TView, tHostNode: TNode | null, index: number, type: TNodeType, name: string | null,\n    attrs: TAttributes | null): TElementNode&TContainerNode&TElementContainerNode&TProjectionNode&\n    TIcuContainerNode {\n  // Keep this function short, so that the VM will inline it.\n  const adjustedIndex = index + HEADER_OFFSET;\n  const tNode = tView.data[adjustedIndex] as TNode ||\n      createTNodeAtIndex(tView, tHostNode, adjustedIndex, type, name, attrs);\n  setPreviousOrParentTNode(tNode, true);\n  return tNode as TElementNode & TViewNode & TContainerNode & TElementContainerNode &\n      TProjectionNode & TIcuContainerNode;\n}\n\nfunction createTNodeAtIndex(\n    tView: TView, tHostNode: TNode | null, adjustedIndex: number, type: TNodeType,\n    name: string | null, attrs: TAttributes | null) {\n  const previousOrParentTNode = getPreviousOrParentTNode();\n  const isParent = getIsParent();\n  const parent =\n      isParent ? previousOrParentTNode : previousOrParentTNode && previousOrParentTNode.parent;\n  // Parents cannot cross component boundaries because components will be used in multiple places,\n  // so it's only set if the view is the same.\n  const parentInSameView = parent && parent !== tHostNode;\n  const tParentNode = parentInSameView ? parent as TElementNode | TContainerNode : null;\n  const tNode = tView.data[adjustedIndex] =\n      createTNode(tView, tParentNode, type, adjustedIndex, name, attrs);\n  // Assign a pointer to the first child node of a given view. The first node is not always the one\n  // at index 0, in case of i18n, index 0 can be the instruction `i18nStart` and the first node has\n  // the index 1 or more, so we can't just check node index.\n  if (tView.firstChild === null) {\n    tView.firstChild = tNode;\n  }\n  if (previousOrParentTNode) {\n    if (isParent && previousOrParentTNode.child == null &&\n        (tNode.parent !== null || previousOrParentTNode.type === TNodeType.View)) {\n      // We are in the same view, which means we are adding content node to the parent view.\n      previousOrParentTNode.child = tNode;\n    } else if (!isParent) {\n      previousOrParentTNode.next = tNode;\n    }\n  }\n  return tNode;\n}\n\nexport function assignTViewNodeToLView(\n    tView: TView, tParentNode: TNode | null, index: number, lView: LView): TViewNode {\n  // View nodes are not stored in data because they can be added / removed at runtime (which\n  // would cause indices to change). Their TNodes are instead stored in tView.node.\n  let tNode = tView.node;\n  if (tNode == null) {\n    ngDevMode && tParentNode &&\n        assertNodeOfPossibleTypes(tParentNode, TNodeType.Element, TNodeType.Container);\n    tView.node = tNode = createTNode(\n        tView,\n        tParentNode as TElementNode | TContainerNode | null,  //\n        TNodeType.View, index, null, null) as TViewNode;\n  }\n\n  return lView[T_HOST] = tNode as TViewNode;\n}\n\n\n/**\n * When elements are created dynamically after a view blueprint is created (e.g. through\n * i18nApply() or ComponentFactory.create), we need to adjust the blueprint for future\n * template passes.\n *\n * @param tView `TView` associated with `LView`\n * @param view The `LView` containing the blueprint to adjust\n * @param numSlotsToAlloc The number of slots to alloc in the LView, should be >0\n */\nexport function allocExpando(tView: TView, lView: LView, numSlotsToAlloc: number) {\n  ngDevMode && assertGreaterThan(\n                   numSlotsToAlloc, 0, 'The number of slots to alloc should be greater than 0');\n  if (numSlotsToAlloc > 0) {\n    if (tView.firstCreatePass) {\n      for (let i = 0; i < numSlotsToAlloc; i++) {\n        tView.blueprint.push(null);\n        tView.data.push(null);\n        lView.push(null);\n      }\n\n      // We should only increment the expando start index if there aren't already directives\n      // and injectors saved in the \"expando\" section\n      if (!tView.expandoInstructions) {\n        tView.expandoStartIndex += numSlotsToAlloc;\n      } else {\n        // Since we're adding the dynamic nodes into the expando section, we need to let the host\n        // bindings know that they should skip x slots\n        tView.expandoInstructions.push(numSlotsToAlloc);\n      }\n    }\n  }\n}\n\n\n//////////////////////////\n//// Render\n//////////////////////////\n\n/**\n * Processes a view in the creation mode. This includes a number of steps in a specific order:\n * - creating view query functions (if any);\n * - executing a template function in the creation mode;\n * - updating static queries (if any);\n * - creating child components defined in a given view.\n */\nexport function renderView<T>(tView: TView, lView: LView, context: T): void {\n  ngDevMode && assertEqual(isCreationMode(lView), true, 'Should be run in creation mode');\n  enterView(lView, lView[T_HOST]);\n  try {\n    const viewQuery = tView.viewQuery;\n    if (viewQuery !== null) {\n      executeViewQueryFn(RenderFlags.Create, viewQuery, context);\n    }\n\n    // Execute a template associated with this view, if it exists. A template function might not be\n    // defined for the root component views.\n    const templateFn = tView.template;\n    if (templateFn !== null) {\n      executeTemplate(tView, lView, templateFn, RenderFlags.Create, context);\n    }\n\n    // This needs to be set before children are processed to support recursive components.\n    // This must be set to false immediately after the first creation run because in an\n    // ngFor loop, all the views will be created together before update mode runs and turns\n    // off firstCreatePass. If we don't set it here, instances will perform directive\n    // matching, etc again and again.\n    if (tView.firstCreatePass) {\n      tView.firstCreatePass = false;\n    }\n\n    // We resolve content queries specifically marked as `static` in creation mode. Dynamic\n    // content queries are resolved during change detection (i.e. update mode), after embedded\n    // views are refreshed (see block above).\n    if (tView.staticContentQueries) {\n      refreshContentQueries(tView, lView);\n    }\n\n    // We must materialize query results before child components are processed\n    // in case a child component has projected a container. The LContainer needs\n    // to exist so the embedded views are properly attached by the container.\n    if (tView.staticViewQueries) {\n      executeViewQueryFn(RenderFlags.Update, tView.viewQuery !, context);\n    }\n\n    // Render child component views.\n    const components = tView.components;\n    if (components !== null) {\n      renderChildComponents(lView, components);\n    }\n\n  } finally {\n    lView[FLAGS] &= ~LViewFlags.CreationMode;\n    leaveView();\n  }\n}\n\n/**\n * Processes a view in update mode. This includes a number of steps in a specific order:\n * - executing a template function in update mode;\n * - executing hooks;\n * - refreshing queries;\n * - setting host bindings;\n * - refreshing child (embedded and component) views.\n */\nexport function refreshView<T>(\n    tView: TView, lView: LView, templateFn: ComponentTemplate<{}>| null, context: T) {\n  ngDevMode && assertEqual(isCreationMode(lView), false, 'Should be run in update mode');\n  const flags = lView[FLAGS];\n  if ((flags & LViewFlags.Destroyed) === LViewFlags.Destroyed) return;\n  enterView(lView, lView[T_HOST]);\n  const checkNoChangesMode = getCheckNoChangesMode();\n  try {\n    resetPreOrderHookFlags(lView);\n\n    setBindingIndex(tView.bindingStartIndex);\n    if (templateFn !== null) {\n      executeTemplate(tView, lView, templateFn, RenderFlags.Update, context);\n    }\n\n    const hooksInitPhaseCompleted =\n        (flags & LViewFlags.InitPhaseStateMask) === InitPhaseState.InitPhaseCompleted;\n\n    // execute pre-order hooks (OnInit, OnChanges, DoCheck)\n    // PERF WARNING: do NOT extract this to a separate function without running benchmarks\n    if (!checkNoChangesMode) {\n      if (hooksInitPhaseCompleted) {\n        const preOrderCheckHooks = tView.preOrderCheckHooks;\n        if (preOrderCheckHooks !== null) {\n          executeCheckHooks(lView, preOrderCheckHooks, null);\n        }\n      } else {\n        const preOrderHooks = tView.preOrderHooks;\n        if (preOrderHooks !== null) {\n          executeInitAndCheckHooks(lView, preOrderHooks, InitPhaseState.OnInitHooksToBeRun, null);\n        }\n        incrementInitPhaseFlags(lView, InitPhaseState.OnInitHooksToBeRun);\n      }\n    }\n\n    refreshDynamicEmbeddedViews(lView);\n\n    // Content query results must be refreshed before content hooks are called.\n    if (tView.contentQueries !== null) {\n      refreshContentQueries(tView, lView);\n    }\n\n    // execute content hooks (AfterContentInit, AfterContentChecked)\n    // PERF WARNING: do NOT extract this to a separate function without running benchmarks\n    if (!checkNoChangesMode) {\n      if (hooksInitPhaseCompleted) {\n        const contentCheckHooks = tView.contentCheckHooks;\n        if (contentCheckHooks !== null) {\n          executeCheckHooks(lView, contentCheckHooks);\n        }\n      } else {\n        const contentHooks = tView.contentHooks;\n        if (contentHooks !== null) {\n          executeInitAndCheckHooks(\n              lView, contentHooks, InitPhaseState.AfterContentInitHooksToBeRun);\n        }\n        incrementInitPhaseFlags(lView, InitPhaseState.AfterContentInitHooksToBeRun);\n      }\n    }\n\n    setHostBindingsByExecutingExpandoInstructions(tView, lView);\n\n    // Refresh child component views.\n    const components = tView.components;\n    if (components !== null) {\n      refreshChildComponents(lView, components);\n    }\n\n    // View queries must execute after refreshing child components because a template in this view\n    // could be inserted in a child component. If the view query executes before child component\n    // refresh, the template might not yet be inserted.\n    const viewQuery = tView.viewQuery;\n    if (viewQuery !== null) {\n      executeViewQueryFn(RenderFlags.Update, viewQuery, context);\n    }\n\n    // execute view hooks (AfterViewInit, AfterViewChecked)\n    // PERF WARNING: do NOT extract this to a separate function without running benchmarks\n    if (!checkNoChangesMode) {\n      if (hooksInitPhaseCompleted) {\n        const viewCheckHooks = tView.viewCheckHooks;\n        if (viewCheckHooks !== null) {\n          executeCheckHooks(lView, viewCheckHooks);\n        }\n      } else {\n        const viewHooks = tView.viewHooks;\n        if (viewHooks !== null) {\n          executeInitAndCheckHooks(lView, viewHooks, InitPhaseState.AfterViewInitHooksToBeRun);\n        }\n        incrementInitPhaseFlags(lView, InitPhaseState.AfterViewInitHooksToBeRun);\n      }\n    }\n    if (tView.firstUpdatePass === true) {\n      // We need to make sure that we only flip the flag on successful `refreshView` only\n      // Don't do this in `finally` block.\n      // If we did this in `finally` block then an exception could block the execution of styling\n      // instructions which in turn would be unable to insert themselves into the styling linked\n      // list. The result of this would be that if the exception would not be throw on subsequent CD\n      // the styling would be unable to process it data and reflect to the DOM.\n      tView.firstUpdatePass = false;\n    }\n\n    // Do not reset the dirty state when running in check no changes mode. We don't want components\n    // to behave differently depending on whether check no changes is enabled or not. For example:\n    // Marking an OnPush component as dirty from within the `ngAfterViewInit` hook in order to\n    // refresh a `NgClass` binding should work. If we would reset the dirty state in the check\n    // no changes cycle, the component would be not be dirty for the next update pass. This would\n    // be different in production mode where the component dirty state is not reset.\n    if (!checkNoChangesMode) {\n      lView[FLAGS] &= ~(LViewFlags.Dirty | LViewFlags.FirstLViewPass);\n    }\n  } finally {\n    leaveView();\n  }\n}\n\nexport function renderComponentOrTemplate<T>(\n    tView: TView, lView: LView, templateFn: ComponentTemplate<{}>| null, context: T) {\n  const rendererFactory = lView[RENDERER_FACTORY];\n  const normalExecutionPath = !getCheckNoChangesMode();\n  const creationModeIsActive = isCreationMode(lView);\n  try {\n    if (normalExecutionPath && !creationModeIsActive && rendererFactory.begin) {\n      rendererFactory.begin();\n    }\n    if (creationModeIsActive) {\n      renderView(tView, lView, context);\n    }\n    refreshView(tView, lView, templateFn, context);\n  } finally {\n    if (normalExecutionPath && !creationModeIsActive && rendererFactory.end) {\n      rendererFactory.end();\n    }\n  }\n}\n\nfunction executeTemplate<T>(\n    tView: TView, lView: LView, templateFn: ComponentTemplate<T>, rf: RenderFlags, context: T) {\n  const prevSelectedIndex = getSelectedIndex();\n  try {\n    setSelectedIndex(-1);\n    if (rf & RenderFlags.Update && lView.length > HEADER_OFFSET) {\n      // When we're updating, inherently select 0 so we don't\n      // have to generate that instruction for most update blocks.\n      selectIndexInternal(tView, lView, 0, getCheckNoChangesMode());\n    }\n    templateFn(rf, context);\n  } finally {\n    setSelectedIndex(prevSelectedIndex);\n  }\n}\n\n//////////////////////////\n//// Element\n//////////////////////////\n\nexport function executeContentQueries(tView: TView, tNode: TNode, lView: LView) {\n  if (isContentQueryHost(tNode)) {\n    const start = tNode.directiveStart;\n    const end = tNode.directiveEnd;\n    for (let directiveIndex = start; directiveIndex < end; directiveIndex++) {\n      const def = tView.data[directiveIndex] as DirectiveDef<any>;\n      if (def.contentQueries) {\n        def.contentQueries(RenderFlags.Create, lView[directiveIndex], directiveIndex);\n      }\n    }\n  }\n}\n\n\n/**\n * Creates directive instances.\n */\nexport function createDirectivesInstances(tView: TView, lView: LView, tNode: TDirectiveHostNode) {\n  if (!getBindingsEnabled()) return;\n  instantiateAllDirectives(tView, lView, tNode, getNativeByTNode(tNode, lView));\n  if ((tNode.flags & TNodeFlags.hasHostBindings) === TNodeFlags.hasHostBindings) {\n    invokeDirectivesHostBindings(tView, lView, tNode);\n  }\n}\n\n/**\n * Takes a list of local names and indices and pushes the resolved local variable values\n * to LView in the same order as they are loaded in the template with load().\n */\nexport function saveResolvedLocalsInData(\n    viewData: LView, tNode: TDirectiveHostNode,\n    localRefExtractor: LocalRefExtractor = getNativeByTNode): void {\n  const localNames = tNode.localNames;\n  if (localNames !== null) {\n    let localIndex = tNode.index + 1;\n    for (let i = 0; i < localNames.length; i += 2) {\n      const index = localNames[i + 1] as number;\n      const value = index === -1 ?\n          localRefExtractor(\n              tNode as TElementNode | TContainerNode | TElementContainerNode, viewData) :\n          viewData[index];\n      viewData[localIndex++] = value;\n    }\n  }\n}\n\n/**\n * Gets TView from a template function or creates a new TView\n * if it doesn't already exist.\n *\n * @param def ComponentDef\n * @returns TView\n */\nexport function getOrCreateTComponentView(def: ComponentDef<any>): TView {\n  return def.tView ||\n      (def.tView = createTView(\n           TViewType.Component, -1, def.template, def.decls, def.vars, def.directiveDefs,\n           def.pipeDefs, def.viewQuery, def.schemas, def.consts));\n}\n\n\n/**\n * Creates a TView instance\n *\n * @param viewIndex The viewBlockId for inline views, or -1 if it's a component/dynamic\n * @param templateFn Template function\n * @param decls The number of nodes, local refs, and pipes in this template\n * @param directives Registry of directives for this view\n * @param pipes Registry of pipes for this view\n * @param viewQuery View queries for this view\n * @param schemas Schemas for this view\n * @param consts Constants for this view\n */\nexport function createTView(\n    type: TViewType, viewIndex: number, templateFn: ComponentTemplate<any>| null, decls: number,\n    vars: number, directives: DirectiveDefListOrFactory | null, pipes: PipeDefListOrFactory | null,\n    viewQuery: ViewQueriesFunction<any>| null, schemas: SchemaMetadata[] | null,\n    consts: TConstants | null): TView {\n  ngDevMode && ngDevMode.tView++;\n  const bindingStartIndex = HEADER_OFFSET + decls;\n  // This length does not yet contain host bindings from child directives because at this point,\n  // we don't know which directives are active on this template. As soon as a directive is matched\n  // that has a host binding, we will update the blueprint with that def's hostVars count.\n  const initialViewLength = bindingStartIndex + vars;\n  const blueprint = createViewBlueprint(bindingStartIndex, initialViewLength);\n  return blueprint[TVIEW as any] = ngDevMode ?\n      new TViewConstructor(\n             type,\n             viewIndex,   // id: number,\n             blueprint,   // blueprint: LView,\n             templateFn,  // template: ComponentTemplate<{}>|null,\n             null,        // queries: TQueries|null\n             viewQuery,   // viewQuery: ViewQueriesFunction<{}>|null,\n             null !,      // node: TViewNode|TElementNode|null,\n             cloneToTViewData(blueprint).fill(null, bindingStartIndex),  // data: TData,\n             bindingStartIndex,  // bindingStartIndex: number,\n             initialViewLength,  // expandoStartIndex: number,\n             null,               // expandoInstructions: ExpandoInstructions|null,\n             true,               // firstCreatePass: boolean,\n             true,               // firstUpdatePass: boolean,\n             false,              // staticViewQueries: boolean,\n             false,              // staticContentQueries: boolean,\n             null,               // preOrderHooks: HookData|null,\n             null,               // preOrderCheckHooks: HookData|null,\n             null,               // contentHooks: HookData|null,\n             null,               // contentCheckHooks: HookData|null,\n             null,               // viewHooks: HookData|null,\n             null,               // viewCheckHooks: HookData|null,\n             null,               // destroyHooks: HookData|null,\n             null,               // cleanup: any[]|null,\n             null,               // contentQueries: number[]|null,\n             null,               // components: number[]|null,\n             typeof directives === 'function' ?\n                 directives() :\n                 directives,  // directiveRegistry: DirectiveDefList|null,\n             typeof pipes === 'function' ? pipes() : pipes,  // pipeRegistry: PipeDefList|null,\n             null,                                           // firstChild: TNode|null,\n             schemas,                                        // schemas: SchemaMetadata[]|null,\n             consts) :                                       // consts: TConstants|null\n      {\n        type: type,\n        id: viewIndex,\n        blueprint: blueprint,\n        template: templateFn,\n        queries: null,\n        viewQuery: viewQuery,\n        node: null !,\n        data: blueprint.slice().fill(null, bindingStartIndex),\n        bindingStartIndex: bindingStartIndex,\n        expandoStartIndex: initialViewLength,\n        expandoInstructions: null,\n        firstCreatePass: true,\n        firstUpdatePass: true,\n        staticViewQueries: false,\n        staticContentQueries: false,\n        preOrderHooks: null,\n        preOrderCheckHooks: null,\n        contentHooks: null,\n        contentCheckHooks: null,\n        viewHooks: null,\n        viewCheckHooks: null,\n        destroyHooks: null,\n        cleanup: null,\n        contentQueries: null,\n        components: null,\n        directiveRegistry: typeof directives === 'function' ? directives() : directives,\n        pipeRegistry: typeof pipes === 'function' ? pipes() : pipes,\n        firstChild: null,\n        schemas: schemas,\n        consts: consts,\n      };\n}\n\nfunction createViewBlueprint(bindingStartIndex: number, initialViewLength: number): LView {\n  const blueprint = ngDevMode ? new LViewBlueprint() : [];\n\n  for (let i = 0; i < initialViewLength; i++) {\n    blueprint.push(i < bindingStartIndex ? null : NO_CHANGE);\n  }\n\n  return blueprint as LView;\n}\n\nfunction createError(text: string, token: any) {\n  return new Error(`Renderer: ${text} [${stringifyForError(token)}]`);\n}\n\nfunction assertHostNodeExists(rElement: RElement, elementOrSelector: RElement | string) {\n  if (!rElement) {\n    if (typeof elementOrSelector === 'string') {\n      throw createError('Host node with selector not found:', elementOrSelector);\n    } else {\n      throw createError('Host node is required:', elementOrSelector);\n    }\n  }\n}\n\n/**\n * Locates the host native element, used for bootstrapping existing nodes into rendering pipeline.\n *\n * @param rendererFactory Factory function to create renderer instance.\n * @param elementOrSelector Render element or CSS selector to locate the element.\n * @param encapsulation View Encapsulation defined for component that requests host element.\n */\nexport function locateHostElement(\n    renderer: Renderer3, elementOrSelector: RElement | string,\n    encapsulation: ViewEncapsulation): RElement {\n  if (isProceduralRenderer(renderer)) {\n    // When using native Shadow DOM, do not clear host element to allow native slot projection\n    const preserveContent = encapsulation === ViewEncapsulation.ShadowDom;\n    return renderer.selectRootElement(elementOrSelector, preserveContent);\n  }\n\n  let rElement = typeof elementOrSelector === 'string' ?\n      renderer.querySelector(elementOrSelector) ! :\n      elementOrSelector;\n  ngDevMode && assertHostNodeExists(rElement, elementOrSelector);\n\n  // Always clear host element's content when Renderer3 is in use. For procedural renderer case we\n  // make it depend on whether ShadowDom encapsulation is used (in which case the content should be\n  // preserved to allow native slot projection). ShadowDom encapsulation requires procedural\n  // renderer, and procedural renderer case is handled above.\n  rElement.textContent = '';\n\n  return rElement;\n}\n\n/**\n * Saves context for this cleanup function in LView.cleanupInstances.\n *\n * On the first template pass, saves in TView:\n * - Cleanup function\n * - Index of context we just saved in LView.cleanupInstances\n */\nexport function storeCleanupWithContext(\n    tView: TView, lView: LView, context: any, cleanupFn: Function): void {\n  const lCleanup = getLCleanup(lView);\n  lCleanup.push(context);\n\n  if (tView.firstCreatePass) {\n    getTViewCleanup(tView).push(cleanupFn, lCleanup.length - 1);\n  }\n}\n\n/**\n * Saves the cleanup function itself in LView.cleanupInstances.\n *\n * This is necessary for functions that are wrapped with their contexts, like in renderer2\n * listeners.\n *\n * On the first template pass, the index of the cleanup function is saved in TView.\n */\nexport function storeCleanupFn(tView: TView, lView: LView, cleanupFn: Function): void {\n  getLCleanup(lView).push(cleanupFn);\n\n  if (tView.firstCreatePass) {\n    getTViewCleanup(tView).push(lView[CLEANUP] !.length - 1, null);\n  }\n}\n\n/**\n * Constructs a TNode object from the arguments.\n *\n * @param tView `TView` to which this `TNode` belongs (used only in `ngDevMode`)\n * @param type The type of the node\n * @param adjustedIndex The index of the TNode in TView.data, adjusted for HEADER_OFFSET\n * @param tagName The tag name of the node\n * @param attrs The attributes defined on this node\n * @param tViews Any TViews attached to this node\n * @returns the TNode object\n */\nexport function createTNode(\n    tView: TView, tParent: TElementNode | TContainerNode | null, type: TNodeType,\n    adjustedIndex: number, tagName: string | null, attrs: TAttributes | null): TNode {\n  ngDevMode && ngDevMode.tNode++;\n  let injectorIndex = tParent ? tParent.injectorIndex : -1;\n  return ngDevMode ? new TNodeDebug(\n                         tView,          // tView_: TView\n                         type,           // type: TNodeType\n                         adjustedIndex,  // index: number\n                         injectorIndex,  // injectorIndex: number\n                         -1,             // directiveStart: number\n                         -1,             // directiveEnd: number\n                         -1,             // directiveStylingLast: number\n                         null,           // propertyBindings: number[]|null\n                         0,              // flags: TNodeFlags\n                         0,              // providerIndexes: TNodeProviderIndexes\n                         tagName,        // tagName: string|null\n                         attrs,  // attrs: (string|AttributeMarker|(string|SelectorFlags)[])[]|null\n                         null,   // mergedAttrs\n                         null,   // localNames: (string|number)[]|null\n                         undefined,  // initialInputs: (string[]|null)[]|null|undefined\n                         null,       // inputs: PropertyAliases|null\n                         null,       // outputs: PropertyAliases|null\n                         null,       // tViews: ITView|ITView[]|null\n                         null,       // next: ITNode|null\n                         null,       // projectionNext: ITNode|null\n                         null,       // child: ITNode|null\n                         tParent,    // parent: TElementNode|TContainerNode|null\n                         null,       // projection: number|(ITNode|RNode[])[]|null\n                         null,       // styles: string|null\n                         undefined,  // residualStyles: string|null\n                         null,       // classes: string|null\n                         undefined,  // residualClasses: string|null\n                         0 as any,   // classBindings: TStylingRange;\n                         0 as any,   // styleBindings: TStylingRange;\n                         ) :\n                     {\n                       type: type,\n                       index: adjustedIndex,\n                       injectorIndex: injectorIndex,\n                       directiveStart: -1,\n                       directiveEnd: -1,\n                       directiveStylingLast: -1,\n                       propertyBindings: null,\n                       flags: 0,\n                       providerIndexes: 0,\n                       tagName: tagName,\n                       attrs: attrs,\n                       mergedAttrs: null,\n                       localNames: null,\n                       initialInputs: undefined,\n                       inputs: null,\n                       outputs: null,\n                       tViews: null,\n                       next: null,\n                       projectionNext: null,\n                       child: null,\n                       parent: tParent,\n                       projection: null,\n                       styles: null,\n                       residualStyles: undefined,\n                       classes: null,\n                       residualClasses: undefined,\n                       classBindings: 0 as any,\n                       styleBindings: 0 as any,\n                     };\n}\n\n\nfunction generatePropertyAliases(\n    inputAliasMap: {[publicName: string]: string}, directiveDefIdx: number,\n    propStore: PropertyAliases | null): PropertyAliases|null {\n  for (let publicName in inputAliasMap) {\n    if (inputAliasMap.hasOwnProperty(publicName)) {\n      propStore = propStore === null ? {} : propStore;\n      const internalName = inputAliasMap[publicName];\n\n      if (propStore.hasOwnProperty(publicName)) {\n        propStore[publicName].push(directiveDefIdx, internalName);\n      } else {\n        (propStore[publicName] = [directiveDefIdx, internalName]);\n      }\n    }\n  }\n  return propStore;\n}\n\n/**\n * Initializes data structures required to work with directive outputs and outputs.\n * Initialization is done for all directives matched on a given TNode.\n */\nfunction initializeInputAndOutputAliases(tView: TView, tNode: TNode): void {\n  ngDevMode && assertFirstCreatePass(tView);\n\n  const start = tNode.directiveStart;\n  const end = tNode.directiveEnd;\n  const defs = tView.data;\n\n  const tNodeAttrs = tNode.attrs;\n  const inputsFromAttrs: InitialInputData = ngDevMode ? new TNodeInitialInputs() : [];\n  let inputsStore: PropertyAliases|null = null;\n  let outputsStore: PropertyAliases|null = null;\n  for (let i = start; i < end; i++) {\n    const directiveDef = defs[i] as DirectiveDef<any>;\n    const directiveInputs = directiveDef.inputs;\n    inputsFromAttrs.push(\n        tNodeAttrs !== null ? generateInitialInputs(directiveInputs, tNodeAttrs) : null);\n    inputsStore = generatePropertyAliases(directiveInputs, i, inputsStore);\n    outputsStore = generatePropertyAliases(directiveDef.outputs, i, outputsStore);\n  }\n\n  if (inputsStore !== null) {\n    if (inputsStore.hasOwnProperty('class') || inputsStore.hasOwnProperty('className')) {\n      tNode.flags |= TNodeFlags.hasClassInput;\n    }\n    if (inputsStore.hasOwnProperty('style')) {\n      tNode.flags |= TNodeFlags.hasStyleInput;\n    }\n  }\n\n  tNode.initialInputs = inputsFromAttrs;\n  tNode.inputs = inputsStore;\n  tNode.outputs = outputsStore;\n}\n\n/**\n * Mapping between attributes names that don't correspond to their element property names.\n *\n * Performance note: this function is written as a series of if checks (instead of, say, a property\n * object lookup) for performance reasons - the series of `if` checks seems to be the fastest way of\n * mapping property names. Do NOT change without benchmarking.\n *\n * Note: this mapping has to be kept in sync with the equally named mapping in the template\n * type-checking machinery of ngtsc.\n */\nfunction mapPropName(name: string): string {\n  if (name === 'class') return 'className';\n  if (name === 'for') return 'htmlFor';\n  if (name === 'formaction') return 'formAction';\n  if (name === 'innerHtml') return 'innerHTML';\n  if (name === 'readonly') return 'readOnly';\n  if (name === 'tabindex') return 'tabIndex';\n  return name;\n}\n\nexport function elementPropertyInternal<T>(\n    tView: TView, lView: LView, index: number, propName: string, value: T,\n    sanitizer?: SanitizerFn | null, nativeOnly?: boolean,\n    loadRendererFn?: ((tNode: TNode, lView: LView) => Renderer3) | null): void {\n  ngDevMode && assertNotSame(value, NO_CHANGE as any, 'Incoming value should never be NO_CHANGE.');\n  const element = getNativeByIndex(index, lView) as RElement | RComment;\n  const tNode = getTNode(tView, index);\n  let inputData = tNode.inputs;\n  let dataValue: PropertyAliasValue|undefined;\n  if (!nativeOnly && inputData != null && (dataValue = inputData[propName])) {\n    setInputsForProperty(tView, lView, dataValue, propName, value);\n    if (isComponentHost(tNode)) markDirtyIfOnPush(lView, index + HEADER_OFFSET);\n    if (ngDevMode) {\n      setNgReflectProperties(lView, element, tNode.type, dataValue, value);\n    }\n  } else if (tNode.type === TNodeType.Element) {\n    propName = mapPropName(propName);\n\n    if (ngDevMode) {\n      validateAgainstEventProperties(propName);\n      if (!validateProperty(tView, lView, element, propName, tNode)) {\n        // Return here since we only log warnings for unknown properties.\n        warnAboutUnknownProperty(propName, tNode);\n        return;\n      }\n      ngDevMode.rendererSetProperty++;\n    }\n\n    const renderer = loadRendererFn ? loadRendererFn(tNode, lView) : lView[RENDERER];\n    // It is assumed that the sanitizer is only added when the compiler determines that the\n    // property is risky, so sanitization can be done without further checks.\n    value = sanitizer != null ? (sanitizer(value, tNode.tagName || '', propName) as any) : value;\n    if (isProceduralRenderer(renderer)) {\n      renderer.setProperty(element as RElement, propName, value);\n    } else if (!isAnimationProp(propName)) {\n      (element as RElement).setProperty ? (element as any).setProperty(propName, value) :\n                                          (element as any)[propName] = value;\n    }\n  } else if (tNode.type === TNodeType.Container) {\n    // If the node is a container and the property didn't\n    // match any of the inputs or schemas we should throw.\n    if (ngDevMode && !matchingSchemas(tView, lView, tNode.tagName)) {\n      warnAboutUnknownProperty(propName, tNode);\n    }\n  }\n}\n\n/** If node is an OnPush component, marks its LView dirty. */\nfunction markDirtyIfOnPush(lView: LView, viewIndex: number): void {\n  ngDevMode && assertLView(lView);\n  const childComponentLView = getComponentLViewByIndex(viewIndex, lView);\n  if (!(childComponentLView[FLAGS] & LViewFlags.CheckAlways)) {\n    childComponentLView[FLAGS] |= LViewFlags.Dirty;\n  }\n}\n\nfunction setNgReflectProperty(\n    lView: LView, element: RElement | RComment, type: TNodeType, attrName: string, value: any) {\n  const renderer = lView[RENDERER];\n  attrName = normalizeDebugBindingName(attrName);\n  const debugValue = normalizeDebugBindingValue(value);\n  if (type === TNodeType.Element) {\n    if (value == null) {\n      isProceduralRenderer(renderer) ? renderer.removeAttribute((element as RElement), attrName) :\n                                       (element as RElement).removeAttribute(attrName);\n    } else {\n      isProceduralRenderer(renderer) ?\n          renderer.setAttribute((element as RElement), attrName, debugValue) :\n          (element as RElement).setAttribute(attrName, debugValue);\n    }\n  } else {\n    const textContent = `bindings=${JSON.stringify({[attrName]: debugValue}, null, 2)}`;\n    if (isProceduralRenderer(renderer)) {\n      renderer.setValue((element as RComment), textContent);\n    } else {\n      (element as RComment).textContent = textContent;\n    }\n  }\n}\n\nexport function setNgReflectProperties(\n    lView: LView, element: RElement | RComment, type: TNodeType, dataValue: PropertyAliasValue,\n    value: any) {\n  if (type === TNodeType.Element || type === TNodeType.Container) {\n    /**\n     * dataValue is an array containing runtime input or output names for the directives:\n     * i+0: directive instance index\n     * i+1: privateName\n     *\n     * e.g. [0, 'change', 'change-minified']\n     * we want to set the reflected property with the privateName: dataValue[i+1]\n     */\n    for (let i = 0; i < dataValue.length; i += 2) {\n      setNgReflectProperty(lView, element, type, dataValue[i + 1] as string, value);\n    }\n  }\n}\n\nfunction validateProperty(\n    tView: TView, lView: LView, element: RElement | RComment, propName: string,\n    tNode: TNode): boolean {\n  // The property is considered valid if the element matches the schema, it exists on the element\n  // or it is synthetic, and we are in a browser context (web worker nodes should be skipped).\n  if (matchingSchemas(tView, lView, tNode.tagName) || propName in element ||\n      isAnimationProp(propName)) {\n    return true;\n  }\n\n  // Note: `typeof Node` returns 'function' in most browsers, but on IE it is 'object' so we\n  // need to account for both here, while being careful for `typeof null` also returning 'object'.\n  return typeof Node === 'undefined' || Node === null || !(element instanceof Node);\n}\n\nexport function matchingSchemas(tView: TView, lView: LView, tagName: string | null): boolean {\n  const schemas = tView.schemas;\n\n  if (schemas !== null) {\n    for (let i = 0; i < schemas.length; i++) {\n      const schema = schemas[i];\n      if (schema === NO_ERRORS_SCHEMA ||\n          schema === CUSTOM_ELEMENTS_SCHEMA && tagName && tagName.indexOf('-') > -1) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n\n/**\n * Logs a warning that a property is not supported on an element.\n * @param propName Name of the invalid property.\n * @param tNode Node on which we encountered the property.\n */\nfunction warnAboutUnknownProperty(propName: string, tNode: TNode): void {\n  console.warn(\n      `Can't bind to '${propName}' since it isn't a known property of '${tNode.tagName}'.`);\n}\n\n/**\n * Instantiate a root component.\n */\nexport function instantiateRootComponent<T>(tView: TView, lView: LView, def: ComponentDef<T>): T {\n  const rootTNode = getPreviousOrParentTNode();\n  if (tView.firstCreatePass) {\n    if (def.providersResolver) def.providersResolver(def);\n    generateExpandoInstructionBlock(tView, rootTNode, 1);\n    baseResolveDirective(tView, lView, def);\n  }\n  const directive = getNodeInjectable(lView, tView, lView.length - 1, rootTNode as TElementNode);\n  attachPatchData(directive, lView);\n  const native = getNativeByTNode(rootTNode, lView);\n  if (native) {\n    attachPatchData(native, lView);\n  }\n  return directive;\n}\n\n/**\n * Resolve the matched directives on a node.\n */\nexport function resolveDirectives(\n    tView: TView, lView: LView, tNode: TElementNode | TContainerNode | TElementContainerNode,\n    localRefs: string[] | null): boolean {\n  // Please make sure to have explicit type for `exportsMap`. Inferred type triggers bug in\n  // tsickle.\n  ngDevMode && assertFirstCreatePass(tView);\n\n  let hasDirectives = false;\n  if (getBindingsEnabled()) {\n    const directiveDefs: DirectiveDef<any>[]|null = findDirectiveDefMatches(tView, lView, tNode);\n    const exportsMap: ({[key: string]: number} | null) = localRefs === null ? null : {'': -1};\n\n    if (directiveDefs !== null) {\n      let totalDirectiveHostVars = 0;\n      hasDirectives = true;\n      initTNodeFlags(tNode, tView.data.length, directiveDefs.length);\n      // When the same token is provided by several directives on the same node, some rules apply in\n      // the viewEngine:\n      // - viewProviders have priority over providers\n      // - the last directive in NgModule.declarations has priority over the previous one\n      // So to match these rules, the order in which providers are added in the arrays is very\n      // important.\n      for (let i = 0; i < directiveDefs.length; i++) {\n        const def = directiveDefs[i];\n        if (def.providersResolver) def.providersResolver(def);\n      }\n      generateExpandoInstructionBlock(tView, tNode, directiveDefs.length);\n      let preOrderHooksFound = false;\n      let preOrderCheckHooksFound = false;\n      for (let i = 0; i < directiveDefs.length; i++) {\n        const def = directiveDefs[i];\n        // Merge the attrs in the order of matches. This assumes that the first directive is the\n        // component itself, so that the component has the least priority.\n        tNode.mergedAttrs = mergeHostAttrs(tNode.mergedAttrs, def.hostAttrs);\n\n        baseResolveDirective(tView, lView, def);\n\n        saveNameToExportMap(tView.data !.length - 1, def, exportsMap);\n\n        if (def.contentQueries !== null) tNode.flags |= TNodeFlags.hasContentQuery;\n        if (def.hostBindings !== null || def.hostAttrs !== null || def.hostVars !== 0)\n          tNode.flags |= TNodeFlags.hasHostBindings;\n\n        // Only push a node index into the preOrderHooks array if this is the first\n        // pre-order hook found on this node.\n        if (!preOrderHooksFound && (def.onChanges || def.onInit || def.doCheck)) {\n          // We will push the actual hook function into this array later during dir instantiation.\n          // We cannot do it now because we must ensure hooks are registered in the same\n          // order that directives are created (i.e. injection order).\n          (tView.preOrderHooks || (tView.preOrderHooks = [])).push(tNode.index - HEADER_OFFSET);\n          preOrderHooksFound = true;\n        }\n\n        if (!preOrderCheckHooksFound && (def.onChanges || def.doCheck)) {\n          (tView.preOrderCheckHooks || (tView.preOrderCheckHooks = [\n           ])).push(tNode.index - HEADER_OFFSET);\n          preOrderCheckHooksFound = true;\n        }\n\n        addHostBindingsToExpandoInstructions(tView, def);\n        totalDirectiveHostVars += def.hostVars;\n      }\n\n      initializeInputAndOutputAliases(tView, tNode);\n      growHostVarsSpace(tView, lView, totalDirectiveHostVars);\n    }\n    if (exportsMap) cacheMatchingLocalNames(tNode, localRefs, exportsMap);\n  }\n  // Merge the template attrs last so that they have the highest priority.\n  tNode.mergedAttrs = mergeHostAttrs(tNode.mergedAttrs, tNode.attrs);\n  return hasDirectives;\n}\n\n/**\n * Add `hostBindings` to the `TView.expandoInstructions`.\n *\n * @param tView `TView` to which the `hostBindings` should be added.\n * @param def `ComponentDef`/`DirectiveDef`, which contains the `hostVars`/`hostBindings` to add.\n */\nexport function addHostBindingsToExpandoInstructions(\n    tView: TView, def: ComponentDef<any>| DirectiveDef<any>): void {\n  ngDevMode && assertFirstCreatePass(tView);\n  const expando = tView.expandoInstructions !;\n  // TODO(misko): PERF we are adding `hostBindings` even if there is nothing to add! This is\n  // suboptimal for performance. `def.hostBindings` may be null,\n  // but we still need to push null to the array as a placeholder\n  // to ensure the directive counter is incremented (so host\n  // binding functions always line up with the corrective directive).\n  // This is suboptimal for performance. See `currentDirectiveIndex`\n  //  comment in `setHostBindingsByExecutingExpandoInstructions` for more\n  // details.  expando.push(def.hostBindings);\n  expando.push(def.hostBindings);\n  const hostVars = def.hostVars;\n  if (hostVars !== 0) {\n    expando.push(def.hostVars);\n  }\n}\n\n/**\n * Grow the `LView`, blueprint and `TView.data` to accommodate the `hostBindings`.\n *\n * To support locality we don't know ahead of time how many `hostVars` of the containing directives\n * we need to allocate. For this reason we allow growing these data structures as we discover more\n * directives to accommodate them.\n *\n * @param tView `TView` which needs to be grown.\n * @param lView `LView` which needs to be grown.\n * @param count Size by which we need to grow the data structures.\n */\nexport function growHostVarsSpace(tView: TView, lView: LView, count: number) {\n  ngDevMode && assertFirstCreatePass(tView);\n  ngDevMode && assertSame(tView, lView[TVIEW], '`LView` must be associated with `TView`!');\n  for (let i = 0; i < count; i++) {\n    lView.push(NO_CHANGE);\n    tView.blueprint.push(NO_CHANGE);\n    tView.data.push(null);\n  }\n}\n\n/**\n * Instantiate all the directives that were previously resolved on the current node.\n */\nfunction instantiateAllDirectives(\n    tView: TView, lView: LView, tNode: TDirectiveHostNode, native: RNode) {\n  const start = tNode.directiveStart;\n  const end = tNode.directiveEnd;\n  if (!tView.firstCreatePass) {\n    getOrCreateNodeInjectorForNode(tNode, lView);\n  }\n\n  attachPatchData(native, lView);\n\n  const initialInputs = tNode.initialInputs;\n  for (let i = start; i < end; i++) {\n    const def = tView.data[i] as DirectiveDef<any>;\n    const isComponent = isComponentDef(def);\n\n    if (isComponent) {\n      ngDevMode && assertNodeOfPossibleTypes(tNode, TNodeType.Element);\n      addComponentLogic(lView, tNode as TElementNode, def as ComponentDef<any>);\n    }\n\n    const directive = getNodeInjectable(lView, tView, i, tNode);\n    attachPatchData(directive, lView);\n\n    if (initialInputs !== null) {\n      setInputsFromAttrs(lView, i - start, directive, def, tNode, initialInputs !);\n    }\n\n    if (isComponent) {\n      const componentView = getComponentLViewByIndex(tNode.index, lView);\n      componentView[CONTEXT] = directive;\n    }\n  }\n}\n\nfunction invokeDirectivesHostBindings(tView: TView, lView: LView, tNode: TNode) {\n  const start = tNode.directiveStart;\n  const end = tNode.directiveEnd;\n  const expando = tView.expandoInstructions !;\n  const firstCreatePass = tView.firstCreatePass;\n  const elementIndex = tNode.index - HEADER_OFFSET;\n  try {\n    setSelectedIndex(elementIndex);\n    for (let i = start; i < end; i++) {\n      const def = tView.data[i] as DirectiveDef<any>;\n      const directive = lView[i];\n      if (def.hostBindings !== null || def.hostVars !== 0 || def.hostAttrs !== null) {\n        invokeHostBindingsInCreationMode(def, directive);\n      } else if (firstCreatePass) {\n        expando.push(null);\n      }\n    }\n  } finally {\n    setSelectedIndex(-1);\n  }\n}\n\n/**\n * Invoke the host bindings in creation mode.\n *\n * @param def `DirectiveDef` which may contain the `hostBindings` function.\n * @param directive Instance of directive.\n */\nexport function invokeHostBindingsInCreationMode(def: DirectiveDef<any>, directive: any) {\n  if (def.hostBindings !== null) {\n    def.hostBindings !(RenderFlags.Create, directive);\n  }\n}\n\n/**\n * Generates a new block in TView.expandoInstructions for this node.\n *\n * Each expando block starts with the element index (turned negative so we can distinguish\n * it from the hostVar count) and the directive count. See more in VIEW_DATA.md.\n */\nexport function generateExpandoInstructionBlock(\n    tView: TView, tNode: TNode, directiveCount: number): void {\n  ngDevMode && assertEqual(\n                   tView.firstCreatePass, true,\n                   'Expando block should only be generated on first create pass.');\n\n  // Important: In JS `-x` and `0-x` is not the same! If `x===0` then `-x` will produce `-0` which\n  // requires non standard math arithmetic and it can prevent VM optimizations.\n  // `0-0` will always produce `0` and will not cause a potential deoptimization in VM.\n  const elementIndex = HEADER_OFFSET - tNode.index;\n  const providerStartIndex = tNode.providerIndexes & TNodeProviderIndexes.ProvidersStartIndexMask;\n  const providerCount = tView.data.length - providerStartIndex;\n  (tView.expandoInstructions || (tView.expandoInstructions = [\n   ])).push(elementIndex, providerCount, directiveCount);\n}\n\n/**\n* Matches the current node against all available selectors.\n* If a component is matched (at most one), it is returned in first position in the array.\n*/\nfunction findDirectiveDefMatches(\n    tView: TView, viewData: LView,\n    tNode: TElementNode | TContainerNode | TElementContainerNode): DirectiveDef<any>[]|null {\n  ngDevMode && assertFirstCreatePass(tView);\n  ngDevMode && assertNodeOfPossibleTypes(\n                   tNode, TNodeType.Element, TNodeType.ElementContainer, TNodeType.Container);\n  const registry = tView.directiveRegistry;\n  let matches: any[]|null = null;\n  if (registry) {\n    for (let i = 0; i < registry.length; i++) {\n      const def = registry[i] as ComponentDef<any>| DirectiveDef<any>;\n      if (isNodeMatchingSelectorList(tNode, def.selectors !, /* isProjectionMode */ false)) {\n        matches || (matches = ngDevMode ? new MatchesArray() : []);\n        diPublicInInjector(getOrCreateNodeInjectorForNode(tNode, viewData), tView, def.type);\n\n        if (isComponentDef(def)) {\n          if (tNode.flags & TNodeFlags.isComponentHost) throwMultipleComponentError(tNode);\n          markAsComponentHost(tView, tNode);\n          // The component is always stored first with directives after.\n          matches.unshift(def);\n        } else {\n          matches.push(def);\n        }\n      }\n    }\n  }\n  return matches;\n}\n\n/**\n * Marks a given TNode as a component's host. This consists of:\n * - setting appropriate TNode flags;\n * - storing index of component's host element so it will be queued for view refresh during CD.\n*/\nexport function markAsComponentHost(tView: TView, hostTNode: TNode): void {\n  ngDevMode && assertFirstCreatePass(tView);\n  hostTNode.flags |= TNodeFlags.isComponentHost;\n  (tView.components || (tView.components = ngDevMode ? new TViewComponents() : [\n   ])).push(hostTNode.index);\n}\n\n\n/** Caches local names and their matching directive indices for query and template lookups. */\nfunction cacheMatchingLocalNames(\n    tNode: TNode, localRefs: string[] | null, exportsMap: {[key: string]: number}): void {\n  if (localRefs) {\n    const localNames: (string | number)[] = tNode.localNames =\n        ngDevMode ? new TNodeLocalNames() : [];\n\n    // Local names must be stored in tNode in the same order that localRefs are defined\n    // in the template to ensure the data is loaded in the same slots as their refs\n    // in the template (for template queries).\n    for (let i = 0; i < localRefs.length; i += 2) {\n      const index = exportsMap[localRefs[i + 1]];\n      if (index == null) throw new Error(`Export of name '${localRefs[i + 1]}' not found!`);\n      localNames.push(localRefs[i], index);\n    }\n  }\n}\n\n/**\n* Builds up an export map as directives are created, so local refs can be quickly mapped\n* to their directive instances.\n*/\nfunction saveNameToExportMap(\n    index: number, def: DirectiveDef<any>| ComponentDef<any>,\n    exportsMap: {[key: string]: number} | null) {\n  if (exportsMap) {\n    if (def.exportAs) {\n      for (let i = 0; i < def.exportAs.length; i++) {\n        exportsMap[def.exportAs[i]] = index;\n      }\n    }\n    if (isComponentDef(def)) exportsMap[''] = index;\n  }\n}\n\n/**\n * Initializes the flags on the current node, setting all indices to the initial index,\n * the directive count to 0, and adding the isComponent flag.\n * @param index the initial index\n */\nexport function initTNodeFlags(tNode: TNode, index: number, numberOfDirectives: number) {\n  ngDevMode && assertNotEqual(\n                   numberOfDirectives, tNode.directiveEnd - tNode.directiveStart,\n                   'Reached the max number of directives');\n  tNode.flags |= TNodeFlags.isDirectiveHost;\n  // When the first directive is created on a node, save the index\n  tNode.directiveStart = index;\n  tNode.directiveEnd = index + numberOfDirectives;\n  tNode.providerIndexes = index;\n}\n\nfunction baseResolveDirective<T>(tView: TView, viewData: LView, def: DirectiveDef<T>) {\n  tView.data.push(def);\n  const directiveFactory =\n      def.factory || ((def as{factory: Function}).factory = getFactoryDef(def.type, true));\n  const nodeInjectorFactory = new NodeInjectorFactory(directiveFactory, isComponentDef(def), null);\n  tView.blueprint.push(nodeInjectorFactory);\n  viewData.push(nodeInjectorFactory);\n}\n\nfunction addComponentLogic<T>(lView: LView, hostTNode: TElementNode, def: ComponentDef<T>): void {\n  const native = getNativeByTNode(hostTNode, lView) as RElement;\n  const tView = getOrCreateTComponentView(def);\n\n  // Only component views should be added to the view tree directly. Embedded views are\n  // accessed through their containers because they may be removed / re-added later.\n  const rendererFactory = lView[RENDERER_FACTORY];\n  const componentView = addToViewTree(\n      lView,\n      createLView(\n          lView, tView, null, def.onPush ? LViewFlags.Dirty : LViewFlags.CheckAlways, native,\n          hostTNode as TElementNode, rendererFactory, rendererFactory.createRenderer(native, def)));\n\n  // Component view will always be created before any injected LContainers,\n  // so this is a regular element, wrap it with the component view\n  lView[hostTNode.index] = componentView;\n}\n\nexport function elementAttributeInternal(\n    index: number, name: string, value: any, tView: TView, lView: LView,\n    sanitizer?: SanitizerFn | null, namespace?: string) {\n  ngDevMode && assertNotSame(value, NO_CHANGE as any, 'Incoming value should never be NO_CHANGE.');\n  ngDevMode && validateAgainstEventAttributes(name);\n  const element = getNativeByIndex(index, lView) as RElement;\n  const renderer = lView[RENDERER];\n  if (value == null) {\n    ngDevMode && ngDevMode.rendererRemoveAttribute++;\n    isProceduralRenderer(renderer) ? renderer.removeAttribute(element, name, namespace) :\n                                     element.removeAttribute(name);\n  } else {\n    ngDevMode && ngDevMode.rendererSetAttribute++;\n    const tNode = getTNode(tView, index);\n    const strValue =\n        sanitizer == null ? renderStringify(value) : sanitizer(value, tNode.tagName || '', name);\n\n\n    if (isProceduralRenderer(renderer)) {\n      renderer.setAttribute(element, name, strValue, namespace);\n    } else {\n      namespace ? element.setAttributeNS(namespace, name, strValue) :\n                  element.setAttribute(name, strValue);\n    }\n  }\n}\n\n/**\n * Sets initial input properties on directive instances from attribute data\n *\n * @param lView Current LView that is being processed.\n * @param directiveIndex Index of the directive in directives array\n * @param instance Instance of the directive on which to set the initial inputs\n * @param def The directive def that contains the list of inputs\n * @param tNode The static data for this node\n */\nfunction setInputsFromAttrs<T>(\n    lView: LView, directiveIndex: number, instance: T, def: DirectiveDef<T>, tNode: TNode,\n    initialInputData: InitialInputData): void {\n  const initialInputs: InitialInputs|null = initialInputData ![directiveIndex];\n  if (initialInputs !== null) {\n    const setInput = def.setInput;\n    for (let i = 0; i < initialInputs.length;) {\n      const publicName = initialInputs[i++];\n      const privateName = initialInputs[i++];\n      const value = initialInputs[i++];\n      if (setInput !== null) {\n        def.setInput !(instance, value, publicName, privateName);\n      } else {\n        (instance as any)[privateName] = value;\n      }\n      if (ngDevMode) {\n        const nativeElement = getNativeByTNode(tNode, lView) as RElement;\n        setNgReflectProperty(lView, nativeElement, tNode.type, privateName, value);\n      }\n    }\n  }\n}\n\n/**\n * Generates initialInputData for a node and stores it in the template's static storage\n * so subsequent template invocations don't have to recalculate it.\n *\n * initialInputData is an array containing values that need to be set as input properties\n * for directives on this node, but only once on creation. We need this array to support\n * the case where you set an @Input property of a directive using attribute-like syntax.\n * e.g. if you have a `name` @Input, you can set it once like this:\n *\n * <my-component name=\"Bess\"></my-component>\n *\n * @param inputs The list of inputs from the directive def\n * @param attrs The static attrs on this node\n */\nfunction generateInitialInputs(inputs: {[key: string]: string}, attrs: TAttributes): InitialInputs|\n    null {\n  let inputsToStore: InitialInputs|null = null;\n  let i = 0;\n  while (i < attrs.length) {\n    const attrName = attrs[i];\n    if (attrName === AttributeMarker.NamespaceURI) {\n      // We do not allow inputs on namespaced attributes.\n      i += 4;\n      continue;\n    } else if (attrName === AttributeMarker.ProjectAs) {\n      // Skip over the `ngProjectAs` value.\n      i += 2;\n      continue;\n    }\n\n    // If we hit any other attribute markers, we're done anyway. None of those are valid inputs.\n    if (typeof attrName === 'number') break;\n\n    if (inputs.hasOwnProperty(attrName as string)) {\n      if (inputsToStore === null) inputsToStore = [];\n      inputsToStore.push(attrName as string, inputs[attrName as string], attrs[i + 1] as string);\n    }\n\n    i += 2;\n  }\n  return inputsToStore;\n}\n\n//////////////////////////\n//// ViewContainer & View\n//////////////////////////\n\n// Not sure why I need to do `any` here but TS complains later.\nconst LContainerArray: any = ((typeof ngDevMode === 'undefined' || ngDevMode) && initNgDevMode()) &&\n    createNamedArrayType('LContainer');\n\n/**\n * Creates a LContainer, either from a container instruction, or for a ViewContainerRef.\n *\n * @param hostNative The host element for the LContainer\n * @param hostTNode The host TNode for the LContainer\n * @param currentView The parent view of the LContainer\n * @param native The native comment element\n * @param isForViewContainerRef Optional a flag indicating the ViewContainerRef case\n * @returns LContainer\n */\nexport function createLContainer(\n    hostNative: RElement | RComment | LView, currentView: LView, native: RComment,\n    tNode: TNode): LContainer {\n  ngDevMode && assertLView(currentView);\n  ngDevMode && !isProceduralRenderer(currentView[RENDERER]) && assertDomNode(native);\n  // https://jsperf.com/array-literal-vs-new-array-really\n  const lContainer: LContainer = new (ngDevMode ? LContainerArray : Array)(\n      hostNative,  // host native\n      true,        // Boolean `true` in this position signifies that this is an `LContainer`\n      ActiveIndexFlag.DYNAMIC_EMBEDDED_VIEWS_ONLY << ActiveIndexFlag.SHIFT,  // active index\n      currentView,                                                           // parent\n      null,                                                                  // next\n      null,                                                                  // queries\n      tNode,                                                                 // t_host\n      native,                                                                // native,\n      null,                                                                  // view refs\n      );\n  ngDevMode && attachLContainerDebug(lContainer);\n  return lContainer;\n}\n\n\n/**\n * Goes over dynamic embedded views (ones created through ViewContainerRef APIs) and refreshes\n * them by executing an associated template function.\n */\nfunction refreshDynamicEmbeddedViews(lView: LView) {\n  let viewOrContainer = lView[CHILD_HEAD];\n  while (viewOrContainer !== null) {\n    // Note: viewOrContainer can be an LView or an LContainer instance, but here we are only\n    // interested in LContainer\n    let activeIndexFlag: ActiveIndexFlag;\n    if (isLContainer(viewOrContainer) &&\n        (activeIndexFlag = viewOrContainer[ACTIVE_INDEX]) >> ActiveIndexFlag.SHIFT ===\n            ActiveIndexFlag.DYNAMIC_EMBEDDED_VIEWS_ONLY) {\n      for (let i = CONTAINER_HEADER_OFFSET; i < viewOrContainer.length; i++) {\n        const embeddedLView = viewOrContainer[i] as LView;\n        const embeddedTView = embeddedLView[TVIEW];\n        ngDevMode && assertDefined(embeddedTView, 'TView must be allocated');\n        if (viewAttachedToChangeDetector(embeddedLView)) {\n          refreshView(\n              embeddedTView, embeddedLView, embeddedTView.template, embeddedLView[CONTEXT] !);\n        }\n      }\n      if ((activeIndexFlag & ActiveIndexFlag.HAS_TRANSPLANTED_VIEWS) !== 0) {\n        // We should only CD moved views if the component where they were inserted does not match\n        // the component where they were declared and insertion is on-push. Moved views also\n        // contains intra component moves, or check-always which need to be skipped.\n        refreshTransplantedViews(viewOrContainer, lView[DECLARATION_COMPONENT_VIEW] !);\n      }\n    }\n    viewOrContainer = viewOrContainer[NEXT];\n  }\n}\n\n\n/**\n * Refresh transplanted LViews.\n *\n * See: `ActiveIndexFlag.HAS_TRANSPLANTED_VIEWS` and `LView[DECLARATION_COMPONENT_VIEW]` for\n * explanation of transplanted views.\n *\n * @param lContainer The `LContainer` which has transplanted views.\n * @param declaredComponentLView The `lContainer` parent component `LView`.\n */\nfunction refreshTransplantedViews(lContainer: LContainer, declaredComponentLView: LView) {\n  const movedViews = lContainer[MOVED_VIEWS] !;\n  ngDevMode && assertDefined(movedViews, 'Transplanted View flags set but missing MOVED_VIEWS');\n  for (let i = 0; i < movedViews.length; i++) {\n    const movedLView = movedViews[i] !;\n    const insertionLContainer = movedLView[PARENT] as LContainer;\n    ngDevMode && assertLContainer(insertionLContainer);\n    const insertedComponentLView = insertionLContainer[PARENT][DECLARATION_COMPONENT_VIEW] !;\n    ngDevMode && assertDefined(insertedComponentLView, 'Missing LView');\n    // Check if we have a transplanted view by compering declaration and insertion location.\n    if (insertedComponentLView !== declaredComponentLView) {\n      // Yes the `LView` is transplanted.\n      // Here we would like to know if the component is `OnPush`. We don't have\n      // explicit `OnPush` flag instead we set `CheckAlways` to false (which is `OnPush`)\n      // Not to be confused with `ManualOnPush` which is used with wether a DOM event\n      // should automatically mark a view as dirty.\n      const insertionComponentIsOnPush =\n          (insertedComponentLView[FLAGS] & LViewFlags.CheckAlways) === 0;\n      if (insertionComponentIsOnPush) {\n        // Here we know that the template has been transplanted across components and is\n        // on-push (not just moved within a component). If the insertion is marked dirty, then\n        // there is no need to CD here as we will do it again later when we get to insertion\n        // point.\n        const movedTView = movedLView[TVIEW];\n        ngDevMode && assertDefined(movedTView, 'TView must be allocated');\n        refreshView(movedTView, movedLView, movedTView.template, movedLView[CONTEXT] !);\n      }\n    }\n  }\n}\n\n/////////////\n\n/**\n * Refreshes components by entering the component view and processing its bindings, queries, etc.\n *\n * @param componentHostIdx  Element index in LView[] (adjusted for HEADER_OFFSET)\n */\nfunction refreshComponent(hostLView: LView, componentHostIdx: number): void {\n  ngDevMode && assertEqual(isCreationMode(hostLView), false, 'Should be run in update mode');\n  const componentView = getComponentLViewByIndex(componentHostIdx, hostLView);\n  // Only attached components that are CheckAlways or OnPush and dirty should be refreshed\n  if (viewAttachedToChangeDetector(componentView) &&\n      componentView[FLAGS] & (LViewFlags.CheckAlways | LViewFlags.Dirty)) {\n    const componentTView = componentView[TVIEW];\n    refreshView(componentTView, componentView, componentTView.template, componentView[CONTEXT]);\n  }\n}\n\nfunction renderComponent(hostLView: LView, componentHostIdx: number) {\n  ngDevMode && assertEqual(isCreationMode(hostLView), true, 'Should be run in creation mode');\n  const componentView = getComponentLViewByIndex(componentHostIdx, hostLView);\n  const componentTView = componentView[TVIEW];\n  syncViewWithBlueprint(componentTView, componentView);\n  renderView(componentTView, componentView, componentView[CONTEXT]);\n}\n\n/**\n * Syncs an LView instance with its blueprint if they have gotten out of sync.\n *\n * Typically, blueprints and their view instances should always be in sync, so the loop here\n * will be skipped. However, consider this case of two components side-by-side:\n *\n * App template:\n * ```\n * <comp></comp>\n * <comp></comp>\n * ```\n *\n * The following will happen:\n * 1. App template begins processing.\n * 2. First <comp> is matched as a component and its LView is created.\n * 3. Second <comp> is matched as a component and its LView is created.\n * 4. App template completes processing, so it's time to check child templates.\n * 5. First <comp> template is checked. It has a directive, so its def is pushed to blueprint.\n * 6. Second <comp> template is checked. Its blueprint has been updated by the first\n * <comp> template, but its LView was created before this update, so it is out of sync.\n *\n * Note that embedded views inside ngFor loops will never be out of sync because these views\n * are processed as soon as they are created.\n *\n * @param tView The `TView` that contains the blueprint for syncing\n * @param lView The view to sync\n */\nfunction syncViewWithBlueprint(tView: TView, lView: LView) {\n  for (let i = lView.length; i < tView.blueprint.length; i++) {\n    lView.push(tView.blueprint[i]);\n  }\n}\n\n/**\n * Adds LView or LContainer to the end of the current view tree.\n *\n * This structure will be used to traverse through nested views to remove listeners\n * and call onDestroy callbacks.\n *\n * @param lView The view where LView or LContainer should be added\n * @param adjustedHostIndex Index of the view's host node in LView[], adjusted for header\n * @param lViewOrLContainer The LView or LContainer to add to the view tree\n * @returns The state passed in\n */\nexport function addToViewTree<T extends LView|LContainer>(lView: LView, lViewOrLContainer: T): T {\n  // TODO(benlesh/misko): This implementation is incorrect, because it always adds the LContainer\n  // to the end of the queue, which means if the developer retrieves the LContainers from RNodes out\n  // of order, the change detection will run out of order, as the act of retrieving the the\n  // LContainer from the RNode is what adds it to the queue.\n  if (lView[CHILD_HEAD]) {\n    lView[CHILD_TAIL] ![NEXT] = lViewOrLContainer;\n  } else {\n    lView[CHILD_HEAD] = lViewOrLContainer;\n  }\n  lView[CHILD_TAIL] = lViewOrLContainer;\n  return lViewOrLContainer;\n}\n\n///////////////////////////////\n//// Change detection\n///////////////////////////////\n\n\n/**\n * Marks current view and all ancestors dirty.\n *\n * Returns the root view because it is found as a byproduct of marking the view tree\n * dirty, and can be used by methods that consume markViewDirty() to easily schedule\n * change detection. Otherwise, such methods would need to traverse up the view tree\n * an additional time to get the root view and schedule a tick on it.\n *\n * @param lView The starting LView to mark dirty\n * @returns the root LView\n */\nexport function markViewDirty(lView: LView): LView|null {\n  while (lView) {\n    lView[FLAGS] |= LViewFlags.Dirty;\n    const parent = getLViewParent(lView);\n    // Stop traversing up as soon as you find a root view that wasn't attached to any container\n    if (isRootView(lView) && !parent) {\n      return lView;\n    }\n    // continue otherwise\n    lView = parent !;\n  }\n  return null;\n}\n\n\n/**\n * Used to schedule change detection on the whole application.\n *\n * Unlike `tick`, `scheduleTick` coalesces multiple calls into one change detection run.\n * It is usually called indirectly by calling `markDirty` when the view needs to be\n * re-rendered.\n *\n * Typically `scheduleTick` uses `requestAnimationFrame` to coalesce multiple\n * `scheduleTick` requests. The scheduling function can be overridden in\n * `renderComponent`'s `scheduler` option.\n */\nexport function scheduleTick(rootContext: RootContext, flags: RootContextFlags) {\n  const nothingScheduled = rootContext.flags === RootContextFlags.Empty;\n  rootContext.flags |= flags;\n\n  if (nothingScheduled && rootContext.clean == _CLEAN_PROMISE) {\n    let res: null|((val: null) => void);\n    rootContext.clean = new Promise<null>((r) => res = r);\n    rootContext.scheduler(() => {\n      if (rootContext.flags & RootContextFlags.DetectChanges) {\n        rootContext.flags &= ~RootContextFlags.DetectChanges;\n        tickRootContext(rootContext);\n      }\n\n      if (rootContext.flags & RootContextFlags.FlushPlayers) {\n        rootContext.flags &= ~RootContextFlags.FlushPlayers;\n        const playerHandler = rootContext.playerHandler;\n        if (playerHandler) {\n          playerHandler.flushPlayers();\n        }\n      }\n\n      rootContext.clean = _CLEAN_PROMISE;\n      res !(null);\n    });\n  }\n}\n\nexport function tickRootContext(rootContext: RootContext) {\n  for (let i = 0; i < rootContext.components.length; i++) {\n    const rootComponent = rootContext.components[i];\n    const lView = readPatchedLView(rootComponent) !;\n    const tView = lView[TVIEW];\n    renderComponentOrTemplate(tView, lView, tView.template, rootComponent);\n  }\n}\n\nexport function detectChangesInternal<T>(tView: TView, lView: LView, context: T) {\n  const rendererFactory = lView[RENDERER_FACTORY];\n  if (rendererFactory.begin) rendererFactory.begin();\n  try {\n    refreshView(tView, lView, tView.template, context);\n  } catch (error) {\n    handleError(lView, error);\n    throw error;\n  } finally {\n    if (rendererFactory.end) rendererFactory.end();\n  }\n}\n\n/**\n * Synchronously perform change detection on a root view and its components.\n *\n * @param lView The view which the change detection should be performed on.\n */\nexport function detectChangesInRootView(lView: LView): void {\n  tickRootContext(lView[CONTEXT] as RootContext);\n}\n\nexport function checkNoChangesInternal<T>(tView: TView, view: LView, context: T) {\n  setCheckNoChangesMode(true);\n  try {\n    detectChangesInternal(tView, view, context);\n  } finally {\n    setCheckNoChangesMode(false);\n  }\n}\n\n/**\n * Checks the change detector on a root view and its components, and throws if any changes are\n * detected.\n *\n * This is used in development mode to verify that running change detection doesn't\n * introduce other changes.\n *\n * @param lView The view which the change detection should be checked on.\n */\nexport function checkNoChangesInRootView(lView: LView): void {\n  setCheckNoChangesMode(true);\n  try {\n    detectChangesInRootView(lView);\n  } finally {\n    setCheckNoChangesMode(false);\n  }\n}\n\nfunction executeViewQueryFn<T>(\n    flags: RenderFlags, viewQueryFn: ViewQueriesFunction<{}>, component: T): void {\n  ngDevMode && assertDefined(viewQueryFn, 'View queries function to execute must be defined.');\n  setCurrentQueryIndex(0);\n  viewQueryFn(flags, component);\n}\n\n\n///////////////////////////////\n//// Bindings & interpolations\n///////////////////////////////\n\n/**\n * Stores meta-data for a property binding to be used by TestBed's `DebugElement.properties`.\n *\n * In order to support TestBed's `DebugElement.properties` we need to save, for each binding:\n * - a bound property name;\n * - a static parts of interpolated strings;\n *\n * A given property metadata is saved at the binding's index in the `TView.data` (in other words, a\n * property binding metadata will be stored in `TView.data` at the same index as a bound value in\n * `LView`). Metadata are represented as `INTERPOLATION_DELIMITER`-delimited string with the\n * following format:\n * - `propertyName` for bound properties;\n * - `propertyNameï¿½prefixï¿½interpolation_static_part1ï¿½..interpolation_static_partNï¿½suffix` for\n * interpolated properties.\n *\n * @param tData `TData` where meta-data will be saved;\n * @param nodeIndex index of a `TNode` that is a target of the binding;\n * @param propertyName bound property name;\n * @param bindingIndex binding index in `LView`\n * @param interpolationParts static interpolation parts (for property interpolations)\n */\nexport function storePropertyBindingMetadata(\n    tData: TData, nodeIndex: number, propertyName: string, bindingIndex: number,\n    ...interpolationParts: string[]) {\n  // Binding meta-data are stored only the first time a given property instruction is processed.\n  // Since we don't have a concept of the \"first update pass\" we need to check for presence of the\n  // binding meta-data to decide if one should be stored (or if was stored already).\n  if (tData[bindingIndex] === null) {\n    const tNode = tData[nodeIndex + HEADER_OFFSET] as TNode;\n    if (tNode.inputs == null || !tNode.inputs[propertyName]) {\n      const propBindingIdxs = tNode.propertyBindings || (tNode.propertyBindings = []);\n      propBindingIdxs.push(bindingIndex);\n      let bindingMetadata = propertyName;\n      if (interpolationParts.length > 0) {\n        bindingMetadata +=\n            INTERPOLATION_DELIMITER + interpolationParts.join(INTERPOLATION_DELIMITER);\n      }\n      tData[bindingIndex] = bindingMetadata;\n    }\n  }\n}\n\nexport const CLEAN_PROMISE = _CLEAN_PROMISE;\n\nexport function getLCleanup(view: LView): any[] {\n  // top level variables should not be exported for performance reasons (PERF_NOTES.md)\n  return view[CLEANUP] || (view[CLEANUP] = ngDevMode ? new LCleanup() : []);\n}\n\nfunction getTViewCleanup(tView: TView): any[] {\n  return tView.cleanup || (tView.cleanup = ngDevMode ? new TCleanup() : []);\n}\n\n/**\n * There are cases where the sub component's renderer needs to be included\n * instead of the current renderer (see the componentSyntheticHost* instructions).\n */\nexport function loadComponentRenderer(tNode: TNode, lView: LView): Renderer3 {\n  const componentLView = lView[tNode.index] as LView;\n  return componentLView[RENDERER];\n}\n\n/** Handles an error thrown in an LView. */\nexport function handleError(lView: LView, error: any): void {\n  const injector = lView[INJECTOR];\n  const errorHandler = injector ? injector.get(ErrorHandler, null) : null;\n  errorHandler && errorHandler.handleError(error);\n}\n\n/**\n * Set the inputs of directives at the current node to corresponding value.\n *\n * @param tView The current TView\n * @param lView the `LView` which contains the directives.\n * @param inputs mapping between the public \"input\" name and privately-known,\n *        possibly minified, property names to write to.\n * @param value Value to set.\n */\nexport function setInputsForProperty(\n    tView: TView, lView: LView, inputs: PropertyAliasValue, publicName: string, value: any): void {\n  for (let i = 0; i < inputs.length;) {\n    const index = inputs[i++] as number;\n    const privateName = inputs[i++] as string;\n    const instance = lView[index];\n    ngDevMode && assertDataInRange(lView, index);\n    const def = tView.data[index] as DirectiveDef<any>;\n    if (def.setInput !== null) {\n      def.setInput !(instance, value, publicName, privateName);\n    } else {\n      instance[privateName] = value;\n    }\n  }\n}\n\n/**\n * Updates a text binding at a given index in a given LView.\n */\nexport function textBindingInternal(lView: LView, index: number, value: string): void {\n  ngDevMode && assertNotSame(value, NO_CHANGE as any, 'value should not be NO_CHANGE');\n  ngDevMode && assertDataInRange(lView, index + HEADER_OFFSET);\n  const element = getNativeByIndex(index, lView) as any as RText;\n  ngDevMode && assertDefined(element, 'native element should exist');\n  ngDevMode && ngDevMode.rendererSetText++;\n  const renderer = lView[RENDERER];\n  isProceduralRenderer(renderer) ? renderer.setValue(element, value) : element.textContent = value;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Renderer2} from '../core';\nimport {ViewEncapsulation} from '../metadata/view';\nimport {addToArray, removeFromArray} from '../util/array_utils';\nimport {assertDefined, assertDomNode, assertEqual, assertString} from '../util/assert';\nimport {assertLContainer, assertLView, assertTNodeForLView} from './assert';\nimport {attachPatchData} from './context_discovery';\nimport {ACTIVE_INDEX, ActiveIndexFlag, CONTAINER_HEADER_OFFSET, LContainer, MOVED_VIEWS, NATIVE, unusedValueExportToPlacateAjd as unused1} from './interfaces/container';\nimport {ComponentDef} from './interfaces/definition';\nimport {NodeInjectorFactory} from './interfaces/injector';\nimport {TElementNode, TNode, TNodeFlags, TNodeType, TProjectionNode, TViewNode, unusedValueExportToPlacateAjd as unused2} from './interfaces/node';\nimport {unusedValueExportToPlacateAjd as unused3} from './interfaces/projection';\nimport {ProceduralRenderer3, RElement, RNode, RText, Renderer3, isProceduralRenderer, unusedValueExportToPlacateAjd as unused4} from './interfaces/renderer';\nimport {isLContainer, isLView} from './interfaces/type_checks';\nimport {CHILD_HEAD, CLEANUP, DECLARATION_COMPONENT_VIEW, DECLARATION_LCONTAINER, FLAGS, HOST, HookData, LView, LViewFlags, NEXT, PARENT, QUERIES, RENDERER, TVIEW, TView, T_HOST, unusedValueExportToPlacateAjd as unused5} from './interfaces/view';\nimport {assertNodeOfPossibleTypes, assertNodeType} from './node_assert';\nimport {getLViewParent} from './util/view_traversal_utils';\nimport {getNativeByTNode, unwrapRNode} from './util/view_utils';\n\nconst unusedValueToPlacateAjd = unused1 + unused2 + unused3 + unused4 + unused5;\n\nexport function getLContainer(tNode: TViewNode, embeddedView: LView): LContainer|null {\n  ngDevMode && assertLView(embeddedView);\n  const container = embeddedView[PARENT] as LContainer;\n  if (tNode.index === -1) {\n    // This is a dynamically created view inside a dynamic container.\n    // The parent isn't an LContainer if the embedded view hasn't been attached yet.\n    return isLContainer(container) ? container : null;\n  } else {\n    ngDevMode && assertLContainer(container);\n    // This is a inline view node (e.g. embeddedViewStart)\n    return container;\n  }\n}\n\n\n/**\n * Retrieves render parent for a given view.\n * Might be null if a view is not yet attached to any container.\n */\nexport function getContainerRenderParent(tViewNode: TViewNode, view: LView): RElement|null {\n  const container = getLContainer(tViewNode, view);\n  return container ? nativeParentNode(view[RENDERER], container[NATIVE]) : null;\n}\n\nconst enum WalkTNodeTreeAction {\n  /** node create in the native environment. Run on initial creation. */\n  Create = 0,\n\n  /**\n   * node insert in the native environment.\n   * Run when existing node has been detached and needs to be re-attached.\n   */\n  Insert = 1,\n\n  /** node detach from the native environment */\n  Detach = 2,\n\n  /** node destruction using the renderer's API */\n  Destroy = 3,\n}\n\n\n\n/**\n * NOTE: for performance reasons, the possible actions are inlined within the function instead of\n * being passed as an argument.\n */\nfunction applyToElementOrContainer(\n    action: WalkTNodeTreeAction, renderer: Renderer3, parent: RElement | null,\n    lNodeToHandle: RNode | LContainer | LView, beforeNode?: RNode | null) {\n  // If this slot was allocated for a text node dynamically created by i18n, the text node itself\n  // won't be created until i18nApply() in the update block, so this node should be skipped.\n  // For more info, see \"ICU expressions should work inside an ngTemplateOutlet inside an ngFor\"\n  // in `i18n_spec.ts`.\n  if (lNodeToHandle != null) {\n    let lContainer: LContainer|undefined;\n    let isComponent = false;\n    // We are expecting an RNode, but in the case of a component or LContainer the `RNode` is\n    // wrapped in an array which needs to be unwrapped. We need to know if it is a component and if\n    // it has LContainer so that we can process all of those cases appropriately.\n    if (isLContainer(lNodeToHandle)) {\n      lContainer = lNodeToHandle;\n    } else if (isLView(lNodeToHandle)) {\n      isComponent = true;\n      ngDevMode && assertDefined(lNodeToHandle[HOST], 'HOST must be defined for a component LView');\n      lNodeToHandle = lNodeToHandle[HOST] !;\n    }\n    const rNode: RNode = unwrapRNode(lNodeToHandle);\n    ngDevMode && !isProceduralRenderer(renderer) && assertDomNode(rNode);\n\n    if (action === WalkTNodeTreeAction.Create && parent !== null) {\n      if (beforeNode == null) {\n        nativeAppendChild(renderer, parent, rNode);\n      } else {\n        nativeInsertBefore(renderer, parent, rNode, beforeNode || null);\n      }\n    } else if (action === WalkTNodeTreeAction.Insert && parent !== null) {\n      nativeInsertBefore(renderer, parent, rNode, beforeNode || null);\n    } else if (action === WalkTNodeTreeAction.Detach) {\n      nativeRemoveNode(renderer, rNode, isComponent);\n    } else if (action === WalkTNodeTreeAction.Destroy) {\n      ngDevMode && ngDevMode.rendererDestroyNode++;\n      (renderer as ProceduralRenderer3).destroyNode !(rNode);\n    }\n    if (lContainer != null) {\n      applyContainer(renderer, action, lContainer, parent, beforeNode);\n    }\n  }\n}\n\nexport function createTextNode(value: string, renderer: Renderer3): RText {\n  ngDevMode && ngDevMode.rendererCreateTextNode++;\n  ngDevMode && ngDevMode.rendererSetText++;\n  return isProceduralRenderer(renderer) ? renderer.createText(value) :\n                                          renderer.createTextNode(value);\n}\n\n/**\n * Adds or removes all DOM elements associated with a view.\n *\n * Because some root nodes of the view may be containers, we sometimes need\n * to propagate deeply into the nested containers to remove all elements in the\n * views beneath it.\n *\n * @param tView The `TView' of the `LView` from which elements should be added or removed\n * @param lView The view from which elements should be added or removed\n * @param insertMode Whether or not elements should be added (if false, removing)\n * @param beforeNode The node before which elements should be added, if insert mode\n */\nexport function addRemoveViewFromContainer(\n    tView: TView, lView: LView, insertMode: true, beforeNode: RNode | null): void;\nexport function addRemoveViewFromContainer(\n    tView: TView, lView: LView, insertMode: false, beforeNode: null): void;\nexport function addRemoveViewFromContainer(\n    tView: TView, lView: LView, insertMode: boolean, beforeNode: RNode | null): void {\n  const renderParent = getContainerRenderParent(tView.node as TViewNode, lView);\n  ngDevMode && assertNodeType(tView.node as TNode, TNodeType.View);\n  if (renderParent) {\n    const renderer = lView[RENDERER];\n    const action = insertMode ? WalkTNodeTreeAction.Insert : WalkTNodeTreeAction.Detach;\n    applyView(tView, lView, renderer, action, renderParent, beforeNode);\n  }\n}\n\n/**\n * Detach a `LView` from the DOM by detaching its nodes.\n *\n * @param tView The `TView' of the `LView` to be detached\n * @param lView the `LView` to be detached.\n */\nexport function renderDetachView(tView: TView, lView: LView) {\n  applyView(tView, lView, lView[RENDERER], WalkTNodeTreeAction.Detach, null, null);\n}\n\n/**\n * Traverses down and up the tree of views and containers to remove listeners and\n * call onDestroy callbacks.\n *\n * Notes:\n *  - Because it's used for onDestroy calls, it needs to be bottom-up.\n *  - Must process containers instead of their views to avoid splicing\n *  when views are destroyed and re-added.\n *  - Using a while loop because it's faster than recursion\n *  - Destroy only called on movement to sibling or movement to parent (laterally or up)\n *\n *  @param rootView The view to destroy\n */\nexport function destroyViewTree(rootView: LView): void {\n  // If the view has no children, we can clean it up and return early.\n  let lViewOrLContainer = rootView[CHILD_HEAD];\n  if (!lViewOrLContainer) {\n    return cleanUpView(rootView[TVIEW], rootView);\n  }\n\n  while (lViewOrLContainer) {\n    let next: LView|LContainer|null = null;\n\n    if (isLView(lViewOrLContainer)) {\n      // If LView, traverse down to child.\n      next = lViewOrLContainer[CHILD_HEAD];\n    } else {\n      ngDevMode && assertLContainer(lViewOrLContainer);\n      // If container, traverse down to its first LView.\n      const firstView: LView|undefined = lViewOrLContainer[CONTAINER_HEADER_OFFSET];\n      if (firstView) next = firstView;\n    }\n\n    if (!next) {\n      // Only clean up view when moving to the side or up, as destroy hooks\n      // should be called in order from the bottom up.\n      while (lViewOrLContainer && !lViewOrLContainer ![NEXT] && lViewOrLContainer !== rootView) {\n        isLView(lViewOrLContainer) && cleanUpView(lViewOrLContainer[TVIEW], lViewOrLContainer);\n        lViewOrLContainer = getParentState(lViewOrLContainer, rootView);\n      }\n      if (lViewOrLContainer === null) lViewOrLContainer = rootView;\n      isLView(lViewOrLContainer) && cleanUpView(lViewOrLContainer[TVIEW], lViewOrLContainer);\n      next = lViewOrLContainer && lViewOrLContainer ![NEXT];\n    }\n    lViewOrLContainer = next;\n  }\n}\n\n/**\n * Inserts a view into a container.\n *\n * This adds the view to the container's array of active views in the correct\n * position. It also adds the view's elements to the DOM if the container isn't a\n * root node of another view (in that case, the view's elements will be added when\n * the container's parent view is added later).\n *\n * @param tView The `TView' of the `LView` to insert\n * @param lView The view to insert\n * @param lContainer The container into which the view should be inserted\n * @param index Which index in the container to insert the child view into\n */\nexport function insertView(tView: TView, lView: LView, lContainer: LContainer, index: number) {\n  ngDevMode && assertLView(lView);\n  ngDevMode && assertLContainer(lContainer);\n  const indexInContainer = CONTAINER_HEADER_OFFSET + index;\n  const containerLength = lContainer.length;\n\n  if (index > 0) {\n    // This is a new view, we need to add it to the children.\n    lContainer[indexInContainer - 1][NEXT] = lView;\n  }\n  if (index < containerLength - CONTAINER_HEADER_OFFSET) {\n    lView[NEXT] = lContainer[indexInContainer];\n    addToArray(lContainer, CONTAINER_HEADER_OFFSET + index, lView);\n  } else {\n    lContainer.push(lView);\n    lView[NEXT] = null;\n  }\n\n  lView[PARENT] = lContainer;\n\n  // track views where declaration and insertion points are different\n  const declarationLContainer = lView[DECLARATION_LCONTAINER];\n  if (declarationLContainer !== null && lContainer !== declarationLContainer) {\n    trackMovedView(declarationLContainer, lView);\n  }\n\n  // notify query that a new view has been added\n  const lQueries = lView[QUERIES];\n  if (lQueries !== null) {\n    lQueries.insertView(tView);\n  }\n\n  // Sets the attached flag\n  lView[FLAGS] |= LViewFlags.Attached;\n}\n\n/**\n * Track views created from the declaration container (TemplateRef) and inserted into a\n * different LContainer.\n */\nfunction trackMovedView(declarationContainer: LContainer, lView: LView) {\n  ngDevMode && assertDefined(lView, 'LView required');\n  ngDevMode && assertLContainer(declarationContainer);\n  const movedViews = declarationContainer[MOVED_VIEWS];\n  const insertedLContainer = lView[PARENT] as LContainer;\n  ngDevMode && assertLContainer(insertedLContainer);\n  const insertedComponentLView = insertedLContainer[PARENT] ![DECLARATION_COMPONENT_VIEW];\n  ngDevMode && assertDefined(insertedComponentLView, 'Missing insertedComponentLView');\n  const insertedComponentIsOnPush =\n      (insertedComponentLView[FLAGS] & LViewFlags.CheckAlways) !== LViewFlags.CheckAlways;\n  if (insertedComponentIsOnPush) {\n    const declaredComponentLView = lView[DECLARATION_COMPONENT_VIEW];\n    ngDevMode && assertDefined(declaredComponentLView, 'Missing declaredComponentLView');\n    if (declaredComponentLView !== insertedComponentLView) {\n      // At this point the declaration-component is not same as insertion-component and we are in\n      // on-push mode, this means that this is a transplanted view. Mark the declared lView as\n      // having\n      // transplanted views so that those views can participate in CD.\n      declarationContainer[ACTIVE_INDEX] |= ActiveIndexFlag.HAS_TRANSPLANTED_VIEWS;\n    }\n  }\n  if (movedViews === null) {\n    declarationContainer[MOVED_VIEWS] = [lView];\n  } else {\n    movedViews.push(lView);\n  }\n}\n\nfunction detachMovedView(declarationContainer: LContainer, lView: LView) {\n  ngDevMode && assertLContainer(declarationContainer);\n  ngDevMode && assertDefined(\n                   declarationContainer[MOVED_VIEWS],\n                   'A projected view should belong to a non-empty projected views collection');\n  const movedViews = declarationContainer[MOVED_VIEWS] !;\n  const declaredViewIndex = movedViews.indexOf(lView);\n  movedViews.splice(declaredViewIndex, 1);\n}\n\n/**\n * Detaches a view from a container.\n *\n * This method removes the view from the container's array of active views. It also\n * removes the view's elements from the DOM.\n *\n * @param lContainer The container from which to detach a view\n * @param removeIndex The index of the view to detach\n * @returns Detached LView instance.\n */\nexport function detachView(lContainer: LContainer, removeIndex: number): LView|undefined {\n  if (lContainer.length <= CONTAINER_HEADER_OFFSET) return;\n\n  const indexInContainer = CONTAINER_HEADER_OFFSET + removeIndex;\n  const viewToDetach = lContainer[indexInContainer];\n\n  if (viewToDetach) {\n    const declarationLContainer = viewToDetach[DECLARATION_LCONTAINER];\n    if (declarationLContainer !== null && declarationLContainer !== lContainer) {\n      detachMovedView(declarationLContainer, viewToDetach);\n    }\n\n\n    if (removeIndex > 0) {\n      lContainer[indexInContainer - 1][NEXT] = viewToDetach[NEXT] as LView;\n    }\n    const removedLView = removeFromArray(lContainer, CONTAINER_HEADER_OFFSET + removeIndex);\n    addRemoveViewFromContainer(viewToDetach[TVIEW], viewToDetach, false, null);\n\n    // notify query that a view has been removed\n    const lQueries = removedLView[QUERIES];\n    if (lQueries !== null) {\n      lQueries.detachView(removedLView[TVIEW]);\n    }\n\n    viewToDetach[PARENT] = null;\n    viewToDetach[NEXT] = null;\n    // Unsets the attached flag\n    viewToDetach[FLAGS] &= ~LViewFlags.Attached;\n  }\n  return viewToDetach;\n}\n\n/**\n * Removes a view from a container, i.e. detaches it and then destroys the underlying LView.\n *\n * @param lContainer The container from which to remove a view\n * @param removeIndex The index of the view to remove\n */\nexport function removeView(lContainer: LContainer, removeIndex: number) {\n  const detachedView = detachView(lContainer, removeIndex);\n  detachedView && destroyLView(detachedView[TVIEW], detachedView);\n}\n\n/**\n * A standalone function which destroys an LView,\n * conducting clean up (e.g. removing listeners, calling onDestroys).\n *\n * @param tView The `TView' of the `LView` to be destroyed\n * @param lView The view to be destroyed.\n */\nexport function destroyLView(tView: TView, lView: LView) {\n  if (!(lView[FLAGS] & LViewFlags.Destroyed)) {\n    const renderer = lView[RENDERER];\n    if (isProceduralRenderer(renderer) && renderer.destroyNode) {\n      applyView(tView, lView, renderer, WalkTNodeTreeAction.Destroy, null, null);\n    }\n\n    destroyViewTree(lView);\n  }\n}\n\n/**\n * Determines which LViewOrLContainer to jump to when traversing back up the\n * tree in destroyViewTree.\n *\n * Normally, the view's parent LView should be checked, but in the case of\n * embedded views, the container (which is the view node's parent, but not the\n * LView's parent) needs to be checked for a possible next property.\n *\n * @param lViewOrLContainer The LViewOrLContainer for which we need a parent state\n * @param rootView The rootView, so we don't propagate too far up the view tree\n * @returns The correct parent LViewOrLContainer\n */\nexport function getParentState(lViewOrLContainer: LView | LContainer, rootView: LView): LView|\n    LContainer|null {\n  let tNode;\n  if (isLView(lViewOrLContainer) && (tNode = lViewOrLContainer[T_HOST]) &&\n      tNode.type === TNodeType.View) {\n    // if it's an embedded view, the state needs to go up to the container, in case the\n    // container has a next\n    return getLContainer(tNode as TViewNode, lViewOrLContainer);\n  } else {\n    // otherwise, use parent view for containers or component views\n    return lViewOrLContainer[PARENT] === rootView ? null : lViewOrLContainer[PARENT];\n  }\n}\n\n/**\n * Calls onDestroys hooks for all directives and pipes in a given view and then removes all\n * listeners. Listeners are removed as the last step so events delivered in the onDestroys hooks\n * can be propagated to @Output listeners.\n *\n * @param tView `TView` for the `LView` to clean up.\n * @param lView The LView to clean up\n */\nfunction cleanUpView(tView: TView, lView: LView): void {\n  if (!(lView[FLAGS] & LViewFlags.Destroyed)) {\n    // Usually the Attached flag is removed when the view is detached from its parent, however\n    // if it's a root view, the flag won't be unset hence why we're also removing on destroy.\n    lView[FLAGS] &= ~LViewFlags.Attached;\n\n    // Mark the LView as destroyed *before* executing the onDestroy hooks. An onDestroy hook\n    // runs arbitrary user code, which could include its own `viewRef.destroy()` (or similar). If\n    // We don't flag the view as destroyed before the hooks, this could lead to an infinite loop.\n    // This also aligns with the ViewEngine behavior. It also means that the onDestroy hook is\n    // really more of an \"afterDestroy\" hook if you think about it.\n    lView[FLAGS] |= LViewFlags.Destroyed;\n\n    executeOnDestroys(tView, lView);\n    removeListeners(tView, lView);\n    const hostTNode = lView[T_HOST];\n    // For component views only, the local renderer is destroyed as clean up time.\n    if (hostTNode && hostTNode.type === TNodeType.Element &&\n        isProceduralRenderer(lView[RENDERER])) {\n      ngDevMode && ngDevMode.rendererDestroy++;\n      (lView[RENDERER] as ProceduralRenderer3).destroy();\n    }\n\n    const declarationContainer = lView[DECLARATION_LCONTAINER];\n    // we are dealing with an embedded view that is still inserted into a container\n    if (declarationContainer !== null && isLContainer(lView[PARENT])) {\n      // and this is a projected view\n      if (declarationContainer !== lView[PARENT]) {\n        detachMovedView(declarationContainer, lView);\n      }\n\n      // For embedded views still attached to a container: remove query result from this view.\n      const lQueries = lView[QUERIES];\n      if (lQueries !== null) {\n        lQueries.detachView(tView);\n      }\n    }\n  }\n}\n\n/** Removes listeners and unsubscribes from output subscriptions */\nfunction removeListeners(tView: TView, lView: LView): void {\n  const tCleanup = tView.cleanup;\n  if (tCleanup !== null) {\n    const lCleanup = lView[CLEANUP] !;\n    for (let i = 0; i < tCleanup.length - 1; i += 2) {\n      if (typeof tCleanup[i] === 'string') {\n        // This is a native DOM listener\n        const idxOrTargetGetter = tCleanup[i + 1];\n        const target = typeof idxOrTargetGetter === 'function' ?\n            idxOrTargetGetter(lView) :\n            unwrapRNode(lView[idxOrTargetGetter]);\n        const listener = lCleanup[tCleanup[i + 2]];\n        const useCaptureOrSubIdx = tCleanup[i + 3];\n        if (typeof useCaptureOrSubIdx === 'boolean') {\n          // native DOM listener registered with Renderer3\n          target.removeEventListener(tCleanup[i], listener, useCaptureOrSubIdx);\n        } else {\n          if (useCaptureOrSubIdx >= 0) {\n            // unregister\n            lCleanup[useCaptureOrSubIdx]();\n          } else {\n            // Subscription\n            lCleanup[-useCaptureOrSubIdx].unsubscribe();\n          }\n        }\n        i += 2;\n      } else {\n        // This is a cleanup function that is grouped with the index of its context\n        const context = lCleanup[tCleanup[i + 1]];\n        tCleanup[i].call(context);\n      }\n    }\n    lView[CLEANUP] = null;\n  }\n}\n\n/** Calls onDestroy hooks for this view */\nfunction executeOnDestroys(tView: TView, lView: LView): void {\n  let destroyHooks: HookData|null;\n\n  if (tView != null && (destroyHooks = tView.destroyHooks) != null) {\n    for (let i = 0; i < destroyHooks.length; i += 2) {\n      const context = lView[destroyHooks[i] as number];\n\n      // Only call the destroy hook if the context has been requested.\n      if (!(context instanceof NodeInjectorFactory)) {\n        (destroyHooks[i + 1] as() => void).call(context);\n      }\n    }\n  }\n}\n\n/**\n * Returns a native element if a node can be inserted into the given parent.\n *\n * There are two reasons why we may not be able to insert a element immediately.\n * - Projection: When creating a child content element of a component, we have to skip the\n *   insertion because the content of a component will be projected.\n *   `<component><content>delayed due to projection</content></component>`\n * - Parent container is disconnected: This can happen when we are inserting a view into\n *   parent container, which itself is disconnected. For example the parent container is part\n *   of a View which has not be inserted or is made for projection but has not been inserted\n *   into destination.\n */\nfunction getRenderParent(tView: TView, tNode: TNode, currentView: LView): RElement|null {\n  // Skip over element and ICU containers as those are represented by a comment node and\n  // can't be used as a render parent.\n  let parentTNode = tNode.parent;\n  while (parentTNode != null && (parentTNode.type === TNodeType.ElementContainer ||\n                                 parentTNode.type === TNodeType.IcuContainer)) {\n    tNode = parentTNode;\n    parentTNode = tNode.parent;\n  }\n\n  // If the parent tNode is null, then we are inserting across views: either into an embedded view\n  // or a component view.\n  if (parentTNode == null) {\n    const hostTNode = currentView[T_HOST] !;\n    if (hostTNode.type === TNodeType.View) {\n      // We are inserting a root element of an embedded view We might delay insertion of children\n      // for a given view if it is disconnected. This might happen for 2 main reasons:\n      // - view is not inserted into any container(view was created but not inserted yet)\n      // - view is inserted into a container but the container itself is not inserted into the DOM\n      // (container might be part of projection or child of a view that is not inserted yet).\n      // In other words we can insert children of a given view if this view was inserted into a\n      // container and the container itself has its render parent determined.\n      return getContainerRenderParent(hostTNode as TViewNode, currentView);\n    } else {\n      // We are inserting a root element of the component view into the component host element and\n      // it should always be eager.\n      ngDevMode && assertNodeOfPossibleTypes(hostTNode, TNodeType.Element);\n      return currentView[HOST];\n    }\n  } else {\n    const isIcuCase = tNode && tNode.type === TNodeType.IcuContainer;\n    // If the parent of this node is an ICU container, then it is represented by comment node and we\n    // need to use it as an anchor. If it is projected then it's direct parent node is the renderer.\n    if (isIcuCase && tNode.flags & TNodeFlags.isProjected) {\n      return getNativeByTNode(tNode, currentView).parentNode as RElement;\n    }\n\n    ngDevMode && assertNodeType(parentTNode, TNodeType.Element);\n    if (parentTNode.flags & TNodeFlags.isComponentHost) {\n      const tData = tView.data;\n      const tNode = tData[parentTNode.index] as TNode;\n      const encapsulation = (tData[tNode.directiveStart] as ComponentDef<any>).encapsulation;\n\n      // We've got a parent which is an element in the current view. We just need to verify if the\n      // parent element is not a component. Component's content nodes are not inserted immediately\n      // because they will be projected, and so doing insert at this point would be wasteful.\n      // Since 